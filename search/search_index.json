{"config":{"lang":["fi"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tervetuloa kurssille","text":"<p>Kurssilla tutustutaan skriptiautomaatioon eri skriptauskielien kautta. Kurssin ohjeistus on kirjoitettu Ubuntu-jakelua ajatellen. Valtaosa teht\u00e4vist\u00e4 suoritetaan Docker-konteissa, mitk\u00e4 toimivat kaikilla k\u00e4ytt\u00f6j\u00e4rjestelmill\u00e4, mutta tietyt teht\u00e4v\u00e4t vaativat merkitt\u00e4v\u00e4sti v\u00e4hemm\u00e4n s\u00e4\u00e4t\u00f6\u00e4 Linux-ymp\u00e4rist\u00f6ss\u00e4. Helpoimman kokemuksen saat fyysisesti koneelle asennetulla Ubuntulla. Mik\u00e4li sinulla ei ole p\u00e4\u00e4sy\u00e4 omaan Linux-koneeseen, suosittelen tekem\u00e4\u00e4n teht\u00e4v\u00e4t Linux-luokassa.</p> <p>Warning</p> <p>K\u00e4yt\u00e4mme kurssilla Ansiblea. Ansible Control Noden requirement on UNIX-like -k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4. Microsoft WSL2-virtuaalikone voi toimia, mutta ei ole Ansiblen dokumentaation mukaan natiivisti tuettu. My\u00f6s verkotukset control nodejen ja managed noden v\u00e4lill\u00e4 voivat aiheuttaa ongelmia, kuten my\u00f6s mahdollinen nestattu virtualisointi.</p> <p>K\u00e4yt\u00e4mme my\u00f6s multipassia, jolla luodaan lyhytik\u00e4isi\u00e4 virtuaalikoneita silloin, kun tarvitaan kone, joka edustaa koko k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4\u00e4 varmemmin kuin kontti, joka on pikemminkin eristetty yksitt\u00e4inen prosessi. My\u00f6s t\u00e4t\u00e4 voit korvata WSL2:n avulla, mutta se vaatii huomattavaa oma-aloitteisuutta viankorjauksessa. Muut ty\u00f6kalut, kuten Vagrant, eiv\u00e4t poista ongelman juurisyyt\u00e4.</p> <p>Opettaja auttaa toki resurssien salliessa, mutta sinua on varoitettu!</p> <p>Kurssin tavoitteena on antaa opiskelijalle valmiudet lukea ja kirjoittaa skriptej\u00e4, jotka automatisoivat arkip\u00e4iv\u00e4isi\u00e4 teht\u00e4vi\u00e4. T\u00e4m\u00e4 opetellaan siten, ett\u00e4 skriptej\u00e4 testataan lyhytik\u00e4isess\u00e4, v\u00e4liaikaisessa ymp\u00e4rist\u00f6ss\u00e4, joka on helppo tuhota ja luoda uudelleen \u2013 eli konteissa ja virtuaalikoneissa. Skriptien k\u00e4ytt\u00f6 edesauttaa automatisointia, v\u00e4hent\u00e4\u00e4 inhimillisi\u00e4 virheit\u00e4, mahdollistaa tehdyn ty\u00f6n toistettavuuden sek\u00e4 muutosten j\u00e4ljitett\u00e4vyyden versionhallinnan avulla. Kurssi on vain pintaraapaisu: varsinaiset taidot karttuvat, kun otat n\u00e4m\u00e4 opit k\u00e4ytt\u00f6\u00f6n tulevissa kursseissa, projekteissa ja ty\u00f6el\u00e4m\u00e4ss\u00e4.</p> <p></p> <p>Kuva 1. DALL-E 3:n n\u00e4kemys skriptiautomaatiosta.</p>"},{"location":"#kursin-rakenne","title":"Kursin rakenne","text":"<p>Kurssin kukin osio (Bash, PowerShell, ...) rakentuu edellisen p\u00e4\u00e4lle siten, ett\u00e4 Bashist\u00e4 opittuja taitoja voidaan hy\u00f6dynt\u00e4\u00e4 seuraavissa osioissa ja niin edelleen. T\u00e4ll\u00e4 kurssilla ei opetella teoriaa tentti\u00e4 varten vaan tehd\u00e4\u00e4n kasap\u00e4in harjoituksia. Kussakin osiossa sinua neuvotaan, mist\u00e4 l\u00e4hteist\u00e4 l\u00f6yt\u00e4\u00e4 avaimet ratkaisuihin - yleens\u00e4 l\u00e4hde on cheat sheet-tyylinen opas, referenssimanuaali tai kirja. My\u00f6s teko\u00e4ly\u00e4 (kielimalleja) ja Cookbook-tyylisi\u00e4 valmiita aihioita kannattaa hy\u00f6dynt\u00e4\u00e4. Noudata kuitenkin Dowstin neuvoa:</p> <p>\"At the same time, do not just copy and paste code from GitHub or StackOverflow into your script and expect everything to work. Instead, look at the code\" </p> <p>\u2013 Matthew Dowst, Practical Automation with PowerShell</p> <p>Skriptauskielten (Bash, PowerShell, Python) osiot k\u00e4yd\u00e4\u00e4n l\u00e4pi seuraavanlaisesti:</p> <ul> <li>Kieli 101: Kokonaiskuva kielest\u00e4 ja l\u00e4hteiden kartoitus.</li> <li>Lukeminen: Tutustutaan syntaksiin valmiin skriptin avulla.</li> <li>Harjoitusosiot: Teht\u00e4v\u00e4paketteja alkuaineittain.<ul> <li>\ud83d\udca1 Gallium. Devausymp\u00e4rist\u00f6n pystytys.</li> <li>\ud83c\udf86 Strontium. Harjoituksia.</li> <li>\ud83d\udc69\u200d\ud83d\udd2c Curium. Lis\u00e4\u00e4 harjoituksia.</li> <li>\ud83d\udc68\u200d\ud83d\udd2c Einsteinium. Viimeiset harjoitukset.</li> </ul> </li> </ul> <p>Alkuaineittain j\u00e4rjestetyt teht\u00e4v\u00e4t Galliumista Einsteiniumiin ovat tarkoitetut j\u00e4rjestyksess\u00e4 suoritettaviksi. Jaottelu auttaa sinua palastelemaan teht\u00e4vi\u00e4 omalle TODO-listallesi. Huolehdithan omasta ajank\u00e4yt\u00f6st\u00e4si ja kurssin harjoitusten tasaisesta etenemisest\u00e4. \u00c4l\u00e4 miss\u00e4\u00e4n nimess\u00e4 yrit\u00e4 j\u00e4tt\u00e4\u00e4 kaikkea viimeiseen iltaan!</p>"},{"location":"#edeltavyysvaatimukset","title":"Edelt\u00e4vyysvaatimukset","text":"<p>Sinun t\u00e4ytyy olla valmiiksi sinut komentorivin kanssa. Linux Perusteet -kurssin k\u00e4yminen ennen t\u00e4t\u00e4 kurssia on edellytys. Lis\u00e4ksi on \u00e4\u00e4rimm\u00e4isen suositeltavaa, ett\u00e4 osaat v\u00e4hint\u00e4\u00e4n yhdest\u00e4 ohjelmointikielest\u00e4 perusteet siten, ett\u00e4 alla esitellyt termit eiv\u00e4t ole sinulle t\u00e4ysin vieraita. Kurssi voi olla hyv\u00e4\u00e4 kertausta n\u00e4ist\u00e4 aiheista, mutta eth\u00e4n saavu paikalle t\u00e4ysin vihre\u00e4n\u00e4. Muutoin oppimiskokemus voi olla turhauttava.</p> <ul> <li>Muuttujat: int, float, string, ...</li> <li>Ehtolauseet: if, else, case/switch</li> <li>Silmukat: for, while, foreach</li> <li>Funktiot: do_something(param1, param2)</li> </ul>"},{"location":"exercises/","title":"Teht\u00e4v\u00e4kooste","text":"<p>T\u00e4ss\u00e4 tiedostossa on listattuna kaikki materiaalin teht\u00e4v\u00e4t. Osa niist\u00e4 ei v\u00e4ltt\u00e4m\u00e4tt\u00e4  kuulu sinun kurssitoteutukseesi. Huomaa, ett\u00e4 t\u00e4m\u00e4 tiedosto luodaan automaattisesti parsimalla  kaikki repositorion Markdown-tiedostot l\u00e4pi. Mik\u00e4li huomaat puuttuvia teht\u00e4vi\u00e4, ilmoita opettajalle. Otsikon per\u00e4ss\u00e4 suluissa oleva numero on j\u00e4rjestysprioriteetti: se vaikuttaa vain t\u00e4m\u00e4n listan j\u00e4rjestykseen.</p> <p>Lista hy\u00f6dynt\u00e4\u00e4 Material for MkDocs -teeman Tasklist -ominaisuutta.</p> <p>Kopioi teht\u00e4v\u00e4lista leikep\u00f6yd\u00e4lle ja muokkaa se sinun k\u00e4ytt\u00f6\u00f6si sopivaksi.</p> <pre><code>## Bash 101 (100)\n\n- [ ] Teht\u00e4v\u00e4: Bash informaatiohaku\n\n## Lukeminen (110)\n\n- [ ] Teht\u00e4v\u00e4: Parsi Bash-skripti\n\n## \ud83d\udca1 Gallium (131)\n\n- [ ] Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runbash.sh\n- [ ] Teht\u00e4v\u00e4: Bash Hello World\n- [ ] Teht\u00e4v\u00e4: Turboahdettu Bash Hello World\n- [ ] Teht\u00e4v\u00e4: Interaktiivinen Bash\n- [ ] Teht\u00e4v\u00e4: Bash vianetsint\u00e4\n\n## \ud83c\udf86 Strontium (138)\n\n- [ ] Teht\u00e4v\u00e4: Arvaa numero\n- [ ] Teht\u00e4v\u00e4: Reminder\n- [ ] Teht\u00e4v\u00e4: Staattinen analyysi (Shellcheck)\n- [ ] Teht\u00e4v\u00e4: Korjaa skriptit\n\n## \ud83d\udc69\u200d\ud83d\udd2c Curium (196)\n\n- [ ] Teht\u00e4v\u00e4: Pilkulla erottelu\n- [ ] Teht\u00e4v\u00e4: Pizzat\u00e4ytteet\n- [ ] Teht\u00e4v\u00e4: P\u00e4iv\u00e4m\u00e4\u00e4r\u00e4n analysointi\n- [ ] Teht\u00e4v\u00e4: Swap\n\n## \ud83d\udc68\u200d\ud83d\udd2c Einsteinium (199)\n\n- [ ] Teht\u00e4v\u00e4: Argumenttien parsiminen\n- [ ] Teht\u00e4v\u00e4: Multipass-harjoituskentt\u00e4\n- [ ] Teht\u00e4v\u00e4: Einstein-level Oppimisp\u00e4iv\u00e4kirja\n- [ ] Teht\u00e4v\u00e4: Oppimisp\u00e4iv\u00e4kirjan jatkot\n\n## PowerShell 101 (200)\n\n- [ ] Teht\u00e4v\u00e4: PowerShell Hello World\n- [ ] Teht\u00e4v\u00e4: PowerShell informaatiohaku\n\n## Lukeminen (210)\n\n- [ ] Teht\u00e4v\u00e4: Parsi PowerShell-skripti\n\n## \ud83d\udca1 Gallium (231)\n\n- [ ] Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runpwsh.sh\n- [ ] Teht\u00e4v\u00e4: PowerShell Hello World\n- [ ] Teht\u00e4v\u00e4: PowerShell Turboahdettu Hello World\n- [ ] Teht\u00e4v\u00e4: Save-Help\n- [ ] Teht\u00e4v\u00e4: gitignore .help\n- [ ] Teht\u00e4v\u00e4: localhelp.ps1\n\n## \ud83c\udf86 Strontium (238)\n\n- [ ] Teht\u00e4v\u00e4: Arvaa numero\n- [ ] Teht\u00e4v\u00e4: Reminder\n- [ ] Teht\u00e4v\u00e4: Verb-Noun generaattori\n- [ ] Teht\u00e4v\u00e4: Staattinen analyysi (PSScriptAnalyzer)\n\n## \ud83d\udc69\u200d\ud83d\udd2c Curium (296)\n\n- [ ] Teht\u00e4v\u00e4: Pingviinien laskeminen\n- [ ] Teht\u00e4v\u00e4: Suurimmat ohjelmat\n- [ ] Teht\u00e4v\u00e4: Duplikaattitiedostojen luominen\n- [ ] Teht\u00e4v\u00e4: Duplikaattien tunnistaminen\n\n## \ud83d\udc68\u200d\ud83d\udd2c Einsteinium (299)\n\n- [ ] Teht\u00e4v\u00e4: PowerShell Docker Wrapper\n\n## Python 101 (300)\n\n- [ ] Teht\u00e4v\u00e4: Python informaatiohaku\n\n## Lukeminen (310)\n\n- [ ] Teht\u00e4v\u00e4: Python Devausymp\u00e4rist\u00f6\n- [ ] Teht\u00e4v\u00e4: Parsi Python-skriptit\n\n## \ud83d\udca1 Gallium (331)\n\n- [ ] Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runpy.py\n- [ ] Teht\u00e4v\u00e4: Python Hello World\n- [ ] Teht\u00e4v\u00e4: Python Turboahdettu Hello World\n- [ ] Teht\u00e4v\u00e4: Interaktiivinen Python\n- [ ] Teht\u00e4v\u00e4: Interaktiivinen Python Pt. 2\n- [ ] Teht\u00e4v\u00e4: Tiedostoon loggaus\n- [ ] Teht\u00e4v\u00e4: Ruff\n\n## \ud83c\udf86 Strontium (338)\n\n- [ ] Teht\u00e4v\u00e4: Arvaa numero\n- [ ] Teht\u00e4v\u00e4: Reminder\n- [ ] Teht\u00e4v\u00e4: breakpoint()\n- [ ] Teht\u00e4v\u00e4: IP Address\n\n## \ud83d\udc69\u200d\ud83d\udd2c Curium (396)\n\n- [ ] Teht\u00e4v\u00e4: Pingviinien laskeminen\n- [ ] Teht\u00e4v\u00e4: Suurimmat ohjelmat\n- [ ] Teht\u00e4v\u00e4: Duplikaattitiedostojen luominen\n- [ ] Teht\u00e4v\u00e4: Duplikaattien tunnistaminen\n- [ ] Teht\u00e4v\u00e4: Tulosta PATH-muuttujan hakemistot\n\n## \ud83d\udc68\u200d\ud83d\udd2c Einsteinium (399)\n\n- [ ] Teht\u00e4v\u00e4: Paste.ee\n- [ ] Teht\u00e4v\u00e4: Premiere Markers to YouTube\n- [ ] Teht\u00e4v\u00e4: Arvaa luku botti\n\n## Ansible 101 (400)\n\n- [ ] Teht\u00e4v\u00e4: Ansiblen informaatiohaku\n\n## Lukeminen (410)\n\n- [ ] Teht\u00e4v\u00e4: Parsi Ansible-koodit\n\n## \ud83d\udca1 Gallium (431)\n\n- [ ] Teht\u00e4v\u00e4: Ansible Devausymp\u00e4rist\u00f6\n- [ ] Teht\u00e4v\u00e4: Ansible Hello World\n\n## \ud83c\udf86 Strontium (438)\n\n- [ ] Teht\u00e4v\u00e4: Lis\u00e4\u00e4 Cloud-Init\n- [ ] Teht\u00e4v\u00e4: Luo Ansible config\n\n## \ud83d\udc69\u200d\ud83d\udd2c Curium (496)\n\n- [ ] Teht\u00e4v\u00e4: Nginx\n- [ ] Teht\u00e4v\u00e4: Nginx idempotenssi\n- [ ] Teht\u00e4v\u00e4: Nginx poisto\n- [ ] Teht\u00e4v\u00e4: Nginx with Hello World\n- [ ] Teht\u00e4v\u00e4: Ufw from Galaxy\n\n## \ud83d\udc68\u200d\ud83d\udd2c Einsteinium (499)\n\n- [ ] Teht\u00e4v\u00e4: Hostaa Linux Perusteet ja Skriptiohjelmointi\n</code></pre>"},{"location":"ansible/31_gallium/","title":"\ud83d\udca1 Gallium","text":"<p>Ansible-osuus eroaa Bash, PowerShell ja Python osuuksista siten, ett\u00e4 valmista koodia tarjoillaan merkitt\u00e4v\u00e4sti aiempaa v\u00e4hemm\u00e4n. T\u00e4m\u00e4 osio on kurssin loppusilaus, jossa yhdistell\u00e4\u00e4n Bash ja Python -osuuksissa opittua Ansibleen. PowerShell hyl\u00e4t\u00e4\u00e4n toistaiseksi, koska Ansible Control Noden tulee olla Unix-pohjainen, ja Bash on valmiina saatavilla.</p> <p>Gallium-osiossa tehd\u00e4\u00e4n minimum viable product. T\u00e4m\u00e4 tehd\u00e4\u00e4n muutamassa vaiheessa.</p> # Vaihe Ty\u00f6kalu Tavoite 1 venv uv + Python Eristet\u00e4\u00e4n projektin riippuvuudet OS-tason Pythonista 2 Ansible uv Asennetaan Ansible Core 3 Virtual Machines Bash, Multipass Luodaan kaksi managed nodea 4 Inventory Generation Python script Luodaan Multipass-komennon outputista Ansible Inventory 5 Playbook VS Code Luodaan Hello World -tason Playbook 6 Test Run Ansible Ajetaan Playbook <p>Kuhunkin osioon on oma t\u00e4rppins\u00e4 alla. Lopulta sivun pohjalla on teht\u00e4vi\u00e4, jotka sis\u00e4lt\u00e4v\u00e4t n\u00e4m\u00e4 vaiheet.</p>"},{"location":"ansible/31_gallium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"ansible/31_gallium/#1-venv","title":"1\ufe0f\u20e3 Venv","text":"<p>K\u00e4yt\u00e4mme Pythonin paketin- ja projektinhallintaan ty\u00f6kalua nimelt\u00e4\u00e4n uv.Onko se asennettuna jo Python-osion tiimoilta? Jos ei, asenna se. Se asentuu yhdell\u00e4 komennolla, joka l\u00f6ytyy uv sivulta.</p> <p>Voit luoda uuden Application tyypin projektin alla n\u00e4kyvill\u00e4 k\u00e4skyill\u00e4. Huomaa, ett\u00e4 projekti luodaan siihen hakemistoon, miss\u00e4 olet nyt. Varmista, ett\u00e4 olet oikeassa hakemistossa, kuten <code>$PROJECT_ROOT/ansible/</code>. Huomaa, ett\u00e4 teemme applikaation nimelt\u00e4\u00e4n <code>ansible-managed-node</code>. T\u00e4m\u00e4 siksi, ett\u00e4 haluamme v\u00e4ltell\u00e4 p\u00e4\u00e4llek\u00e4isyytt\u00e4 pelk\u00e4n <code>ansible</code>-nimisen projektin kanssa. Muutoin <code>import</code> voi menn\u00e4 pieleen tietyiss\u00e4 tilanteissa.</p> <pre><code># Install a new uv-managed Python\nuv python install 3.12\n\n# Pin this directory to use the installed Python (.python-version)\nuv python pin 3.12\n\n# Create a new uv-managed Python project\nuv init --name \"ansible-managed-node\" --bare --app .\n</code></pre> <p>Voit kokeilla REPL:i\u00e4 n\u00e4in:</p> <pre><code>$ uv run python\nCreating virtual environment at: .venv\nPython 3.12 (...) [...]\nType \"help\" for more information.\n&gt;&gt;&gt;\n</code></pre> <p>Law of UV</p> <p>Huomaa, ett\u00e4 <code>uv</code> hallinnoi Pythonia.</p> <ol> <li>\u00c4l\u00e4 pid\u00e4 muita Pythoneita.</li> <li>Jos ajat Pythonia, k\u00e4sky alkaa <code>uv run &lt;komento&gt;</code>.</li> <li>Jos asennat paketteja, k\u00e4yt\u00e4 <code>uv add &lt;paketti&gt;</code>.</li> </ol> <p>Unohda system-level Python eli <code>/bin/python3</code>. Siihen ei ole asennettu eik\u00e4 siihen aiota asentaa ansiblea tai muita riippuvuuksia, joita t\u00e4m\u00e4 applikaatio sattuu tarvitsemaan.</p>"},{"location":"ansible/31_gallium/#2-ansible","title":"2\ufe0f\u20e3 Ansible","text":"<p>Nyt voimme asentaa Ansible Coren t\u00e4h\u00e4n meid\u00e4n luomaamme applikaatioon. Ei siis system-wide Pythoniin. \u00c4l\u00e4 sovella omia k\u00e4skyj\u00e4 teko\u00e4lyn hallusinaatioiden perusteella. Lue mieluummin alla oleva t\u00e4rppi.</p> <pre><code>uv add ansible-core\n</code></pre>"},{"location":"ansible/31_gallium/#3-virtual-machines","title":"3\ufe0f\u20e3 Virtual Machines","text":"<p>Voit luoda virtuaalikoneita Multipass-ty\u00f6kalulla. Nime\u00e4 ne j\u00e4rkev\u00e4sti, kuten <code>ansible-1</code> ja <code>ansible-2</code>. Voit k\u00e4ytt\u00e4\u00e4 alla olevia komentoja.</p> <pre><code># Create 1 and 2\nmultipass launch --name ansible-1\nmultipass launch --name ansible-2\n</code></pre> <p>Kun my\u00f6hemmin haluat tuhota koneet, aja komennot:</p> <pre><code>multipass delete ansible-1\nmultipass delete ansible-2\nmultipass purge\n</code></pre> <p>Olisikohan t\u00e4ss\u00e4 kenties j\u00e4rkev\u00e4\u00e4 k\u00e4ytt\u00e4\u00e4 skriptej\u00e4 <code>create-vms.sh</code> ja <code>destroy-vms.sh</code>? No olisi! Tee t\u00e4m\u00e4 skriptin\u00e4.</p>"},{"location":"ansible/31_gallium/#4-inventory-generation","title":"4\ufe0f\u20e3 Inventory Generation","text":"<p>Ansiblea varten tarvitsemme joko koneiden hostnamet tai IP-osoitteen Inventory-ty\u00f6kaluun. P\u00f6ller\u00f6n ratkaisu olisi aina k\u00e4yd\u00e4 k\u00e4sin korvaamassa IP-osoitteet kun koneet luodaan uusiksi. T\u00e4m\u00e4 ei ole kovin skaalautuva ratkaisu. Sen sijaan voimme luoda skriptin, joka luo meille Inventoryn automaattisesti. Jotta t\u00e4m\u00e4 on mahdollista, tarvitset koneiden tiedot koneluettavassa muodossa, ja t\u00e4m\u00e4 onnistuu Multipassin avulla.</p> <pre><code>multipass list --format json\n</code></pre> <p>Mik\u00e4 parempaa, voimme lopulta luoda Python-skriptin, joka lukee t\u00e4m\u00e4n outputin ja kirjoittaa sen tiedostoon <code>config/inventory/hosts.ini</code>. Lis\u00e4t\u00e4\u00e4n kumpikin kone groupiin <code>multipass</code>, ja luodaan kummallekin oma ryhm\u00e4ns\u00e4: <code>first</code> ja <code>second</code>. T\u00e4m\u00e4 siksi, ett\u00e4 voimme jatkossa kohdentaa k\u00e4skyj\u00e4 vain yhteen virtuaalikoneeseen helposti. Meill\u00e4 ei ole DNS-osoitteita hallittuina, emmek\u00e4 halua joutua kirjoittamaan IP-osoitteita, koska ne vaihtuvat joka kerta kun koneet tuhotaan ja luodaan uusiksi. Skripti\u00e4 voisi k\u00e4ytt\u00e4\u00e4 k\u00e4sin n\u00e4in:</p> <pre><code>$ multipass list --format json | uv run scripts/multipass-to-inv.py\n[INFO] Adding 192.168.64.41 to inventory\n[INFO] Adding 192.168.64.42 to inventory\n[INFO] Inventory written to config/inventory/hosts.ini\n\n$ cat config/inventory/hosts.ini \n[multipass]\n192.168.64.41\n192.168.64.42\n\n[first]\n192.168.64.41\n\n[second]\n192.168.64.42\n</code></pre> <p>Yll\u00e4 oleva komento olisi hyv\u00e4 lis\u00e4t\u00e4 aiemmin luomaasi <code>create-vms</code>-skriptiin, eik\u00f6 vain? N\u00e4in inventorio ei voi vahingossa unohtua tilaan, jossa se ei ole ajan tasalla.</p> Opettajan skripti <p>Voit k\u00e4ytt\u00e4\u00e4 t\u00e4m\u00e4n kaltaista skripti\u00e4. Tunnista puuttuvat riippuvuudet ja lis\u00e4\u00e4 ne <code>uv add</code>-komennolla.</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom ipaddress import IPv4Address\nfrom pathlib import Path\n\nTARGET_FILE = Path(\"config/inventory/hosts.ini\")\n\nclass VMInfo(BaseModel):\n    ipv4: list[IPv4Address]\n    name: str\n    release: str\n    state: str\n\nclass VMList(BaseModel):\n    list: list[VMInfo]\n\ndef read_raw_json_from_stdin() -&gt; str:\n    if sys.stdin.isatty():\n        print(\"No input string given\", file=sys.stderr)\n        sys.exit(1)\n\n    return \"\".join([line.strip() for line in sys.stdin])\n\ndef vmlist_to_ini(vm_list: VMList, ini_file) -&gt; str:\n    ini_file.parent.mkdir(parents=True, exist_ok=True)\n\n    with ini_file.open(\"w\") as f:\n        f.write(\"[multipass]\\n\")\n        for vm in vm_list.list:\n            ip = vm.ipv4[0].exploded\n            print(f\"[INFO] Adding {ip} to inventory\")\n            f.write(f\"{ip}\\n\")\n\n        f.write(\"\\n[first]\\n\")\n        f.write(vm_list.list[0].ipv4[0].exploded)\n        f.write(\"\\n\")\n\n        f.write(\"\\n[second]\\n\")\n        f.write(vm_list.list[1].ipv4[0].exploded)\n\nif __name__ == \"__main__\":\n    raw_json = read_raw_json_from_stdin()\n    vm_list = VMList.model_validate_json(raw_json)\n    vmlist_to_ini(vm_list, TARGET_FILE)\n    print(f\"[INFO] Inventory written to {TARGET_FILE}\")\n</code></pre>"},{"location":"ansible/31_gallium/#5-playbook","title":"5\ufe0f\u20e3 Playbook","text":"<p>Luo yksinkertainen Playbook, joka vain tulostaa <code>Hello, World!</code>. T\u00e4m\u00e4 on hyv\u00e4 tapa varmistaa, ett\u00e4 Ansible toimii ja ett\u00e4 koneet ovat saavutettavissa. Voit k\u00e4ytt\u00e4\u00e4 pohjana Ansible Community Docs: Creating a playbook ohjeen esimerkki\u00e4.</p>"},{"location":"ansible/31_gallium/#6-test-run-erehdys","title":"6\ufe0f\u20e3 Test Run Erehdys \u26d4","text":"<p>Bug</p> <p>Nyt on tuikata Playbook k\u00e4yntiin, ottaa et\u00e4isyytt\u00e4 ja ihailla k\u00e4sien ty\u00f6t\u00e4. Kuten aiemmasta Creating a Playbook -ohjeesta tied\u00e4t, komento on:</p> <pre><code>$ uv run ansible-playbook -i config/inventory/hosts.ini config/playbooks/hello-world.yml \n\nPLAY [Hello World] \nfatal: [192.168.64.42]: UNREACHABLE! =&gt; \n{\n    \"changed\": false, \n    \"msg\": \"...myuser@192.168.64.42: Permission denied (publickey).\", \n    \"unreachable\": true\n}\n</code></pre> <p>Uh oh! Eih\u00e4n homma toimi laisinkaan, mutta t\u00e4m\u00e4 on ihan odotettua. Kuinka me voisimme saada SSH-yhteyden hostiin, johon emme ole lis\u00e4nneet meid\u00e4n julkista avainta? Lis\u00e4ksi, yritimme yhdist\u00e4\u00e4 k\u00e4ytt\u00e4j\u00e4ll\u00e4 <code>myuser</code>, joka on host-koneen k\u00e4ytt\u00e4j\u00e4nimi. </p> <p>Korjataan t\u00e4m\u00e4 tilanne tasan kerran k\u00e4sin oppimisen vuoksi. Ensi luvussa automatisoimme t\u00e4m\u00e4n.</p>"},{"location":"ansible/31_gallium/#6-test-run-korjaus","title":"6\ufe0f\u20e3 Test Run Korjaus \u2705","text":"<p>Saat lis\u00e4tty\u00e4 avaimen n\u00e4in:</p> <pre><code># Copy our public key to the remote hosts\ncat ~/.ssh/id_ed25519.pub | multipass exec ansible-1 -- bash -c 'cat &gt; /tmp/id_ed25519.pub'\ncat ~/.ssh/id_ed25519.pub | multipass exec ansible-2 -- bash -c 'cat &gt; /tmp/id_ed25519.pub'\n\n# Append the public key to authorized_keys in /home/ubuntu/.ssh\nmultipass exec ansible-1 -- bash -c \"cat /tmp/id_ed25519.pub &gt;&gt; ~/.ssh/authorized_keys\"\nmultipass exec ansible-2 -- bash -c \"cat /tmp/id_ed25519.pub &gt;&gt; ~/.ssh/authorized_keys\"\n\n# Disable SSH host key checking. This means the \n# \"Are you sure you want to continue connecting (yes/no/[fingerprint])?\" prompt is not shown.\n# and the host is blindly trusted.\nexport ANSIBLE_HOST_KEY_CHECKING=False\n\n# Run the playbook using the ubuntu user\nuv run ansible-playbook -i config/inventory/hosts.ini config/playbooks/hello-world.yml -u ubuntu\n</code></pre> <p>Tulosteen pit\u00e4isi olla jotakuinkin:</p> <pre><code>PLAY [Hello World] *********************\n\nTASK [Gathering Facts] *********************\nok: [192.168.64.45]\nok: [192.168.64.44]\n\nTASK [Print Hello World] *********************\nok: [192.168.64.45] =&gt; {\n    \"msg\": \"Hello, World!\"\n}\nok: [192.168.64.44] =&gt; {\n    \"msg\": \"Hello, World!\"\n}\n\nPLAY RECAP *********************\n192.168.64.44              : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   \n192.168.64.45              : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n</code></pre>"},{"location":"ansible/31_gallium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Ansible Devausymp\u00e4rist\u00f6 <p>Luo yll\u00e4 olevien t\u00e4rppien avulla devausymp\u00e4rist\u00f6 hakemistoon <code>ansible/</code>. Projektisi juuren tulisi n\u00e4ytt\u00e4\u00e4 siis lopulta t\u00e4lt\u00e4:</p> <pre><code>johnanderton\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 ansible/\n\u251c\u2500\u2500 bash/\n\u251c\u2500\u2500 pwsh/\n\u2514\u2500\u2500 python/\n</code></pre> <p>Jos tarkastelemme vain <code>ansible/</code>-hakemistoa, sen tulisi n\u00e4ytt\u00e4\u00e4 t\u00e4lt\u00e4:</p> <pre><code>ansible\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 .venv\n\u2502   \u251c\u2500\u2500 .gitignore\n\u2502   \u2514\u2500\u2500 many.files.here\n\u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 inventory\n\u2502   \u2502   \u2514\u2500\u2500 hosts.ini\n\u2502   \u2514\u2500\u2500 playbooks\n\u2502       \u2514\u2500\u2500 hello-world.yml\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 create-vms.sh\n\u2502   \u251c\u2500\u2500 destroy-vms.sh\n\u2502   \u2514\u2500\u2500 multipass-to-inv.py\n\u2514\u2500\u2500 uv.lock\n</code></pre> <p>Huomaa, ett\u00e4 osa tiedostoista luodaan komentojen avulla, osa k\u00e4sin. \u00c4l\u00e4 luo esimerkiksi <code>pyproject.toml</code> tai <code>uv.lock</code> tiedostoja k\u00e4sin. K\u00e4yt\u00e4 <code>uv</code>-ty\u00f6kalua, kuten t\u00e4rpeiss\u00e4 on neuvottu.</p> <p>Note</p> <p>Tuotannossa hakemistorakenne olisi todenn\u00e4k\u00f6isesti monimutkaisempi. Ansible Docs: Sample Ansible setup antaa esimerkkej\u00e4 siit\u00e4, kuinka hakemistot voivat olla j\u00e4rjestetty.</p> Teht\u00e4v\u00e4: Ansible Hello World <p>Toisinna yll\u00e4 n\u00e4kyv\u00e4t vaiheet siten, ett\u00e4 saat Ansiblen tulostamaan <code>Hello, World!</code> molemmille virtuaalikoneille. K\u00e4yt\u00e4 apunasi yll\u00e4 olevia t\u00e4rppej\u00e4.</p> <p>Vihje: Playbook</p> <p>Playbook n\u00e4ytt\u00e4\u00e4 lopulta jotakuinkin t\u00e4lt\u00e4:</p> <pre><code>---\n- name: Hello World\nhosts: multipass\ntasks:\n    - name: Print Hello World\n    ansible.builtin.debug:\n        msg: \"Hello, World!\"\n...\n</code></pre>"},{"location":"ansible/38_strontium/","title":"\ud83c\udf86 Strontium","text":"<p>Edellisess\u00e4 luvussa varmasti huomasit, ett\u00e4 Ansible-komennoista kasvoi melko pitki\u00e4. Lis\u00e4ksi viimeisiin komentoihin j\u00e4i jonkin verran k\u00e4sin teht\u00e4v\u00e4\u00e4, kuten IP-osoitteiden t\u00e4ydennys. Strontium-luvussa keskitymme tekem\u00e4\u00e4n Ansiblesta siin\u00e4 mieless\u00e4 k\u00e4ytett\u00e4v\u00e4n, ett\u00e4 komennot ovat jatkossa lyhyit\u00e4.</p>"},{"location":"ansible/38_strontium/#ansible-kayttaja","title":"Ansible-k\u00e4ytt\u00e4j\u00e4","text":"<p>Kuvitellaan, ett\u00e4 meill\u00e4 on ohjattavana my\u00f6s muita distribuutioita kuin kaksi Multipassilla ajettavaa Ubuntua. Olisi huomattavan n\u00e4pp\u00e4r\u00e4\u00e4, jos kaikissa koneissa olisi aina k\u00e4ytt\u00e4j\u00e4 <code>ansible</code>, jonka avulla voimme tehd\u00e4 muutoksia. K\u00e4ytt\u00e4j\u00e4n voi luonnollisesti luoda k\u00e4sin, Ansible-automatiikalla, tai jollekin muulla automatiikalla, kuten Cloud-Initilla. Alla tutustumme sek\u00e4 hyvinkin manualiseen ratkaisuun ett\u00e4 Cloud-Init-ratkaisuun.</p>"},{"location":"ansible/38_strontium/#ansible-kayttaja-kasin","title":"Ansible-k\u00e4ytt\u00e4j\u00e4 k\u00e4sin","text":"<p>K\u00e4ytt\u00e4j\u00e4n voi luoda kohtalaisen k\u00e4sin k\u00e4ytt\u00e4en Multipassia ja Ansiblea. Alla esimerkki, jota sinun ei siis todellakaan tarvitse kirjoittaa, koska seuraavaksi automatisoimme t\u00e4m\u00e4n.</p> <pre><code># Copy our public key to the remote hosts\nmultipass transfer ~/.ssh/id_ed25519.pub ansible-1:/tmp/id_ed25519.pub\nmultipass transfer ~/.ssh/id_ed25519.pub ansible-2:/tmp/id_ed25519.pub\n\n# Append the public key to authorized_keys in /home/ubuntu/.ssh\nmultipass exec ansible-1 -- bash -c \"cat /tmp/id_ed25519.pub &gt;&gt; ~/.ssh/authorized_keys\"\nmultipass exec ansible-2 -- bash -c \"cat /tmp/id_ed25519.pub &gt;&gt; ~/.ssh/authorized_keys\"\n\n# Disable SSH host key checking.\nexport ANSIBLE_HOST_KEY_CHECKING=False\n\n# Create ansible user\nuv run ansible \\\n--inventory config/inventory/hosts.ini multipass \\\n--module-name ansible.builtin.user \\\n--args \"name=ansible create_home=yes groups=sudo append=yes\" \\\n--user ubuntu --become\n\n# Create the .ssh directory\nuv run ansible \\\n-i config/inventory/hosts.ini multipass \\\n-m ansible.builtin.file \\\n-a \"path=/home/ansible/.ssh state=directory owner=ansible group=ansible mode=0700\" \\\n-u ubuntu -b\n\n# Copy the public key to the authorized_keys file\nuv run ansible -i config/inventory/hosts.ini multipass \\\n-m ansible.builtin.copy \\\n-a \"src=~/.ssh/id_ed25519.pub dest=/home/ansible/.ssh/authorized_keys owner=ansible group=ansible mode=0600\" \\\n-u ubuntu -b\n\n# NOW you could run commands as the ansible user! \ud83c\udf89\nuv run ansible -i config/inventory/hosts.ini multipass \\\n-m debug \\\n-a \"msg='Hello world!'\" \\\n-u ansible\n</code></pre> <p>Yksitt\u00e4inen komento ylt\u00e4 selitettyn\u00e4 auki. T\u00e4t\u00e4 ymm\u00e4rt\u00e4\u00e4ksesi sinun tulisi lukea Ansible Community Docs: ansible-bin\u00e4\u00e4rin optioneiden kuvaukset. Selitys parametreille j\u00e4rjestyksess\u00e4 vasemmalta oikealle:</p> Parametri Selitys <code>uv run ansible</code> Ansible Core <code>-i &lt;path&gt;</code>, <code>--inventory &lt;path&gt;</code> Inventory-tiedoston polku <code>multipass</code> Group <code>multipass</code>, jonka hosteihin tehd\u00e4\u00e4n muutoksia <code>-m &lt;FQDN&gt;</code>, <code>--module-name &lt;FQDN&gt;</code> Moduuli. Esimerkiksi <code>user</code> collectionista <code>ansible.builtin</code> <code>-a \"...\"</code> Argumentit moduulille <code>-u ubuntu</code>, <code>--user &lt;username&gt;</code> K\u00e4ytt\u00e4j\u00e4, jolla ajetaan <code>-b</code>, <code>--become</code> K\u00e4yt\u00e4 sudoa <p>Seuraavia kahta parametri\u00e4 emme tarvitse t\u00e4m\u00e4n virtuaalikoneen kanssa, koska k\u00e4ytt\u00e4j\u00e4ll\u00e4 <code>ubuntu</code> ei ole salasanaa, mutta ne on hyv\u00e4 tuntea, koska niit\u00e4 tarvitaan usein. N\u00e4in voi olla, jos esimerkiksi teet VMwareen virtuaalikoneen ja haluat konfiguroida sen Ansiblella.</p> Parametri Selitys <code>-k</code>, <code>--ask-pass</code> Kysy k\u00e4ytt\u00e4j\u00e4n (ubuntu) salasanaa SSH-avaintunnistuksen sijasta. <code>-K</code>, <code>--ask-become-pass</code> Kysy sudo-salasanaa interaktiivisesti kun jokin sudo-komento ajetaan."},{"location":"ansible/38_strontium/#ansible-kayttaja-cloud-initilla","title":"Ansible-k\u00e4ytt\u00e4j\u00e4 Cloud-initilla","text":"<p>Ansible-k\u00e4ytt\u00e4j\u00e4n luominen koneen luomisen yhteydess\u00e4 on n\u00e4pp\u00e4r\u00e4 tapa automatisoida inhat vaiheet. T\u00e4m\u00e4 onnistuu Cloud-Initill\u00e4, joka on pilvipalveluissa yleisesti k\u00e4ytetty tapa konfiguroida virtuaalikoneita luomisen tai k\u00e4ynnistymisen yhteydess\u00e4.</p> <p>Jos kurkkaat multipass launch-komennon dokumentaatiota, huomaat, ett\u00e4 sille voi antaa <code>--cloud-init &lt;file&gt; | &lt;url&gt;</code> optionin. T\u00e4m\u00e4 tarkoittaa, ett\u00e4 voimme luoda Cloud-Init -tiedoston, joka sis\u00e4lt\u00e4\u00e4 Ansiblen k\u00e4ytt\u00e4j\u00e4n luomisen.</p> <pre><code>#cloud-config\nssh_pwauth: false\nusers:\n- name: ansible\n  gecos: Ansible User\n  groups: users,admin,wheel\n  sudo: ALL=(ALL) NOPASSWD:ALL\n  shell: /bin/bash\n  lock_passwd: true\n  create_home: true\n  ssh_authorized_keys:\n    - \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGK9z+oj4VYSpW7K/k0MJKFYuZFw68sDTrw8NGToyM41\"\n</code></pre> <p>T\u00e4m\u00e4n j\u00e4lkeen sinun tulee lis\u00e4t\u00e4 kyseinen tiedosto <code>multipass launch</code>-komennon <code>--cloud-init</code>-parametrin per\u00e4\u00e4n. Muokkaa sinun <code>create-vms.sh</code>-tiedostoa.</p> <p>Warning</p> <p>HUOM! Ensimm\u00e4isen rivin <code>#cloud-config</code> on oltava ensimm\u00e4inen rivi tiedostossa. Muutoin Cloud-Init ei tunnista tiedostoa omakseen.</p>"},{"location":"ansible/38_strontium/#komennon-lyhentaminen","title":"Komennon lyhent\u00e4minen","text":""},{"location":"ansible/38_strontium/#konfiguraatiotiedosto","title":"Konfiguraatiotiedosto","text":"<p>Ansiblen <code>ansible.cfg</code>-tiedostoon voi kirjoittaa asetuksia, jotka ovat voimassa kaikille Ansible-komennoille. T\u00e4m\u00e4n avulla voimme ratkaista monta aiemmin vastaan tullutta ongelmaa, kuten sen, ett\u00e4 <code>--inventory</code>-parametri on aina kirjoitettava.</p> <p>Ansible etsii tiedostoa seuraavassa j\u00e4rjestyksess\u00e4, kuten Ansible Community Docs: Ansible Configuration Settings kertoo:</p> <ol> <li><code>ANSIBLE_CONFIG</code> (ymp\u00e4rist\u00f6muuttuja)</li> <li><code>ansible.cfg</code> (cwd)</li> <li><code>~/.ansible.cfg</code> (kotikansion juuressa)</li> <li><code>/etc/ansible/ansible.cfg</code> (globaali)</li> </ol> <p>Voit luoda kommentoidun esimerkkitiedoston seuraavalla komennolla:</p> <pre><code>uv run ansible-config init --disabled &gt; ansible.cfg\n</code></pre> <p>Tiedosto on todella verbose, joten luomme sen sijaan k\u00e4sin omamme:</p> <pre><code>[defaults]\ninventory = config/inventory/hosts.ini\nremote_user = ansible\nhost_key_checking = False\ninterpreter_python = auto_silent\ngathering = smart\n</code></pre>"},{"location":"ansible/38_strontium/#kokeile-vaikka","title":"Kokeile vaikka","text":"<p>Olettaen ett\u00e4 sinun <code>ansible.cfg</code>-tiedosto on kunnossa ja Cloud-init on ajettu onnistuneesti, voit ajaa ad-hoc komentoja Ansiblen avulla hyvinkin helposti. T\u00e4m\u00e4 on n\u00e4pp\u00e4r\u00e4\u00e4 ja poistaa tarpeen ottaa k\u00e4sin SSH-yhteyksi\u00e4 (tai ParalellelSSH:n tai <code>multipass exec</code> kautta). Jos termi ad-hoc on vieras, sill\u00e4 tarkoitetaan IT-maailmassa tilap\u00e4ist\u00e4 tai kertaluonteista k\u00e4sky\u00e4 tai ratkaisua.</p> <p>Quote</p> <p>ad hoc tapauskohtainen t. tapauskohtaisesti, yhteen tarkoitukseen soveltuva(sti) \u00b6 Periaatteessa sitaattilaina latinasta, merkitykselt\u00e4\u00e4n 't\u00e4t\u00e4 varten', mutta k\u00e4ytet\u00e4\u00e4n tavallisemmin m\u00e4\u00e4ritteen\u00e4, esim. \"ad hoc -ratkaisu\". Usein s\u00e4vylt\u00e4\u00e4n liev\u00e4sti paheksuva; taustalla voi olla ajatus, ett\u00e4 olisi pit\u00e4nyt l\u00f6yt\u00e4\u00e4 tai kehitt\u00e4\u00e4 yleinen ratkaisu mutta tehtiinkin jokin \"viritelm\u00e4\" joka sopii vain yhteen tilanteeseen eik\u00e4 siihenk\u00e4\u00e4n ehk\u00e4 luotettavasti.</p> <p>L\u00e4hde: Jukka Korpelan pienehk\u00f6st\u00e4 sanakirja</p> <p>Mik\u00e4li <code>ansible.cfg</code>-tiedosto on kunnossa ja vakiok\u00e4ytt\u00e4j\u00e4 ansible on olemassa avaimineen, niin voit ajaa seuraavanlaisia komentoja:</p> <pre><code># Syntaksi\n# uv run ansible &lt;group&gt; -m &lt;module&gt; -a \"&lt;args&gt;\"\n\n# Yksi tietty moduuli\n$ uv run ansible all -m ping\n\n# Yksi tietty moduuli attribuutteineen\n$ uv run ansible all -m file -a \"path=/home/ansible/kissa.txt state=touch\"\n$ uv run ansible all -m find -a \"paths=/home/ansible patterns=*.txt\"\n\n# Vakiomoduuli on command\n$ uv run ansible all -a \"df -h\"\n\n# Jos haluat ajaa komennon sudo-oikeuksilla\n$ uv run ansible all -a \"cat /etc/shadow\" --become\n\n# Tarvitsemme Shell-moduulin, jos haluamme k\u00e4ytt\u00e4\u00e4 putkia\n$ uv run ansible all -m shell -a \"cat /etc/shadow | grep -i ansible\" --become\n</code></pre> <p>Kuten jo yll\u00e4 esitellyst\u00e4 m\u00e4\u00e4ritelm\u00e4st\u00e4 voi arvata, t\u00e4m\u00e4 ratkaisu on v\u00e4liaikainen. Pysyv\u00e4mpi\u00e4 ratkaisuja varten kannattaa k\u00e4ytt\u00e4\u00e4 Playbookeja, joihin palaamme kurssin seuraavassa luvussa.</p>"},{"location":"ansible/38_strontium/#requirements","title":"Requirements","text":"<p>Riippuvuuksia varten voi luoda oman <code>requirements.yml</code>-tiedoston, joka sis\u00e4lt\u00e4\u00e4 kaikki tarvittavat moduulit. T\u00e4m\u00e4 on hy\u00f6dyllist\u00e4, jos haluat jakaa projektisi muiden kanssa. Tiedosto on k\u00e4ytt\u00f6tarkoitukseltaan vastaava kuin <code>pyproject.toml</code>-tiedoston <code>dependencies</code>-lista.</p> <pre><code>---\ncollections:\n  - ansible.posix\n</code></pre> <p>Kaikki kyseisess\u00e4 tiedostossa olevat riippuvuudet voi asentaa, kuten Ansible Community Docs: Install multiple collections with a requirements file ohje neuvoo, komennolla:</p> <pre><code>$ uv run ansible-galaxy collection install -r requirements.yml\n</code></pre>"},{"location":"ansible/38_strontium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Lis\u00e4\u00e4 Cloud-Init <p>T\u00e4m\u00e4 vaihe on simppeli ja siihen l\u00f6ytyy ohjeet ylt\u00e4. Vaiheet:</p> <ol> <li>Luo Cloud-Init -tiedosto, joka luo <code>ansible</code>-k\u00e4ytt\u00e4j\u00e4n virtuaalikoneisiin.</li> <li>Lis\u00e4\u00e4 tiedosto <code>create-vms.sh</code>-skriptiin.</li> </ol> <p>Hakemistorakenteesi tulisi n\u00e4ytt\u00e4\u00e4 jotakuinkin t\u00e4lt\u00e4:</p> <pre><code>ansible\n\u251c\u2500\u2500 ansible.cfg\n\u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 cloud-init\n\u2502   \u2502   \u2514\u2500\u2500 ansible.yml\n\u2502   \u251c\u2500\u2500 inventory\n\u2502   \u2502   \u2514\u2500\u2500 hosts.ini\n\u2502   \u2514\u2500\u2500 playbooks\n\u2502       \u2514\u2500\u2500 hello-world.yml\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 create-vms.sh\n\u2502   \u251c\u2500\u2500 destroy-vms.sh\n\u2502   \u2514\u2500\u2500 multipass-to-inv.py\n\u2514\u2500\u2500 uv.lock\n</code></pre> Teht\u00e4v\u00e4: Luo Ansible config <p>Luo yll\u00e4 neuvottu <code>ansible.cfg</code>-tiedosto ja tarkista, ett\u00e4 kokonaisuus toimii. Sinun tulisi voida ajaa seuraavanlaiset komennot <code>ansible/</code>-hakemistossa:</p> <pre><code>$ ./scripts/create-vms.sh\nLaunched: ansible-1\nLaunched: ansible-2\n[INFO] Adding 192.168.64.49 to inventory\n[INFO] Adding 192.168.64.48 to inventory\n[INFO] Inventory written to config/inventory/hosts.ini\n\n$ uv run ansible all -m ping\n192.168.64.53 | SUCCESS =&gt; {\n    ...\n}\n192.168.64.52 | SUCCESS =&gt; {\n    ...\n}\n\n$ uv run ansible multipass -a \"df -h\"\n192.168.64.53 | CHANGED | rc=0 &gt;&gt;\nFilesystem      Size  Used Avail Use% Mounted on\ntmpfs            96M  1.2M   95M   2% /run\n/dev/sda1       3.9G  1.9G  2.0G  50% /\n...\n\n192.168.64.52 | CHANGED | rc=0 &gt;&gt;\nFilesystem      Size  Used Avail Use% Mounted on\ntmpfs            96M  1.2M   95M   2% /run\n/dev/sda1       3.9G  1.9G  2.0G  50% /\n...\n</code></pre>"},{"location":"ansible/96_curium/","title":"\ud83d\udc69\u200d\ud83d\udd2c Curium","text":""},{"location":"ansible/96_curium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"ansible/96_curium/#faktat","title":"Faktat","text":"<p>Ansible suorittaa Play-vaiheita edelt\u00e4v\u00e4n Fact Gathering prosessin, jossa se noutaa muuttujiin arvoja koneelta. Voit tarkastella JSON-muotoista raakamuotoa n\u00e4in:</p> <pre><code>$ uv run ansible 192.168.64.62 -m ansible.builtin.setup\n</code></pre> <p>Playbookeissa n\u00e4it\u00e4 arvoja voi k\u00e4ytt\u00e4\u00e4 simppelisti jommalla kummalla alla n\u00e4kyvist\u00e4 tavoista. Huomaa, ett\u00e4 <code>ansible_facts</code> dictionaryn arvot ovat saatavilla my\u00f6s globaaleiksi muuttujiksi injektoituina. Niiden etuliitteen\u00e4 on <code>ansible_</code>. Lis\u00e4ksi l\u00f6ytyy nippu <code>magic</code>-muuttujia, kuten <code>inventory_hostname</code> tai <code>group_names</code>. N\u00e4m\u00e4 ovat varattuja sanoja (engl. reserved), jotka eiv\u00e4t ole <code>ansible_facts</code> -dictionaryss\u00e4. Et voi ylikirjoittaa niiden sis\u00e4lt\u00f6\u00e4.</p> playbook_facts.yml<pre><code>---\n- name: Gather facts\n  hosts: localhost\n  tasks:\n    - name: Print processor architecture (injected)\n      ansible.builtin.debug:\n        msg: \"Processor architecture is {{ ansible_processor }}\"\n\n    - name: Print processor architecture (from dictionary)\n      ansible.builtin.debug:\n        msg: \"Processor architecture is {{ ansible_facts['processor'] }}\"\n...\n</code></pre>"},{"location":"ansible/96_curium/#muuttujat","title":"Muuttujat","text":"<p>Yll\u00e4 mainitut faktat ovat jo itses\u00e4\u00e4n muuttujia, mutta voit m\u00e4\u00e4ritell\u00e4 niit\u00e4 itse lis\u00e4\u00e4. Muuttujat voivat olla tyyppi\u00e4 string, boolean, list tai dictionary. Playbookin sis\u00e4ll\u00e4 t\u00e4m\u00e4n joko Play- tai Task-tasolla, mutta yhteens\u00e4 eri tapoja m\u00e4\u00e4ritell\u00e4 muuttujia on kymmeni\u00e4, mukaan lukien erilliset <code>vars_files</code>:t, <code>--extra-vars</code> CLI optionit ja Ansible Vault-s\u00e4il\u00f6n. Jos pysyt\u00e4\u00e4n kuitenkin Play- ja Task-tasolla, niin alla n\u00e4kyv\u00e4t kummatkin:</p> playbook_variables.yml<pre><code>---\n- name: This is my play\n  hosts: localhost\n  vars:\n    play_level1: \"aaa\"\n    play_level2: 123\n    play_level3:\n        - \"Hello\"\n        - \"World!\"\n  tasks: \n    - name: This is my task\n      vars:\n        task_level1: \"ccc\"\n        task_level2: 456\n        task_level3:\n            goodbye: \"Goodbye\"\n            world: \"World!\"\n      debug:\n        msg: |\n            From task: {{ task_level1 }} and {{ task_level2 }} and {{ task_level3 }}\n            From play: {{ play_level1 }} and {{ play_level2 }} and {{ play_level3 }}\n...\n</code></pre> <p>Huomaat, ett\u00e4 Playbookin ajaminen tuottaa seuraavan tulosteen:</p> <pre><code>TASK [This is my task] **********************\nok: [localhost] =&gt; {\n    \"msg\": \"From task: ccc and 456 and {'goodbye': 'Goodbye', 'world': 'World!'}\\nFrom play: aaa and 123 and ['Hello', 'World!']\\n\"\n}\n</code></pre>"},{"location":"ansible/96_curium/#galaxy","title":"Galaxy","text":"<p>Jos teet jotakin, mit\u00e4 tavallisesti tehd\u00e4\u00e4n usein, sille l\u00f6ytyy todenn\u00e4k\u00f6isesti moduuli. Hyv\u00e4 esimerkki t\u00e4st\u00e4 on SSH-avaimen lis\u00e4\u00e4minen <code>authorized_keys</code>-tiedostoon. T\u00e4m\u00e4 on niin yleinen toimenpide, ett\u00e4 Ansiblella on sille oma moduuli, jota olisimme voineet k\u00e4ytt\u00e4\u00e4 aiemmin. Moduuli on FQDN:t\u00e4\u00e4n ansible.posix.authorized_key. Se asennettaisiin seuraavasti:</p> <pre><code>$\u00a0uv run ansible-galaxy collection install ansible.posix\nStarting galaxy collection install process\nProcess install dependency map\nStarting collection install process\nDownloading https://galaxy.ansible.com/api/v3/.../artifacts/ansible-posix-2.0.0.tar.gz to /home/me/.ansible/tmp/.../tmp_vdehsjm/ansible-posix-2.0.0-43kkw7ue\nInstalling 'ansible.posix:2.0.0' to '/home/me/.ansible/collections/ansible_collections/ansible/posix'\nansible.posix:2.0.0 was installed successfully\n</code></pre> <p>Jos t\u00e4m\u00e4n kurssin teht\u00e4v\u00e4t ohjaavat sinua k\u00e4ytt\u00e4m\u00e4\u00e4n moduulia jostakin muusta <code>namespace.collection</code>-osoitteesta kuin <code>ansible.builtin</code>, voit asentaa sen samalla tavalla.</p> <pre><code>$ uv run ansible-galaxy collection install &lt;namespace&gt;.&lt;collection&gt;\n</code></pre>"},{"location":"ansible/96_curium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Nginx <p>Luo playbook, <code>configs/playbooks/nginx.yml</code>, joka asentaa Nginxin ja k\u00e4ynnist\u00e4\u00e4 sen. K\u00e4yt\u00e4 vain ja ainoastaan <code>ansible.builtin</code> collectionista l\u00f6ytyvi\u00e4 moduuleita. Kenties <code>ansible.builtin.package</code> ja/tai <code>ansible.builtin.apt</code> ratkaisee ongelman? Jos kumpikin toimii, miss\u00e4 tilanteessa suosisit toista? Mit\u00e4 mahtaa apt:n parametri <code>update_cache</code> tehd\u00e4, ja l\u00f6ytyyk\u00f6 sille vastaine <code>package</code>-moduulista?</p> <p>Tarvitset kaksi play:t\u00e4, jotka voivat olla nimelt\u00e4\u00e4n esimerkiksi:</p> <ul> <li><code>- name: Install nginx</code></li> <li><code>- name: Ensure Nginx is running and enabled</code></li> </ul> <p>Tarkista, ett\u00e4 saat Welcome to nginx! -sivun auki selaimessa kummastakin IP-osoitteesta.</p> Teht\u00e4v\u00e4: Nginx idempotenssi <p>Aja yll\u00e4 oleva skripti uusiksi ja tarkkaile, kuinka se k\u00e4ytt\u00e4ytyy. Pohdi erityisesti, mik\u00e4 numerot n ja m ovat seuraavassa, ja miten ne eroavat ensimm\u00e4isest\u00e4 ajokerrasta:</p> <pre><code>PLAY RECAP ******************************************************* ...\n192.168.xx.xx              : ok=n    changed=m    unreachable=0    ...\n192.168.xx.xx              : ok=n    changed=m    unreachable=0    ...\n</code></pre> <p>Varmista, ett\u00e4 osaat jatkossa selitt\u00e4\u00e4, mit\u00e4 idempotentti tarkoittaa Ansiblessa - tai ylip\u00e4\u00e4t\u00e4ns\u00e4 tietojenk\u00e4sittelyn kontekstissa. Apua saat vaikkapa Wikipediasta.</p> Teht\u00e4v\u00e4: Nginx poisto <p>Luo Playbook, <code>configs/playbooks/nginx-remove.yml</code>, joka poistaa edellisen Playbookin asentaman nginx:n. Jos nginx:\u00e4\u00e4 ei ole asennettuna, skripti ei saa antaa virheilmoitusta! Kyll\u00e4, sen pit\u00e4\u00e4 olla idempotentti.</p> <p>Sinun tulisi tarvita vain yksi Play, esimerkiksi:</p> <ul> <li><code>- name: Remove Nginx package and its configuration</code></li> </ul> <p>Tip</p> <p>K\u00e4yt\u00e4 <code>purge</code>-parametria, jotta kaikki asetustiedostot poistetaan.</p> <p>Tip</p> <p>Muista, ett\u00e4 voit koska tahansa ottaa <code>multipass shell</code> -komennolla yhteyden koneeseen, jos haluat tutkia sen tilaa manuaalisesti.</p> Teht\u00e4v\u00e4: Nginx with Hello World <p>Tee Playbook, <code>configs/playbooks/nginx-hello.yml</code>, joka asentaa Nginxin ja luo sille yksinkertaisen Hello World -sivun. Jos tutkit aiemman tehv\u00e4t\u00e4n tilassa olevaa palvelinta, huomaat, ett\u00e4 <code>/etc/nginx/sites-available/default</code> tiedostossa m\u00e4\u00e4ritell\u00e4\u00e4n default endpoint <code>/var/www/html</code>. T\u00e4m\u00e4 on siis se hakemisto, johon sivut tulisi asentaa.</p> /etc/nginx/sites-available/default<pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm index.nginx-debian.html;\n    # ...\n}\n</code></pre> <p>T\u00e4m\u00e4 tarkoittaa, ett\u00e4 voimme vaihtaa etusivua siten, ett\u00e4 kirjoitamme <code>index.htm[l]</code> -tiedoston <code>/var/www/html</code> -hakemistoon. P\u00e4\u00e4tet\u00e4\u00e4n samalla, ett\u00e4 hakemiston ei tulisi olla <code>root:root</code> omistuksessa, vaan <code>www-data:www-data</code>. Syy on se, ett\u00e4 jatkossa voimme py\u00f6ritt\u00e4\u00e4 esimerkiksi staattista sivugeneraattoria k\u00e4ytt\u00e4j\u00e4ll\u00e4 www-data, jolloin se voi kirjoittaa hakemistoon ja sen tiedostoihin. Hakemiston omistajuuden tulisi olla <code>755</code> (<code>drwxr-xr-x</code>) ja tiedoston <code>644</code> (<code>-rw-r--r--</code>).</p> <p>Playbookin pit\u00e4isi siis tehd\u00e4 seuraavat askeleet, joista kaksi ensimm\u00e4ist\u00e4 olet jo kerran tehnyt:</p> <ul> <li>\u2705 Asenna Nginx (tuttu)</li> <li>\u2705 K\u00e4ynnist\u00e4 Nginx (tuttu)</li> <li>\ud83d\udcc2 Luo <code>/var/www/html</code> -hakemisto<ul> <li>Omistajaksi: www-data</li> <li>Oikeudet: 755</li> </ul> </li> <li>\ud83c\udf10 Luo <code>/var/www/html/index.html</code> -tiedosto<ul> <li>Sama omistaja kuin hakemistolla</li> <li>Oikeudet: 644</li> </ul> </li> </ul> <p>Saat p\u00e4\u00e4tt\u00e4\u00e4 HTML-tiedoston sis\u00e4ll\u00f6n itse, kuten my\u00f6s tavan, kuinka sen kirjoitat. Kenties haluat k\u00e4ytt\u00e4\u00e4 <code>ansible.builtin.copy</code> -moduulia ja m\u00e4\u00e4ritt\u00e4\u00e4 sis\u00e4ll\u00f6n YAML:n sis\u00e4ll\u00e4 content-kent\u00e4ss\u00e4? Tai ehk\u00e4 haluat k\u00e4ytt\u00e4\u00e4 <code>template</code> -moduulia ja noutaa tiedoston sis\u00e4ll\u00f6n erillisest\u00e4 tiedostosta? Valinta on sinun. Tiedoston sis\u00e4ll\u00f6ksi riitt\u00e4\u00e4 mik\u00e4 tahansa simppeli HTML-dokumentti. Jos et osaa HTML-kielt\u00e4, k\u00e4yt\u00e4 pohjana vaikkapa W3Schoolsin esimerkki\u00e4.</p> Template? <p>Jos haluat k\u00e4ytt\u00e4\u00e4 templatea, t\u00e4ss\u00e4 on vihje:</p> <pre><code>  - name: Create Index from Template\n    ansible.builtin.template:\n        src: ../templates/index.html.j2\n        dest: TODO\n        owner: TODO\n        group: TODO\n        mode: TODO\n    vars:\n        site_title: \"Hello from Template!\"\n        computer_name: \"{{ ansible_hostname }}\"\n</code></pre> <p>Yll\u00e4 esitelty <code>ansible_hostname</code> on Ansiblen Special Variable, joka pengotaan koneesta Fact Gathering -vaiheessa. N\u00e4in ensimm\u00e4isen koneen ip vastaisi:</p> <pre><code>Hello World!\nI am ansible-1`\n</code></pre> <p>Ja toisen:</p> <pre><code>Hello World!\nI am ansible-2`\n</code></pre> Teht\u00e4v\u00e4: Ufw from Galaxy <p>Luo yksinkertainen Playbook, jossa:</p> <ul> <li>Varmistat, ett\u00e4 <code>ufw</code> on asennettu</li> <li>Lis\u00e4\u00e4 seuraavat s\u00e4\u00e4nn\u00f6t:<ul> <li>Default policy, joka kielt\u00e4\u00e4 kaiken liikenteen</li> <li>Salli SSH</li> <li>Salli HTTP</li> </ul> </li> <li>Varmista, ett\u00e4 <code>ufw</code> on enabled</li> </ul> <p>K\u00e4yt\u00e4 teht\u00e4v\u00e4ss\u00e4 <code>community.general.ufw</code> moduulia. Selvit\u00e4, kuinka asennat sen, ja mist\u00e4 sen ohjeet l\u00f6ytyv\u00e4t.</p> <p>Voit tarkistaa, ett\u00e4 s\u00e4\u00e4nn\u00f6t ovat voimassa komennolla:</p> <pre><code># Ansible\n$ uv run ansible all -a \"ufw status\" --become\n\n# Multipass (jos suljet SSH-portin vahingossa)\n$ multipass exec ansible-1 -- sudo ufw status\n$ multipass exec ansible-2 -- sudo ufw status\n</code></pre>"},{"location":"ansible/99_einsteinium/","title":"\ud83d\udc68\u200d\ud83d\udd2c Einsteinium","text":""},{"location":"ansible/99_einsteinium/#tarpit","title":"T\u00e4rpit","text":"<p>Ei t\u00e4rppej\u00e4. Teht\u00e4v\u00e4nannossa on vihjeit\u00e4.</p>"},{"location":"ansible/99_einsteinium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Hostaa Linux Perusteet ja Skriptiohjelmointi</p> <p>Luo Playbook, joka ajaa gh:sourander/linux-perusteet sek\u00e4 gh:sourander/skriptiohjelmointi -repositorioissa esitellyt Material for MkDocs sivustot Multipassin luomissa koneissa. Muista, ett\u00e4 Inventory-tiedostossa n\u00e4m\u00e4 ovat lis\u00e4ttyin\u00e4 kummatkin ryhm\u00e4\u00e4n <code>multipass</code>, ja erikseen ryhmiin <code>first</code> ja <code>second</code>.</p> <p>Ty\u00f6vaiheet voi tehd\u00e4 esimerkiksi seuraavan rungon mukaisesti:</p> study_materials.yml<pre><code>---\n######################\n# Play: Dependencies #\n######################\n- name: Install dependencies\n  hosts: multipass\n  become: yes\n\n  tasks: []  # Asenna ainakin acl ja python3-virtualenv\n\n###############################\n# Play: Set global variables  #\n###############################\n- name: Set Playbook level variables\n  hosts: multipass\n  tasks:\n    - name: Set global variables\n      ansible.builtin.set_fact:\n        mkdocs_user: mkdocs\n        www_group: www-data\n        sites_directory: /var/www/html\n\n#####################\n# Play: MkDocs user #\n#####################\n- name: Create MkDocs user\n  hosts: multipass\n  become: yes\n\n  tasks: []  # Muista lis\u00e4t\u00e4 www-data ryhm\u00e4\u00e4n\n\n##############################\n# Play: Set up /var/www/html #\n##############################\n\n- name: Set up www directory permissions\n  hosts: first,second\n  become: yes\n\n  tasks: []\n\n###############\n# Play: Clone #\n###############\n\n- name: Cloning the repository to mkdocs user home\n  hosts: first,second\n  become: yes\n  become_user: \"{{ mkdocs_user }}\"\n\n  tasks: []\n\n###################\n# Play: MkDocs    #\n###################\n\n- name: Install and run Mkdocs Build\n  hosts: first,second\n  become: yes\n  become_user: \"{{ mkdocs_user }}\"\n\n  tasks: []\n\n  vars:\n    venv_dir: \"/home/{{ mkdocs_user }}/.venv\"\n    venv_python: \"{{ venv_dir }}/bin/python\"\n\n################\n# Play: Nginx  #\n################\n\n- name: Install and start Nginx with default settings\n  hosts: first,second\n  become: yes\n\n  tasks:\n    - name: Install\n      # implementoi\n    - name: Ensure Nginx is started and enabled\n      # implementoi\n    - name: Print what is running and where\n      ansible.builtin.debug:\n        msg: \"{{ repo_name }} is running at http://{{ inventory_hostname }}/\"\n...\n</code></pre> <p>Alla skriptin ajamisesta seulotut t\u00e4rke\u00e4t osat:</p> <pre><code>PLAY [Install dependencies]\nTASK [Gathering Facts]\nTASK [Install ACL package (for become_user)]\nTASK [Python virtualenv]\n\nPLAY [Set Playbook level variables]\nTASK [Set global variables]\n\nPLAY [Create MkDocs user]\nTASK [Create mkdocs user]\nTASK [Create Ansible temporary directory for mkdocs user]\n\nPLAY [Set up www directory permissions]\nTASK [Ensure www directory exists with proper permissions]\n\nPLAY [Cloning the repository to mkdocs user home]\nTASK [Clone the repository]\n\nPLAY [Install and run Mkdocs Build]\nTASK [Install pip dependencies]\nTASK [Build the site to the destination]\n\nPLAY [Install and start Nginx with default settings]\nTASK [Install]\nTASK [Ensure Nginx is started and enabled]\nTASK [Print what is running and where]\n    \"linux-perusteet is running at http://192.168.64.71/\"\n    \"skriptiohjelmointi is running at http://192.168.64.70/\"\n\nPLAY RECAP ***********************************\n192.168.64.70              : ok=13   changed=9 \n192.168.64.71              : ok=13   changed=9\n</code></pre> <p>Vinkki: Group Vars</p> <p>Muuttujat <code>repo_name</code> ja <code>repo_url</code> on n\u00e4pp\u00e4r\u00e4\u00e4 sijoittaa erilliseen tiedostoon, josta Ansible osaa ne automaattisesti noutaa, kunhan hosts on m\u00e4\u00e4ritelty muotoon <code>hosts: first,second</code>. Tarvitset YAML-tiedostoja kaksi: <code>first.yml</code> ja <code>second.yml</code>, ja niiden tulee olla hakemistossa <code>group_vars/</code>. Huomaa, ett\u00e4 tuo polku on relatiivinen playbookin sijaintiin, ei hakemistoon, jossa ajat Ansiblea. Alla ensimm\u00e4isen n\u00e4ist\u00e4 sis\u00e4lt\u00f6:</p> group_vars/first.yml<pre><code>repo_name: linux-perusteet\nrepo_url: https://github.com/sourander/linux-perusteet.git\n</code></pre> <p>Vinkki: Ajettava komento</p> <p>Komento, joka varsinaisesti rakentaa sivuston, on <code>mkdocs build</code>. Kokonaisuutena komento on:</p> <pre><code># Jinja:\n# {{ venv_python }} -m mkdocs build -d {{ sites_directory }}\n\n# Eli:\n$ /home/mkdocs/.venv/bin/python -m mkdocs build -d /var/www/html\n</code></pre> <p>Huomaa, ett\u00e4 komento tulee ajaa oikeassa hakemistossa, eli <code>~/linux-perusteet</code> tai <code>~/skriptiohjelmointi</code>.</p> <p>Vinkki: Tarvittavat pip-paketit</p> <p>Tarvitset paketit <code>mkdocs-material</code> ja <code>mkdocs-awesome-nav</code>. N\u00e4m\u00e4 voisi nuuhkia <code>pyprojects.toml</code>-tiedostosta, mutta helpoimmalla p\u00e4\u00e4set kun rautakoodaat ne.</p>"},{"location":"ansible/aloita/","title":"Ansible 101","text":""},{"location":"ansible/aloita/#perusteet","title":"Perusteet","text":""},{"location":"ansible/aloita/#missa-ajetaan","title":"Miss\u00e4 ajetaan?","text":""},{"location":"ansible/aloita/#lokaalisti","title":"Lokaalisti","text":"<p>Emme k\u00e4yt\u00e4 Docker-konttia Ansiblen ajamiseen, jotta s\u00e4\u00e4stymme mahdollisilta huolilta liittyen verkotukseen. Ansible control node ajetaan t\u00e4ll\u00e4 kurssilla omalta Linux-ty\u00f6asemalta. </p> <p>Ansiblea voi ajaa keskitetyst\u00e4 CI/CD-palvelusta (GitLab CI/CD, GitHub Actions, Jenkins, ...) tai keskitetyn hallintapalvelimen kautta (Ansible Tower, AWX), mutta perusteita opetellessa on helpointa ajaa Ansiblea lokaalisti. K\u00e4ytettiin sit\u00e4 mist\u00e4 tahansa, sen tiedostot s\u00e4il\u00f6t\u00e4\u00e4n tyypillisesti Git-repositorioon. </p> <p>Note</p> <p>Git ja \"<code>$ANYTHING</code> as a Code\" ovat DevOpsin perusta.</p> <p>Muuttuja <code>$ANYTHING</code> voi olla esimerkiksi:</p> <ul> <li>Platform as Code</li> <li>Infrastructure as Code</li> <li>Configuration as Code</li> <li>Pipeline as Code</li> <li>Policy as Code</li> <li>...</li> </ul>"},{"location":"ansible/aloita/#multipass","title":"Multipass","text":"<p>Ansible managed node on t\u00e4ll\u00e4 kurssilla Multipass-virtuaalikone. Huomaa, ett\u00e4 t\u00e4m\u00e4 ei tarkoita, ett\u00e4 me ajaisimme Ansiblea Multipass-virtuaalikoneessa. Ansible ajetaan control nodella, ja se yhdist\u00e4\u00e4 SSH:lla managed nodeen. Termi t\u00e4lle on agentless.</p>"},{"location":"ansible/aloita/#mika-ansible-on","title":"Mik\u00e4 Ansible on?","text":"<p>Ansible on DevOps- tai Configuration Management -ty\u00f6kalu, joka toteuttaa Configuration as Code-periaatetta. Sen omistaa Red Hat Inc., ja se on kirjoitettu Pythonilla, mutta tavallisessa k\u00e4yt\u00f6ss\u00e4 Python-taitoja ei tarvita: riitt\u00e4\u00e4, ett\u00e4 osaa kirjoittaa YAML-tiedostoja. Ansiblella ei siis tyypillisesti hallita intrastruktuuria vaan sen konfiguraatiota. Toisilla kursseilla sinulle on esitelty Terraform, joka on infrastruktuurin hallintaty\u00f6kalu: Ansible jatkaa siit\u00e4, mihin Terraform loppuu.</p> <p>Ansiblella voi siis esimerkiksi asentaa ohjelmia, konfiguroida palomuureja, luoda k\u00e4ytt\u00e4ji\u00e4, ajaa skriptej\u00e4, ja niin edelleen. Kaiken, mink\u00e4 voit tehd\u00e4 komentorivill\u00e4, voit tehd\u00e4 Ansiblella.</p> <p>Ansiblen kilpailijoita ovat esimerkiksi Puppet, Chef, VMware SaltStack. Toisin kuin useimmat kilpailijat, Ansible ei vaadi agenttien asentamista managed nodeihin, vaan se k\u00e4ytt\u00e4\u00e4 SSH:ta (tai Windows-nodejen kanssa WinRM:\u00e4\u00e4) managed nodeihin yhteyden ottamiseen. T\u00e4m\u00e4 tekee Ansiblesta helpon ottaa k\u00e4ytt\u00f6\u00f6n, koska managed nodeihin ei tarvitse asentaa mit\u00e4\u00e4n (paitsi SSH).</p> <p>Alla on taulukko tyypillisist\u00e4 entiteeteist\u00e4 tai konsepteista, jotka ovat osa Ansiblea:</p> Entiteetti Kuvaus Control node Ansiblen ajamiseen k\u00e4ytett\u00e4v\u00e4 kone Managed node Ansiblen hallinnoitava kone Inventory Managed nodejen lista Playbook Ansiblen suoritettava tiedosto Task Yksitt\u00e4inen komento Playbookissa Collection Kokoelma moduuleja (<code>&lt;namespace&gt;.&lt;collection&gt;</code>) Module Yksitt\u00e4inen komento (<code>&lt;namespace&gt;.&lt;collection&gt;.&lt;module&gt;</code>) <p>Moduuli on k\u00e4yt\u00e4nn\u00f6ss\u00e4 yksitt\u00e4inen Python-skripti, joka suoritetaan managed nodella. Kuinka t\u00e4m\u00e4 ajetaan? Control Node avaa SSH-yhteyden Managed Nodeen, etsii Python-bin\u00e4\u00e4rin, siirt\u00e4\u00e4 (<code>scp</code>:ll\u00e4) skriptin v\u00e4liaikaishakemistoon, ja ajaa skriptin: <code>/usr/bin/python3 /tmp/ansible_script_xyz.py</code>. Huomaa, ett\u00e4 Ansiblen ei tarvitse olla asennettuna Managed Nodeen: riitt\u00e4\u00e4, ett\u00e4 Python, SSH Daemon ja automaatioon sopiva k\u00e4ytt\u00e4j\u00e4 (default: <code>ubuntu</code>) ovat l\u00e4sn\u00e4.</p> <p>Tip</p> <p>Voit k\u00e4yd\u00e4 kurkkimassa Python-skriptien sis\u00e4lt\u00f6\u00e4. Esimerkiksi <code>ansible.builtin.command</code>-moduuli l\u00f6ytyy virtuaaliymp\u00e4rist\u00f6n luomisen j\u00e4lkeen <code>.venv/lib/python3.12/site-packages/ansible/modules/command.py</code>-tiedostosta. Jos haluat n\u00e4hd\u00e4 tiedoston ilman asennusta, se l\u00f6ytyy luonnollisesti GitHubista: gh:ansible/ansible/lib/ansible/modules/command.py/.</p>"},{"location":"ansible/aloita/#ero-skripteihin","title":"Ero skripteihin","text":"<p>Ansible on deklaratiivinen ty\u00f6kalu, toisin kuin imperatiiviset skriptit, kuten Bash-skriptit. Deklaratiivinen tarkoittaa, ett\u00e4 kerrot Ansiblelle, mit\u00e4 haluat, ja Ansible huolehtii siit\u00e4, ett\u00e4 se tapahtuu. Imperatiivinen tarkoittaa, ett\u00e4 kerrot tarkalleen, miten haluat, ett\u00e4 asiat tapahtuvat.</p> <p>Lis\u00e4ksi Ansible on idempotentti, eli voit ajaa saman Playbookin monta kertaa, ja lopputulos on aina sama. Jos desired state on jo saavutettu, Ansible ei tee mit\u00e4\u00e4n.</p>"},{"location":"ansible/aloita/#komponentit","title":"Komponentit","text":""},{"location":"ansible/aloita/#core-ja-community","title":"Core ja Community","text":"<p>Red Hat pyrkii tekem\u00e4\u00e4n Ansiblella rahaa, joten kaikki siihen liittyv\u00e4t ty\u00f6kalut eiv\u00e4t ole ilmaisia. Alla on taulukko Ansiblen eri palikoista ja tieto siit\u00e4, onko se ilmainen vai kuuluuko se maksulliseen tuotteeseen.</p> Ty\u00f6kalu Free $$$ Maksullinen vastine Ansible Core x Ansible Community x Ansible Navigator x x Automation Content Navigator Ansible Galaxy x x Automation Hub AWX x x Ansible Controller (ex Tower) x Red Hat Ansible Lightspeed x Red Hat Ansible Automation Platform x Red Hat Ansible on Clouds <p>Yll\u00e4 listatuista on hyv\u00e4 tiet\u00e4\u00e4, ett\u00e4:</p> <ul> <li>Ansible Core on varsinainen ansible-komentorivity\u00f6kalu.</li> <li>Ansible Navigator on TUI-k\u00e4ytt\u00f6liittym\u00e4 (Text User Interface) Ansiblelle. Tyypillisesti se hy\u00f6dynt\u00e4\u00e4 <code>podman</code> tai <code>docker</code>-konttia runtimen\u00e4. Emme k\u00e4sittele Navigatoria t\u00e4ll\u00e4 kurssilla. Meille riitt\u00e4\u00e4 CLI.</li> <li>Ansible Galaxy on pakettivarasto, josta voit ladata Collectioneita (vrt. PowerShell Gallery, PyPi).</li> <li>Ansible Community sis\u00e4lt\u00e4\u00e4 Ansible Coren, johon on valmiiksi asennettu kuratoitu kattaus Collectioneita.</li> <li>Maksulliset vastineet asentuvat Red Hat Ansible Automation Platformin mukana. Niit\u00e4 ei k\u00e4ytet\u00e4 t\u00e4ss\u00e4 kurssissa. Esimerkiksi Lightspeed on Red Hatin kehitt\u00e4m\u00e4 teko\u00e4lyavusteinen ty\u00f6kalu, joka auttaa sinua kirjoittamaan Ansible-koodia. Se asennettaisiin esimerkiksi VS Codeen Extensionina. Ansible on Clouds on tuotteistettu tapa asentaa Ansible pilvipalveluihin, kuten AWS:\u00e4\u00e4n tai Azureen.</li> </ul> <p>Lopulta on siis sama, asennatko ansible-coren vai ansiblen. Jos asennat ensimm\u00e4iseen kaikki j\u00e4lkimm\u00e4iseen sis\u00e4lty\u00e4t Collectionit, sinulla on k\u00e4yt\u00e4nn\u00f6ss\u00e4 sama paketti. Kuinka monta Collectiona ja mit\u00e4 ne ovat?</p> <ul> <li>Core<ul> <li>1 Collection.</li> <li>T\u00e4m\u00e4: Core docs: ansible.builtin</li> </ul> </li> <li>Community<ul> <li>Yli 100 Collectionia.</li> <li>Lista: Community docs: Collection Index</li> </ul> </li> </ul> <p>Rautalangasta</p> <p>Kuvittele, ett\u00e4 Windowsista olisi olemassa Windows Core ja Windows Community Gamer Edition (WCGE).</p> <p>WCGE sis\u00e4lt\u00e4isi: Windows Coren, eli tavallisen Windowsin, johon on valmiiksi asennettu: Steam, Discord, Chrome, ja Visual Studio Code.</p> <p>Lopulta on aivan sama, asennatko Windows Coren ja lataat sen j\u00e4lkeen Steam, Discord, Chrome ja Visual Studio Code erikseen, vai asennatko Windows Community Collectionin.</p>"},{"location":"ansible/aloita/#versionumerot","title":"Versionumerot","text":"<p>Jotta homma ei olisi liian simppeli\u00e4, Community ja Coren versionumerot poikkeavat toisistaan, ja lis\u00e4ksi standardi on vaihtunut 2021 Ansible 3:n my\u00f6t\u00e4. Alla on taulukko, joka kertoo, mik\u00e4 Coren versio vastaa mit\u00e4kin Communityn versiota:</p> Ansible Ansible Core Ansible 11 2.18 Ansible 10 2.17 Ansible 9 2.16 ... ... Ansible 3 2.11 Ansible 2.10 2.10 Ansible 2.9 2.9 <p>Nyky\u00e4\u00e4n riitt\u00e4\u00e4 tiet\u00e4\u00e4, ett\u00e4 Python Package Indexiss\u00e4 on ansible-core-paketti, joka on Ansible Coren uusin versio, ja ansible-paketti, joka on Ansible (Community) uusin versio. Kirjoitushetkell\u00e4 versiot m\u00e4ts\u00e4\u00e4v\u00e4t yll\u00e4 n\u00e4kyv\u00e4\u00e4n taulukkoon, eli versiot 11 ja 2.18 ovat tuoreimmat:</p> <ul> <li>Ansible (Community) 11.3.0</li> <li>Ansible Core 2.18.3</li> </ul>"},{"location":"ansible/aloita/#playbook","title":"Playbook","text":""},{"location":"ansible/aloita/#sisalto","title":"Sis\u00e4lt\u00f6","text":"<p>Hello World -viritelm\u00e4\u00e4n tarvitsemme v\u00e4hint\u00e4\u00e4n kaksi tiedostoa: Inventory ja Playbook.</p> <p>Playbook on Ansiblen suoritettava tiedosto, joka koostuu yhdest\u00e4 tai useammasta playsta. Play on yksi tai useampi task, joka suoritetaan managed nodeilla. Task on yksitt\u00e4inen komento, joka suoritetaan managed nodella. Alla on yksinkertainen Playbook, joka on lainattu Ansible Community: Getting started with Ansible-dokumentaatiosta.</p> my-first-playbook.yml<pre><code>- name: My first play\n  hosts: myhosts\n  tasks:\n   - name: Ping my hosts\n     ansible.builtin.ping:\n\n   - name: Print message\n     ansible.builtin.debug:\n       msg: Hello world\n</code></pre> <p>Kyseinen Playbook sis\u00e4lt\u00e4\u00e4 yhden playn, My first play, joka sis\u00e4lt\u00e4\u00e4 kaksi taskia. Ensimm\u00e4inen task k\u00e4ytt\u00e4\u00e4 <code>ansible.builting</code> Collectionista moduulia nimelt\u00e4\u00e4n <code>ping</code>, ja toinen k\u00e4ytt\u00e4\u00e4 saman Collectionin <code>debug</code>-moduulia.</p> <p>Kolme v\u00e4liviivaa</p> <p>Tulet t\u00f6rm\u00e4\u00e4m\u00e4\u00e4n esimerkkeihin, joissa Playbook alkaa kolmella v\u00e4liviivalla. T\u00e4m\u00e4 kuuluu YAML-tiedoston spesifikaatioon, ja merkkaa dokumentin alkua: \"YAML uses three dashes (\u201c---\u201d) to separate directives from document content. This also serves to signal the start of a document if no directives are present.\"</p> <p>Meid\u00e4n harjoituksissa yhdess\u00e4 YAML-tiedostossa ei tule koskaan olemaan enemp\u00e4\u00e4 kuin yksi dokumentti, joten ne voi n\u00e4hd\u00e4 valinnaisina. Ota tai j\u00e4t\u00e4.</p> <p>Kolme pistett\u00e4</p> <p>Sama tarina kuin yll\u00e4, mutta <code>...</code>-merkkaa dokumentin loppua. Valinnainen, mutta spesifikaation mukainen.</p> <p>Toinen tiedosto on Inventory, joka sis\u00e4lt\u00e4\u00e4 listan IP-osoitteista tai hostnameista, joihin Ansible yhdist\u00e4\u00e4. Inventory voi olla yksinkertainen tiedosto, joka sis\u00e4lt\u00e4\u00e4 hy\u00f6dynt\u00e4\u00e4 ryhmi\u00e4 ja muuttujia. Tiedosto voi olla <code>.ini</code> tai <code>.yaml</code>-muotoinen. Alla on esimerkki <code>.ini</code>-muotoisesta Inventory-tiedostosta, joka on lainattu samasta l\u00e4hteest\u00e4 kuin Playbook:</p> inventory.ini<pre><code>[myhosts]\n192.0.2.50\n192.0.2.51\n</code></pre>"},{"location":"ansible/aloita/#ajaminen","title":"Ajaminen","text":"<p>Olettaen, ett\u00e4 sinulla on <code>ansible-core</code> asennettuna, voit ajaa Playbookin seuraavasti:</p> <pre><code>ansible-playbook -i inventory.ini my-first-playbook.yml\n</code></pre> <p>T\u00e4m\u00e4 komento ajaa Playbookin <code>my-first-playbook.yml</code> ja k\u00e4ytt\u00e4\u00e4 Inventory-tiedostoa <code>inventory.ini</code>. Ansible yhdist\u00e4\u00e4 IP-osoitteisiin ja suorittaa m\u00e4\u00e4ritellyt taskit j\u00e4rjestyksess\u00e4 ylh\u00e4\u00e4lt\u00e4 alas.</p>"},{"location":"ansible/aloita/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Ansiblen informaatiohaku</p> <p>Muodosta itsellesi katalogi tarpeellisista l\u00e4hteist\u00e4. Suosi tuoreita ja virallisia l\u00e4hteit\u00e4. Alla pari suositusta, mist\u00e4 aloittaa etsint\u00e4:</p> <ol> <li>Ansible Community Documentation. Vaikka me k\u00e4yt\u00e4mme <code>ansible-core</code>-pakettia, t\u00e4m\u00e4 dokumentaatio on silti hy\u00f6dyllinen. Ainut, mit\u00e4 sinun pit\u00e4\u00e4 huomioida, ett\u00e4 <code>ansible.builtin</code>-moduuli on Ansible Coren oma, muut moduulit ovat Collectioneista. Jos tarvitset jotakin muuta pluginia (moduulia tai roolia), asenna se <code>ansible-galaxy</code>-komennolla.</li> <li>Ansible for DevOps. T\u00e4m\u00e4 avoimen l\u00e4hdekoodin kirja on ostettavissa, jos haluaa tukea kirjoittajaa. Kirja on saatavilla ilmaiseksi: etsi GitHubista lausetta \"You can also grab a free copy of the published work on LeanPub using this coupon link\".</li> <li>Ansible for DevOps Examples. Latasit yll\u00e4 olevan kirjan tai et, t\u00e4m\u00e4 repositorio on hy\u00f6dyllinen, koska se sis\u00e4lt\u00e4\u00e4 paljon esimerkkej\u00e4. Eik\u00e4 ihan mit\u00e4 tahansa esimerkkej\u00e4. Jos etsit ladatuimmat Rolet Ansible Galaxyst\u00e4, huomaat, ett\u00e4 top 10 on t\u00e4ynn\u00e4 t\u00e4m\u00e4n kirjoittajan rooleja. Kirjoitushetkell\u00e4 ladatuin on <code>geerlingguy.docker</code> noin 22 miljoonalla latauksella.</li> <li>Practical Ansible Automation Handbook on vaihtoehtoinen kirja ja se l\u00f6ytyy KAMK Finna -kirjastosta. Kirja on vuodelta 2023 ja Luca Bertonin kirjoittama.</li> </ol> <p>My\u00f6s maksullisia kirjoja l\u00f6ytyy, joista maininnan arvoinen on Ansible: Up and Running 3rd e.d. (2022), joka O'Reillyn julkaisema ja . Data Center -opiskelijoita voi kiinnostaa my\u00f6s Ansible for VMware by Examples: A Step-by-Step Guide to Automating Your VMware Infrastructure (2022), joka on Apressin julkaisema ja Luca Bertonin kirjoittama.</p> <p>Ansible on aihe, josta l\u00f6ytyy merkitt\u00e4v\u00e4sti my\u00f6s YouTube-sis\u00e4lt\u00f6\u00e4.</p>"},{"location":"ansible/lukeminen/","title":"Lukeminen","text":""},{"location":"ansible/lukeminen/#esimerkkeja","title":"Esimerkkej\u00e4","text":""},{"location":"ansible/lukeminen/#scylladb","title":"ScyllaDB","text":"<p>Tutustu ScyllaDB:n Set Up a Spark Cluster with Ansible ohjeeseen. Ohje sis\u00e4lt\u00e4\u00e4 opastuksen vaiheista ja komennoista, joilla k\u00e4ytt\u00e4j\u00e4 saisi Spark-klusterin pystyyn Ansiblen avulla. Klusteriin kuuluu yksi <code>spark_master</code> ja kaksi workeria: <code>spark_worker1</code> ja <code>spark_worker2</code>.</p> <p>Itse koodi l\u00f6ytyy: gh:scylladb/scylladb/scylla-migrator repositoriosta</p>"},{"location":"ansible/lukeminen/#etsi-ohje","title":"Etsi ohje","text":"<p>Voit etsi\u00e4 my\u00f6s muita ohjeita, jotka k\u00e4ytt\u00e4v\u00e4t Ansiblea. P\u00e4\u00e4asia, ett\u00e4 ohjeesta l\u00f6ytyy Playbook ja Inventory -tiedostot, jotta voit tutustua Ansiblen syntaksiin. Yksi tapa on etsi\u00e4 esimerkiksi <code>medium.com</code>, <code>dev.to</code> tai <code>substack.com</code> sivustojen artikkeleita. Voit etsi\u00e4 tietty\u00e4 vuotta tuoreempia artikkeleita tietylt\u00e4 sivustolta n\u00e4in:</p> <pre><code>deploy ansible site:medium.com after:2023\n</code></pre>"},{"location":"ansible/lukeminen/#open-forms","title":"Open Forms","text":"<p>Tutustu Open Forms -projektin Install using Ansible -ohjeeseen. Ohje sis\u00e4lt\u00e4\u00e4 opastuksen vaiheista ja komennoista, joilla k\u00e4ytt\u00e4j\u00e4 saisi Open Forms -sovelluksen pystyyn Ansiblen avulla.</p> <p>Itse koodi l\u00f6ytyy gh:open-formulieren/open-forms repositoriosta.</p> <p>Huomaa, ett\u00e4 koodissa k\u00e4ytet\u00e4\u00e4n rooleja, jotka ovat Ansiblen tapa luoda itsen\u00e4inen kokonaisuus toisiinsa liittyvist\u00e4 taskeista, muuttujista, tiedostoista ja muista asseteista siten, ett\u00e4 sit\u00e4 voi k\u00e4ytt\u00e4\u00e4 useissa eri Playbookeissa. Roolit itsess\u00e4\u00e4n ladataan t\u00e4ss\u00e4 tapauksessa toisesta collectionista:</p> <pre><code>  collections:\n    - maykinmedia.commonground\n</code></pre> <p>N\u00e4m\u00e4 roolit l\u00f6ytyv\u00e4t <code>gh:maykinmedia/commonground-ansible</code> repositoriosta, joka on siis Ansible Galaxyst\u00e4 l\u00f6ytyv\u00e4 Galaxy: maykinmedia.commonground Collection. Esimerkiksi roolin <code>django_app_docker</code> koodi l\u00f6ytyy repositorion polusta roles/django_app_docker/tasks/main.yml.</p> <p>Warning</p> <p>T\u00e4m\u00e4 on monimutkainen esimerkki! \u00c4l\u00e4 huoli, jos et ymm\u00e4rr\u00e4 kaikkea koodia. Pyri silti silm\u00e4ilem\u00e4\u00e4n koodia ja tunnistamaan syntaksista merkityksellisi\u00e4 palasia.</p>"},{"location":"ansible/lukeminen/#syventavaa-lukemista","title":"Syvent\u00e4v\u00e4\u00e4 lukemista","text":""},{"location":"ansible/lukeminen/#ansible-lokaalisti","title":"Ansible Lokaalisti","text":"<p>Ansible on suunniteltu k\u00e4ytett\u00e4v\u00e4ksi keskitettyn\u00e4 ty\u00f6kaluja, jolla hallinnoidaan useiden koneiden konfiguraatiota, mutta kukaan ei est\u00e4 k\u00e4ytt\u00e4m\u00e4st\u00e4 sit\u00e4 vain ja ainoastaan omien ty\u00f6asemien konfiguroimiseen. Kenties kyll\u00e4styt esimerkiksi varmistelemaan, ett\u00e4 sinun <code>.zshrc</code>-tiedostosta l\u00f6ytyy tietyt rivit. Jos ajat sokkona seuraavan koodiblokin, p\u00e4\u00e4dyt lis\u00e4\u00e4m\u00e4\u00e4n samat rivit useita kertoja:</p> <pre><code>echo 'alias gitweek=\"'git log --pretty=format:\"%x09%ad%x09%s\" --date=format:\"%V %a\"'' &gt;&gt; ~/.zshrc\necho 'eval \"$(uv generate-shell-completion zsh)\"' &gt;&gt; ~/.zshrc\necho 'eval \"$(uvx --generate-shell-completion zsh)\"' &gt;&gt; ~/.zshrc\n</code></pre> <p>Voit korvata t\u00e4m\u00e4n joko <code>ansible.builtin.lineinfile</code> tai <code>blockinfile</code> moduulia hy\u00f6dynt\u00e4en. Esimerkiksi:</p> <pre><code>- name: Add gitweek alias to startup scripts\n  ansible.builtin.lineinfile:\n    path: ~/.zshrc\n    line: 'alias gitweek='git log --pretty=format:\"%x09%ad%x09%s\" --date=format:\"%V %a\"''\n    regexp: '^alias gitweek='\n- name: Add uv autocompletion to startup scripts\n  ansible.builtin.blockinfile:\n    path: ~/.zshrc\n    block: |\n      # uv and uvx autocompletion\n      eval \"$(uv generate-shell-completion zsh)\"\n      eval \"$(uvx --generate-shell-completion zsh)\"\n</code></pre> <p>Luonnollisesti yll\u00e4 olevan <code>typora</code>-aliasis voisi lis\u00e4t\u00e4 my\u00f6s <code>blockinfile</code>-moduulin avulla.</p>"},{"location":"ansible/lukeminen/#ansible-dotfiles","title":"Ansible dotfiles","text":"<p>Yll\u00e4 mainitun lokaalin ty\u00f6aseman hallinnan voi vied\u00e4 niin pitk\u00e4lle kuin haluaa. Ansible ei ole toki ainut ty\u00f6kalu, jolla voit hakea dotfilesisisi GitHubista tai jostakin muusta keskitetyst\u00e4 l\u00e4hteest\u00e4, mist\u00e4 l\u00f6ytyy niiden tuoreimmat versiot. T\u00e4h\u00e4n l\u00f6ytyy hirve\u00e4 m\u00e4\u00e4r\u00e4 kilpailevia ratkaisuja. T\u00e4ss\u00e4 luvussa k\u00e4sitell\u00e4\u00e4n Ansiblea, joten on luontevaa pohtia, kuinka ongelman voisi ratkaista Ansiblea hy\u00f6dynt\u00e4en. T\u00e4h\u00e4n tarjoaa yhdenlaisen ratkaisun esimerkiksi TechDufus, katso video alta. Videolla saat pikaisen katsauksen my\u00f6s Ansible Vaultiin, jota ei k\u00e4sitell\u00e4 t\u00e4ll\u00e4 kurssilla. Ansible Vault mahdollistaa arkaluonteisten tietojen salaamisen siten, ett\u00e4 ne voi s\u00e4ilytt\u00e4\u00e4 versionhallinnassa. Esimerkiksi SSH-avaimet, salasanat ja muut arkaluontoiset tiedot voi salata ja purkaa Ansible Vaultin avulla.</p> <p>Video 1: Kehitysymp\u00e4rist\u00f6n pystytys Ansiblea hy\u00f6dynt\u00e4en. Varsinainen koodi l\u00f6ytyy gh:techdufus/dotfiles repositoriosta.</p> <p>Onko t\u00e4m\u00e4 tarpeen? Riippuu t\u00e4ysin sinusta. Jos k\u00e4yt\u00e4t useita eri ty\u00f6asemia, ja sinulla on tarve pit\u00e4\u00e4 niiden kehitysymp\u00e4rist\u00f6t kaikkine konfiguraatioineen synkronissa, ja tarpeet ovat monimutkaisempia kuin pelkk\u00e4 yksi tai kaksi aliasia, niin silloin Ansible voi olla hyv\u00e4 vaihtoehto. Muissa tapauksissa over-engineering voi olla vaarana.</p>"},{"location":"ansible/lukeminen/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Parsi Ansible-koodit</p> <p>T\u00e4m\u00e4 teht\u00e4v\u00e4tyyppi on tuttu jo Bash, PowerShell ja Python osioista. Valitse yll\u00e4 olevista Ansible-esimerkeist\u00e4 yksi ja tutustu sen koodin sis\u00e4lt\u00f6\u00f6n. Kirjoita yl\u00f6s l\u00f6yt\u00e4m\u00e4si syntaksin palaset, jotka ovat uniikkeja. Huomaa, ett\u00e4 koodi ei ole pelk\u00e4st\u00e4\u00e4n yhdess\u00e4 tiedostossa, vaan sinun tulee yleens\u00e4 tutustua 2-3 tiedostoon:</p> <ul> <li>Playbook (<code>something.yml</code>)</li> <li>Inventory (<code>something.ini</code>)</li> <li>Ansible Configuration (<code>ansible.cfg</code>)</li> </ul> <p>J\u00e4lkimm\u00e4ist\u00e4 tiedostoa ei v\u00e4ltt\u00e4m\u00e4tt\u00e4 ole aina olemassa kaikissa esimerkeiss\u00e4.</p> <p>Huomaa, ett\u00e4 jos jokin moduuli on todella lyhytt\u00e4 muotoa kuten <code>shell</code>, se viittaa <code>ansible.builtin.shell</code>-moduuliin. FQCN (Fully Qualified Collection Name) on aina suositeltavaa k\u00e4ytt\u00e4\u00e4, mutta se ei ole pakollista, jos moduuli on Ansiblen Coresta.</p>"},{"location":"bash/31_gallium/","title":"\ud83d\udca1 Gallium","text":"<p>Osaat jo ajaa Hello World -skriptin, ja olet lukenut oikeaa tuotantokoodia. T\u00e4ss\u00e4 luvussa harjoittelemme yksinkertaisia skriptej\u00e4, jotka eiv\u00e4t odota argumentteja tai k\u00e4ytt\u00e4j\u00e4n sy\u00f6tett\u00e4. Ne eiv\u00e4t my\u00f6sk\u00e4\u00e4n luo tai tuohoa tiedostoja. Seuraavassa luvussa siirrymme ajamaan skriptej\u00e4 Docker-kontissa, jolloin voimme k\u00e4ytt\u00e4\u00e4 hitusen riskialttiimpia skriptej\u00e4.</p> <p>Olet kasannut itsellesi oppimateriaaleja, joten t\u00e4m\u00e4 paketti ei keskity esittelem\u00e4\u00e4n teoriaa. Alla on kuitenkin muutama t\u00e4rppi, joista voi olla hy\u00f6ty\u00e4. Varsinkin debug-taidot kannattaa ottaa haltuun.</p>"},{"location":"bash/31_gallium/#muuttujanimet","title":"Muuttujanimet","text":"<p>Muuttujien nimet voivat olla mit\u00e4 tahansa, mutta niiden tulee alkaa kirjaimella tai alaviivalla ja niiss\u00e4 voi olla kirjaimia, numeroita ja alaviivoja. Muuttujanimet ovat case-sensitiivisi\u00e4, eli <code>muuttuja</code> ja <code>Muuttuja</code> ovat kaksi eri muuttujaa.</p> <p>Bashissa k\u00e4ytet\u00e4\u00e4n usein kokonaan pienill\u00e4 kirjoitettuja muuttujia ja eri sanat irrotetaan toisistaan <code>snake_case</code>-tyylill\u00e4. Esimerkiksi <code>max_length</code> on hyv\u00e4 muuttujanimi.</p> <p>Kussakin kieless\u00e4 on varattuja avainsanoja (engl. reserved keyword). Niit\u00e4 ei voi k\u00e4ytt\u00e4\u00e4 muuttujien nimin\u00e4. N\u00e4m\u00e4 on listatuna alla.</p> <pre><code>if          then        else        elif        \nfi          case        esac        for         \nselect      while       until       do          \ndone        in          function    time        \n{           }           !           [[          \n]]          coproc      \n</code></pre> Klikkaa auki skripti, jolla lista muodostettiin reserved.sh<pre><code>#!/bin/bash\n\n# Get all reserved keywords\nkeywords=($(compgen -k))\n\n# Define the number of columns\ncolumns=4\n\n# Loop through and print in formatted columns\nfor ((i = 0; i &lt; ${#keywords[@]}; i++)); do\n    printf \"%-12s\" \"${keywords[i]}\"\n\n    # Print a newline after every nth column\n    if (( (i + 1) % columns == 0 )); then\n        echo\n    fi\ndone\n\n# End the output with a newline\necho\n</code></pre> <p>Warning</p> <p>Varattujen avainsanojen lis\u00e4ksi on lista Bashin sis\u00e4\u00e4nrakennettuja komentoja, jotka voit ylikirjoittaa, mutta t\u00e4m\u00e4 ei luonnollisesti kannata. Esimerkiksi <code>cd ..</code>-komennon pit\u00e4isi vaihtaa hakemistopuussa yksi hakemisto yl\u00f6sp\u00e4in. Katso alta skripti, jossa kyseinen komento tulostaa vain <code>.. by cd()</code>, koska se on korvattu samannimisell\u00e4 funktiolla kyseisen skriptin sis\u00e4ll\u00e4.</p> overwrite_cd.sh<pre><code>#!/bin/bash -e\ncd() {\n    local var=\"$1\";\n    echo \"${var} by cd()\";\n}\n\ncd ..\n</code></pre> <p>T\u00e4m\u00e4 ei riko skriptin ulkopuolista <code>cd</code>-komennon toimintaa, paitsi jos sen tuo kyseiseen namespaceen <code>source</code>-komennolla. T\u00e4m\u00e4n j\u00e4lkeen hakemiston muuttuminen muuttuu merkitt\u00e4v\u00e4n hankalaksi:</p> \ud83d\udc33 Bash<pre><code>$ source /app/overwrite_cd.sh \n.. by cd()\n\n$ cd /etc/\n/etc/ by cd()\n\n$ cd $HOME\n/root by cd()\n</code></pre>"},{"location":"bash/31_gallium/#muuttujan-asettaminen","title":"Muuttujan asettaminen","text":"<p>Muuttujan asettaminen tapahtuu seuraavasti:</p> <pre><code># \u2705 Oikein\nmuuttuja=\"arvo\"\nmuuttuja='arvo'\nmuuttuja=arvo\nmuuttuja=\"moni sanainen arvo\"\nmuuttuja=5       # Merkkijono \"5\", ei varsinainen numero\n\n# \u26d4\ufe0f V\u00e4\u00e4rin\nmuuttuja = \"arvo\"\nmuuttuja=moni sanainen arvo\n</code></pre> <p>Lis\u00e4ksi on mahdollista k\u00e4ytt\u00e4\u00e4 <code>declare</code>-komentoa, joka on Bashin sis\u00e4\u00e4nrakennettu komento muuttujien m\u00e4\u00e4rittelyyn. <code>declare</code>-komento on hy\u00f6dyllinen, jos haluat m\u00e4\u00e4ritt\u00e4\u00e4 muuttujan tyypin.</p> <pre><code># Kokonaisluku\ndeclare -i muuttuja=5\n\n# Joukko (array)\ndeclare -a my_array=(\"eka\" \"toka\" \"kolmas\")\n\n# Joukko (assoasiative array)\ndeclare -A my_dictionary=([key1]=\"value1\" [key2]=\"value2\")\n</code></pre> <p>Jos haluat tulostaa kaikki k\u00e4ytt\u00e4m\u00e4si muuttujat, kirjoita <code>declare -p</code>.</p> <p>Saavutettuja hy\u00f6tyj\u00e4 <code>declare -&lt;tyyppi&gt;</code>-k\u00e4yt\u00f6st\u00e4 ovat mm. virheiden v\u00e4ltt\u00e4minen ja koodin selkeytt\u00e4minen. Vahvasti tyyppim\u00e4\u00e4ritelty\u00e4 kielt\u00e4 Bashist\u00e4 ei n\u00e4in tule, mutta <code>declare</code>-komento auttaa hieman. </p> Aritmeettiset operaatiot? <p>Voit suorittaa kokonaislukumuuttujien avulla laskuoperaatioita esimerkiksi n\u00e4in:</p> aritmeettinen.sh<pre><code>#!/bin/bash\ndeclare -i a=5 b=3 x=0\nx=a*b\necho \"Tulo: $x\"\n</code></pre> <p>Vaihtoehtoinen tapa on <code>let</code>, joka k\u00e4sittelee kaikkia <code>=</code>-merkin oikealla puolella olevia muuttujia lukuina.</p> aritmeettinen_let.sh<pre><code>#!/bin/bash\na=5\nb=3\nlet \"x=a*b\"\necho \"Tulo: $x\"\n</code></pre> aritmeettinen_compound.sh<pre><code>#!/bin/bash\na=5\nb=3\n(( x = a * b ))\necho \"Tulo: $x\"\n</code></pre> <p>Warning</p> <p>Huomaa, ett\u00e4 luvut ovat kokonaislukuja, mik\u00e4 aiheuttaa sen, ett\u00e4 esimerkiksi <code>5 / 3</code> palauttaa luvun <code>1</code>. Jos jostain syyst\u00e4 haluat k\u00e4ytt\u00e4\u00e4 liukulukuja, sinun tulee kutsua jotakin ulkoista ohjelmaa, kuten <code>bc</code>-ohjelmaa. L\u00e4ht\u00f6kohtaisesti Bash ei kuitenkaan ole matemaattinen ohjelmointikieli vaan skriptikieli, joten j\u00e4t\u00e4mme n\u00e4m\u00e4 operaatiot muiden kielien ongelmaksi t\u00e4ll\u00e4 kurssilla.</p>"},{"location":"bash/31_gallium/#vianetsinta","title":"Vianetsint\u00e4","text":"<p>Virheiden etsiminen on t\u00e4rke\u00e4 osa ohjelmointia. Bashissa on muutamia tapoja, joilla voit helpottaa vianetsint\u00e4\u00e4.</p>"},{"location":"bash/31_gallium/#set-builtin","title":"Set Builtin","text":"<p>Jos haluat debugata skripti\u00e4si, voit k\u00e4ytt\u00e4\u00e4 <code>set -x</code> ja <code>set -u</code> -komentoja. Ensimm\u00e4inen tulostaa jokaisen komennon ennen sen suorittamista ja j\u00e4lkimm\u00e4inen kaataa skriptin, jos k\u00e4yt\u00e4t m\u00e4\u00e4rittelem\u00e4t\u00f6nt\u00e4 muuttujaa. J\u00e4lkimm\u00e4inen kaatuu my\u00f6s silloin, jos yrit\u00e4t esimerkiksi sijoittaa merkkijonon kokonaislukumuuttujaan. Tutustu my\u00f6s muihin The Set Builtin optioihin. N\u00e4ist\u00e4 varsinkin <code>-e</code> on hy\u00f6dyllinen, joka kaataa skriptin, jos jokin komento palauttaa virheen.</p> muuttuja_set_none.sh<pre><code>#!/bin/bash\n\ndeclare -i luku=5\n\nluku=\"kissa\"\necho $luku\n</code></pre> muuttuja_set_u.sh<pre><code>#!/bin/bash -u\n# ...\n</code></pre> muuttuja_set_ux.sh<pre><code>#!/bin/bash -ux\n# ... \n</code></pre> <p>Tip</p> <p>Samat optiot voi antaa my\u00f6s skripti\u00e4 ajaessa n\u00e4in: <code>bash -u muuttuja_set_u.sh</code>.</p>"},{"location":"bash/31_gallium/#echo","title":"Echo","text":"<p>Yksi luonnollinen tapa debugata l\u00e4hes mit\u00e4 tahansa ohjelmointikielt\u00e4 on k\u00e4ytt\u00e4\u00e4 <code>echo</code>-komennon tulostusta. Voit tulostaa muuttujien arvoja ja tarkistaa, ett\u00e4 ne ovat oikein.</p>"},{"location":"bash/31_gallium/#interaktiivinen","title":"Interaktiivinen","text":"<p>Huomaa, ett\u00e4 Bashi\u00e4 voi ajaa skriptin lis\u00e4ksi my\u00f6s interaktiivisesti komentorivilt\u00e4. T\u00e4m\u00e4 voi kuulostaa itsest\u00e4\u00e4nselv\u00e4lt\u00e4, mutta on helppoa unohtaa, ett\u00e4 keskell\u00e4 200-rivist\u00e4 skripti\u00e4 olevan rivin voi my\u00f6s ajaa erikseen ihan vain kopioimalla sen ja liitt\u00e4m\u00e4ll\u00e4 terminaaliin.</p>"},{"location":"bash/31_gallium/#declare","title":"Declare","text":"<p>Ajoittain on tarpeellista katsoa, mit\u00e4 muuttujia on m\u00e4\u00e4ritelty ja mit\u00e4 niiden arvot ovat. T\u00e4m\u00e4 onnistuu <code>declare -p</code>-komennolla. Se tulostaa kaikki m\u00e4\u00e4ritellyt muuttujat ja niiden arvot - my\u00f6s sellaiset, jotka Bash on m\u00e4\u00e4ritellyt jossain sinun skriptin ulkopuolella. Sinun m\u00e4\u00e4rittelem\u00e4t muuttuja-arvot ovat onneksi helposti listan lopussa.</p> declare_p.sh<pre><code>#!/bin/bash\ndeclare -A my_dictionary=([key1]=\"value1\" [key2]=\"value2\")\nmy_dictionary[key3]=\"kissa\"\n\ndeclare -p\n</code></pre> \ud83d\udda5\ufe0f Host<pre><code># Komentoa lyhennetty - ks. runbash.sh alemmasta teht\u00e4v\u00e4st\u00e4.\ndocker container run ... declare_p.sh\n</code></pre> \ud83d\udc33 stdout<pre><code># ...\ndeclare -x TERM=\"xterm\"\ndeclare -ir UID=\"0\"\ndeclare -- _=\"\"\ndeclare -A my_dictionary=([key2]=\"value2\" [key3]=\"kissa\" [key1]=\"value1\" )\n</code></pre> <p>Tip</p> <p>Jos haluat tulostaa tietyt muuttujat, sinun tulee antaa ne argumentteina.</p> <pre><code>declare -p muuttuja1 muuttuja2 ...\n</code></pre>"},{"location":"bash/31_gallium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runbash.sh <p>Ensimm\u00e4isen\u00e4 teht\u00e4v\u00e4n\u00e4 luot itsellesi devausymp\u00e4rist\u00f6n. K\u00e4yt\u00e4nn\u00f6ss\u00e4 luot:</p> <ul> <li>Hakemistorakenteen teht\u00e4vien vastauksia varten</li> <li>Skriptin <code>runbash.sh</code>, joka joko:<ul> <li>Ajaa valitun skriptin kontissa</li> <li>K\u00e4ynnist\u00e4\u00e4 interaktiivisen Bashin kontissa</li> </ul> </li> <li>Varmistat, ett\u00e4 kaikki on versionhallinnassa</li> </ul> <p>Opettaja on antanut sinulle tyhj\u00e4n repositorion t\u00e4t\u00e4 kurssia varten, ja se on esimerkiksi osoitteessa <code>https://gitlab.dclabra.fi/skriptiohjelmointi-2054/johnanderton</code>. Tyhj\u00e4 repositorio sis\u00e4lt\u00e4\u00e4 ohjeet, kuinka voit luoda lokaalin repositorion ja alustaa sen <code>main</code>-haaralla sek\u00e4 tyhj\u00e4ll\u00e4 <code>README.md</code>-tiedostolla. Noudata GitLabin ohjeita. Kloonaa repositorio lokaatioon:</p> <ul> <li>\u24c2\ufe0f win: <code>C:\\Users\\uname\\Code\\skriptiohjelmointi-2054\\johnanderton</code></li> <li>\ud83d\udc27 linux: <code>/home/uname/Code/skriptiohjelmointi-2054/johnanderton</code></li> </ul> <p>Korvaa 2054 kuluvalla vuodella. Korvaa johnanderton omalla nimell\u00e4si, jossa kirjoitusa on s\u00e4hk\u00f6postisi alku: <code>xxxxxx@kamk.fi</code>)</p> <p>Miksi 2054?</p> <p>Minority Report -elokuvan John Anderton seikkailee vuodessa 2054. K\u00e4yt\u00e4n fiktionaalista vuotta, jotta t\u00e4t\u00e4 materiaalia ei tarvitse p\u00e4ivitt\u00e4\u00e4 joka toteutuksen yhteydess\u00e4.</p> <p>Luo repositorion sis\u00e4llle seuraava rakenne:</p> <pre><code>johnanderton\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 bash\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 runbash.sh\n\u2502   \u2514\u2500\u2500 scripts\n\u2502       \u251c\u2500\u2500 kaikki.sh\n\u2502       \u251c\u2500\u2500 skriptit.sh\n\u2502       \u2514\u2500\u2500 tanne.sh\n\u251c\u2500\u2500 pwsh\n\u2502   \u2514\u2500\u2500 .gitkeep \n\u2514\u2500\u2500 python\n    \u2514\u2500\u2500 .gitkeep\n</code></pre> <p>Tiedosto <code>runbash.sh</code>:n luominen olisi hyv\u00e4 teht\u00e4v\u00e4 viikon p\u00e4\u00e4st\u00e4, mutta tarvitset sit\u00e4 jo nyt, joten tarjoan sen valmiina. Voit ladata sen Githubista osoitteesta gh:sourander/skriptiohjelmointi/exercise-assets/scripts/runbash.sh. Lataa tiedosto ja sijoita se oikeaan hakemistoon.</p> Teht\u00e4v\u00e4: Bash Hello World <p>Luo skripti <code>hello.sh</code>, joka tulostaa tekstin \"Hello World\". </p> <p>Huomaa, ett\u00e4 sijoita se oikeaan hakemistoon, kuten <code>~/Code/skriptiohjelmointi-2054/johnanderton/bash/scripts/hello.sh</code>. Voit ajaa tiedoston \u00e4sken lataamallasi apuri-skriptill\u00e4.</p> \ud83d\udda5\ufe0f Host<pre><code># Vaihda hakemistoon, miss\u00e4 on runbash.sh\ncd ~/Code/skriptiohjelmointi-2054/johnanderton/bash/\n\n# Aja\n./runbash.sh scripts/hello.sh\n</code></pre> \ud83d\udc33 stdout<pre><code>Hello World\n</code></pre> Teht\u00e4v\u00e4: Turboahdettu Bash Hello World <p>Luo skripti, joka tulostaa absoluuttisen polun ty\u00f6hakemistoon ja siihen hakemistoon, miss\u00e4 skripti sijaitsee. Skriptin runko on alla:</p> hello_turbo.sh<pre><code>#!/bin/bash\n\nsource /etc/os-release\ndistro_version=${VERSION:-\"Unknown distribution\"}\n\ncwd_path=''  # IMPLEMENT\nsrc_path=''  # IMPLEMENT\n\nprintf \"========= Turbo Hello World! =========\\n\"\nprintf \"%-30s %s\\n\" \"Current working directory:\" \"$cwd_path\"\nprintf \"%-30s %s\\n\" \"Script directory:\" \"$src_path\"\nprintf \"%-30s %s\\n\" \"Kernel name:\" \"$distro_version\"\n</code></pre> <p>Rivit, joiden per\u00e4ss\u00e4 on kommentti <code># IMPLEMENT</code>, vaativat sinulta toimia. Lis\u00e4\u00e4 n\u00e4ihin toiminnallisuus. Testaa yll\u00e4 olevan teht\u00e4v\u00e4n neuvoilla. Kutsu skripti\u00e4 <code>hello_turbo.sh</code> ja katso, ett\u00e4 se tulostaa oikeat tiedot.</p> <p>HUOM! Pelkk\u00e4 <code>src_path=$0</code> sattuu toimimaan, koska skripti ajetaan absoluuttisella polulla. T\u00e4m\u00e4n tulet kuitenkin huomaamaan v\u00e4\u00e4r\u00e4ksi vastaukseksi viimeist\u00e4\u00e4n seuraavaa teht\u00e4v\u00e4\u00e4 tehdess\u00e4. Selvit\u00e4, kuinka saat k\u00e4\u00e4nnetty\u00e4 relatiivisen polun absoluuttiseksi.</p> Apuja absolutisointiin <p>GNU:n <code>readlink</code>-komento auttaa t\u00e4ss\u00e4. Ota selv\u00e4\u00e4, mink\u00e4 flagin ja parametrin avulla saat haluamasi tuloksen. Tarvitset t\u00e4ss\u00e4 tiedonhakutaitoja:</p> <pre><code># Mit\u00e4 ? ja ???? tilalle tulee?\nsrc_path=$(readlink -? ????)\n</code></pre> Teht\u00e4v\u00e4: Interaktiivinen Bash <p>Harjoittele t\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4 interaktiivista Bashin k\u00e4ytt\u00f6\u00e4. T\u00e4m\u00e4 on tarpeellista, jos haluat luoda kontin sis\u00e4lle esimerkiksi testitiedostoja, tai haluat tarkkailla, mit\u00e4 ajettu skripti oikeastaan tekik\u00e4\u00e4n. Tarvitset t\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4 ylemp\u00e4n\u00e4 mainitun <code>runbash.sh</code>-skriptin. Huomaa, ett\u00e4 se l\u00f6ytyy <code>/app/scripts/</code>-hakemistosta kontin sis\u00e4ll\u00e4. T\u00e4m\u00e4 johtuu <code>runbash.sh</code>-skriptin rivist\u00e4: <code>--mount type=bind,source=\"$(pwd)/${SCRIPT_DIR}\",target=/app,readonly</code>.</p> <p>Jos muokkaat <code>hello_turbo.sh</code>-tiedostoa Host-koneella, sinun ei tarvitse poistua kontista ja k\u00e4ynnist\u00e4\u00e4 sit\u00e4 uudelleen, koska polku on bindattu kontin sis\u00e4\u00e4n. Tallenna tiedosto ja aja se uudelleen kontissa - tiedosto on p\u00e4ivittynyt! My\u00f6s alla komennoissa luotava tiedosto <code>/root/a/b/c/hello_turbo.sh</code>-p\u00e4ivittyy samalla kertaa, koska se on symbolinen linkki eli pointteri alkuper\u00e4iseen tiedostoon.</p> <p>K\u00e4ynnist\u00e4 istunto alla olevalla komennolla. Pois p\u00e4\u00e4set komennolla <code>exit</code> tai pikan\u00e4pp\u00e4imell\u00e4 Ctrl+D.</p> \ud83d\udda5\ufe0f Host<pre><code># Ilman parametri\u00e4 skripti ajaa kontin vakio CMD:n, joka on\n# haluamamme: /bin/bash\n./runbash.sh\n</code></pre> <p>Vaihe 1: Aja miss\u00e4 oletkin</p> \ud83d\udc33 Bash<pre><code>/app/scripts/hello_turbo.sh\n</code></pre> \ud83d\udc33 stdout<pre><code>========= Turbo Hello World! =========\nCurrent working directory:     /\nScript directory:              /app/scripts/hello_turbo.sh\nKernel name:                   24.04.1 LTS (Noble Numbat)\n</code></pre> <p>Huomaa, ett\u00e4 vakiona ty\u00f6hakemisto on <code>/</code> eli juurihakemisto.</p> <p>Vaihe 2: Aja toisaalla ja toisaalta</p> \ud83d\udc33 Bash<pre><code>mkdir -p /root/a/b/c\nln -s /app/hello_turbo.sh /root/a/b/c/hello_turbo.sh\ncd /root/a\n./b/c/hello_turbo.sh\n</code></pre> <p>Huomaa, ett\u00e4 <code>hello_turbo.sh</code>-skripti tulostaa nyt oikeat tiedot. Symbolinen linkki tosiaan sijaitsee hakemistossa <code>/root/a/b/c/</code>, eli <code>src_path</code>-muuttuja on m\u00e4\u00e4ritelty oikein. Samaten <code>cwd_path</code>-muuttuja on m\u00e4\u00e4ritelty oikein, koska kun ajoit skritin, olit hakemistossa <code>/root/a</code>.</p> \ud83d\udc33 stdout<pre><code>========= Turbo Hello World! =========\nCurrent working directory:     /root/a\nScript directory:              /root/a/b/c/hello_turbo.sh\nKernel name:                   24.04.1 LTS (Noble Numbat)\n</code></pre> Teht\u00e4v\u00e4: Bash vianetsint\u00e4 <p>Luo yll\u00e4 esitellyt kolme skripti\u00e4: <code>muuttuja_set_{none,u,ux}.sh</code>.</p> <ol> <li>Tarkastele, kuinka optiot vaikuttavat outputtiin.</li> <li>Kokeile my\u00f6s vaihtoehtoista tapaa. Aja <code>bash -ux muuttuja_set_none.sh</code>.</li> </ol> <p>Ajathan n\u00e4m\u00e4 kontissa aiempien teht\u00e4vien oppien avulla.</p>"},{"location":"bash/38_strontium/","title":"\ud83c\udf86 Strontium","text":""},{"location":"bash/38_strontium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"bash/38_strontium/#tarpeelliset-komennot","title":"Tarpeelliset komennot","text":"<p>T\u00e4m\u00e4n osion teht\u00e4viss\u00e4 avuksi ovat ainakin seuraavat kohdat GNU-manuaalista:</p> <ul> <li>read</li> <li>while</li> <li>if</li> <li>RANDOM</li> </ul>"},{"location":"bash/38_strontium/#hakasulkeiden-maara","title":"Hakasulkeiden m\u00e4\u00e4r\u00e4","text":"<p>Huomaa, ett\u00e4 yksitt\u00e4iset hakasulkeet, eli <code>[ jotain ]</code>, ovat sama asia kuin komento <code>test</code>. Kyseinen komento on POSIX-yhteensopiva ja sit\u00e4 k\u00e4ytet\u00e4\u00e4n usein ehtolauseissa, jos haluat koodin toimivan kaikilla Unix-johdannaisilla k\u00e4ytt\u00f6j\u00e4rjestelmill\u00e4. Jos tied\u00e4t, ett\u00e4 koodia ajetaan nimenomaan Bash-shellill\u00e4, niin voit k\u00e4ytt\u00e4\u00e4 kaksoishakasulkeita, eli <code>[[ jotain ]]</code>. Kaksoishakasulkeet ovat extensio Bashille ja niiss\u00e4 on muutamia etuja, kuten parempi merkkijonon k\u00e4sittely ja parempi looginen operaattorien tuki.</p> compare_brackets.sh<pre><code>#!/bin/bash\n\nif [ 2 -gt 1 -a 1 -lt 2 -a 3 -eq 3 ]; then\n    echo \"[POSIX] 2&gt;1 ja 1&lt;2 ja 3 on yht\u00e4 suuri kuin 3\"\nfi\n\n# T\u00e4m\u00e4 on Bash-spesifi\nif [[ 2 -gt 1 &amp;&amp; 1 -lt 2 &amp;&amp; 3 -eq 3 ]]; then\n    echo \"[[BASH]] 2&gt;1 ja 1&lt;2 ja 3 on yht\u00e4 suuri kuin 3\"\nfi\n\n# Arithmetic Bash\nif (( 2 &gt; 1 &amp;&amp; 1 &lt; 2 &amp;&amp; 3 == 3 )); then\n    echo \"((BASH)) 2&gt;1 ja 1&lt;2 ja 3 on yht\u00e4 suuri kuin 3\"\nfi\n</code></pre> <p>Warning</p> <p>Huomaa, ett\u00e4 v\u00e4lily\u00f6nnit ovat t\u00e4rkeit\u00e4 Bash-skripteiss\u00e4 - my\u00f6s (haka)sulkeiden kanssa. Katso alta esimerkki toimivasta ja ei-toimivasta koodista.</p> bracket_space_problem.sh<pre><code>#!/bin/bash -e\n\nanswer=\"no\"\n\n# \u26d4\ufe0f Huonoa koodia; puuttuva v\u00e4lily\u00f6nti tekee ehdosta \n# ep\u00e4p\u00e4tev\u00e4n, ja one-linerin logiikka hajoaa vaarallisesti!\nif [ \"$answer\" != \"yes\"]; then exit 1; fi\necho \"Case 1: should not print\"\n\n# \u2705 Hyv\u00e4\u00e4 koodia; koodista otetaan exit ellei vastaus ole 'yes'\nif [ \"$answer\" != \"yes\" ]; then exit 1; fi\necho \"Case 2: should not print\"\n</code></pre> <p>Tulostuu:</p> \ud83d\udc33 stdout<pre><code>./thingy.sh: line 6: [: missing `]'\nCase 1: should not print\n</code></pre>"},{"location":"bash/38_strontium/#staattinen-analyysi","title":"Staattinen analyysi","text":"<p>Viime luvussa opimme debuggausta bash:n optioneilla. Nyt k\u00e4yt\u00e4mme lintteri\u00e4. Voit kokeilla sen online-versiota osoitteessa shellcheck.net. Teht\u00e4v\u00e4-osiossa sin\u00e4 otat sen k\u00e4ytt\u00f6\u00f6n skriptauksen ja Dockerin avulla.</p>"},{"location":"bash/38_strontium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Arvaa numero <p>Luo ohjelma, joka generoi luvun v\u00e4lilt\u00e4 1-1000 ja pyyt\u00e4\u00e4 k\u00e4ytt\u00e4j\u00e4\u00e4 arvaamaan sen. Ohjelma antaa vihjeen, onko arvattu luku suurempi vai pienempi kuin generoitu luku. Ohjelma lopettaa, kun k\u00e4ytt\u00e4j\u00e4 arvaa oikein.</p> arvaaluku.sh<pre><code>#!/bin/bash\n\nmax_number=1000\n\ndeclare -i correct=500 # IMPLEMENT! Generoi satunnainen\ndeclare -i guess=0\n\necho \"Arvaa luku v\u00e4lilt\u00e4 1-${max_number}.\"\necho \"Negatiivinen luku poistuu ohjelmasta.\"\n\n# IMPLEMENT! Logiikka k\u00e4ytt\u00e4en while-silmukkaa.\n</code></pre> <p>Kannattaa tutkia, mink\u00e4 arvon kokonaisluku <code>guess</code>saa, jos sy\u00f6te on jotain muuta kuin validi numero.</p> Teht\u00e4v\u00e4: Reminder <p>T\u00e4m\u00e4n teht\u00e4v\u00e4n idean pohjana toimii Dave Taylorin ja Brandon Perryn Wicked Cool Shell Scripts, 2nd Edition. Luo kaksi ohjelmaa, jotka toimivat yhdess\u00e4. Toinen luo, toinen n\u00e4ytt\u00e4\u00e4 muistiinpanoja.</p> <p>Jotta teht\u00e4v\u00e4 ei olisi pelkk\u00e4 copy-paste kirjan repositoriosta l\u00f6ytyvist\u00e4 tiedostoista, niin luodaan ohjelma, joka on merkitt\u00e4v\u00e4sti yksinkertaisempi. Voit poistaa koodista monimutkaisimmat osiot (<code>cat</code> ja <code>grep</code>). Typist\u00e4 koodin toiminnallisuus siten, ett\u00e4 vain v\u00e4ltt\u00e4m\u00e4t\u00f6n on j\u00e4ljell\u00e4. Jos haluat lis\u00e4haastetta, \u00e4l\u00e4 katso kirjan esimerkkikoodia laisinkaan.</p> <ul> <li><code>install_remind.sh</code><ul> <li>Lis\u00e4\u00e4 <code>remember</code> ja <code>remind</code>-komennot <code>/usr/local/bin</code>-hakemistoon symbolisina linkkein\u00e4, jotta niit\u00e4 voi kutsua ilman tiedostopolkua nimill\u00e4 <code>remember</code> ja <code>remind</code>.</li> </ul> </li> <li><code>remember</code><ul> <li>Kysyy <code>read</code>-komennon avulla k\u00e4ytt\u00e4j\u00e4lt\u00e4 muistutuksia, jotka tallennetaan <code>$HOME/.reminder</code>-tiedostoon. Tyhj\u00e4 sy\u00f6te lopettaa muistutusten kirjoittamisen.</li> <li>Formaatti: <code>[timestamp] Muistutus</code></li> </ul> </li> <li><code>reminder</code><ul> <li>Tulostaa koko muistutustiedoston sis\u00e4ll\u00f6n.</li> </ul> </li> </ul> Vihje PATH:iin <p><code>ln -s /app/jotain.sh /usr/local/bin/jotain</code></p> <p>Alla esimerkki asennuksen ja kummankin sovelluksen toiminnasta. Komentojen v\u00e4liin on lis\u00e4tty tyhj\u00e4 rivi lukemisen helpottamiseksi:</p> \ud83d\udc33 Bash<pre><code>root$ /app/remind_install.sh\n[INFO] Added remember and remind commands to /usr/local/bin\n\nroot$ remember\nEnter note (quit with empty note)\n&gt;&gt;&gt; Buy egg\n&gt;&gt;&gt; Buy ham\n&gt;&gt;&gt; Buy sausage\n&gt;&gt;&gt; ???\n&gt;&gt;&gt; Profit\n&gt;&gt;&gt;\n\nroot$ remind\nYour reminders are as follows:\n[1738583804]    Buy egg\n[1738583806]    Buy ham\n[1738583809]    Buy sausage\n[1738583814]    ???\n[1738583815]    Profit\n</code></pre> <p>Komennoissa on UNIX-timetamp eli sekunteja 1970-luvun alusta, joten olisi t\u00e4ysin mahdollista toteuttaa ohjelma, joka poistaa yli n viikkoa vanhat muistutukset. Vaihtoehtoisesti olisi teht\u00e4viss\u00e4 menu, joka kysyy, mitk\u00e4 muistutukset halutaan poistaa. Emme kuitenkaan toteuta n\u00e4it\u00e4 t\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4.</p> Teht\u00e4v\u00e4: Staattinen analyysi (Shellcheck) <p>Latasit aiemmassa luvussa <code>readbash.sh</code>-skriptin. Ota siit\u00e4 ja ShellCheck GitHub repositoriosta mallia. Luo skripti, jolla voit ajaa ShellCheckin valitsemillesi skripteille. </p> <p>Ehdot:</p> <ul> <li>Hy\u00f6dynt\u00e4\u00e4 <code>shellcheck:stable</code>-imagea Docker Hubista.</li> <li>On ajettavissa alla n\u00e4kyv\u00e4n docsin examplejen mukaisesti</li> </ul> <p>Nice-to-have:</p> <ul> <li>V\u00e4rit tulostuvat oikein, jotta output on helpompi lukea.</li> </ul> static.sh<pre><code>#!/bin/bash\n#: Title        : static.sh\n#: Date         : 202x-xx-xx\n#: Author       : xxx xxxxx\n#: Version      : 1.0\n#: Description  : Static code analysis for bash scripts.\n#\n#: Options      : [script_name(s)]\n#\n#: === Examples ====\n#:   static.sh scripts/*.sh\n#:   static.sh scripts/foo.sh\n#:   static.sh scripts/foo.sh scripts/bar.sh\n#:   static.sh scripts/{foo,bar}.sh\n\n# ... IMPLEMENT !\n</code></pre> Teht\u00e4v\u00e4: Korjaa skriptit <p>Aja yll\u00e4 luomasi skripti kaikkia <code>scripts/</code>-hakemiston skriptej\u00e4 vasten \u2013 eli testaa kaikki kurssin skriptit. Korjaa virheet, joita ShellCheck l\u00f6yt\u00e4\u00e4. L\u00f6yd\u00e4t virheist\u00e4 lis\u00e4tietoa ShellCheck Wikist\u00e4. Korvaa urlissa viimeinen <code>SCxxxx</code>-osa oikealla virhekoodilla.</p> <p>Ota samalla tavoitteeksi ajaa jatkossa kaikki skriptisi ShellCheckin l\u00e4pi ennen kuin p\u00e4\u00e4st\u00e4t niit\u00e4 k\u00e4sist\u00e4si. Huomaa, ett\u00e4 ShellCheck ei palauta mit\u00e4\u00e4n, jos skripti on virheet\u00f6n.</p>"},{"location":"bash/96_curium/","title":"\ud83d\udc69\u200d\ud83d\udd2c Curium","text":""},{"location":"bash/96_curium/#listat","title":"Listat","text":"<p>Ennen kuin siirrymme viimeiseen Einsteinium-osuuteen, harjoitellaan viel\u00e4 hieman listoja. Listat ovat t\u00e4rkeit\u00e4, koska niit\u00e4 k\u00e4ytet\u00e4\u00e4n usein silmukoiden yhteydess\u00e4. Listoja k\u00e4sitell\u00e4\u00e4n usein my\u00f6s argumentteina skripteille. On kovin tyypillist\u00e4, ett\u00e4 sinun pit\u00e4\u00e4 tavalla tai toisella parsia kaikkia argumentteja, eli: <code>$@</code>, jonka osatekij\u00f6it\u00e4 ovat <code>$1</code>, <code>$2</code>, <code>$3</code>, jne. Alla olevissa teht\u00e4viss\u00e4 t\u00e4h\u00e4n tutustutaan parin rautakoodatun, helpomman esimerkin kautta.</p>"},{"location":"bash/96_curium/#funktiot","title":"Funktiot","text":"<p>Listojen lis\u00e4ksi on syyt\u00e4 opetella funktioiden k\u00e4ytt\u00f6\u00e4. Funktiot auttavat pit\u00e4m\u00e4\u00e4n koodisi modulaarisena ja helposti luettavana. Funktiot ovat my\u00f6s hyv\u00e4 tapa v\u00e4ltt\u00e4\u00e4 toistoa koodissasi. </p> <p>Funktiot ovat my\u00f6s hyv\u00e4 tapa testata koodiasi, koska voit testata yksitt\u00e4isi\u00e4 funktioita erikseen. T\u00e4m\u00e4 on erityisen hy\u00f6dyllist\u00e4, jos koodisi on monimutkaista ja sis\u00e4lt\u00e4\u00e4 paljon reunaehtoja.</p>"},{"location":"bash/96_curium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Pilkulla erottelu <p>Luo skripti, joka tulostaa luvut 1-10 pilkulla eroteltuna. Skriptin pit\u00e4\u00e4 alkaa n\u00e4in:</p> pilkkuerotellut.sh<pre><code>#!/bin/bash\nnumbers=({1..10})\n</code></pre> <p>Lopputuloksena tulisi tulostaa:</p> \ud83d\udc33 stdout<pre><code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n</code></pre> Vihje 1 <p>Sijoita v\u00e4liaikaiseen muuttujaan jotain, mit\u00e4 seuraava tulostaa:</p> <pre><code>printf \", %s\" \"${numbers[@]}\"\n</code></pre> Vihje 2 <p>Huomasit kaiketi, ett\u00e4 yll\u00e4 neuvottu komento j\u00e4tt\u00e4\u00e4 komennon alkuun pilkun ja v\u00e4lily\u00f6nnin. Voit j\u00e4tt\u00e4\u00e4 n\u00e4m\u00e4 kaksi ensimm\u00e4ist\u00e4 merkki\u00e4, eli <code>,</code> tulostamatta k\u00e4ytt\u00e4m\u00e4ll\u00e4 <code>${parameter:offset}</code> parameter expansion syntaksi: </p> <pre><code>echo ${muuttuja:2}\n</code></pre> Teht\u00e4v\u00e4: Pizzat\u00e4ytteet <p>Luo skripti, jonka alussa m\u00e4\u00e4ritell\u00e4\u00e4n rautakoodatut muuttujat alla olevan <code>pizza.sh</code>-esimerkin mukaisesti. Huomaa, ett\u00e4 nime\u00e4, ik\u00e4\u00e4 ja suosikkit\u00e4ytteit\u00e4 pit\u00e4\u00e4 voida muuttaa. T\u00e4ytteit\u00e4 on aina v\u00e4hint\u00e4\u00e4n kaksi.</p> pizza.sh<pre><code>#!/bin/bash\nname='Black Knight'\nage=42\nfav_toppings=(\"egg\" \"sausage\" \"spam\")\n</code></pre> <p>Tavoite on tulostaa seuraava lause:</p> \ud83d\udc33 stdout<pre><code>Black Knight is 42 years old and likes pizza with egg, sausage, and spam.\n</code></pre> <p>Huomaa, ett\u00e4 t\u00e4ytteiden tulee olla pilkkueroteltuja kahden viimeisen v\u00e4liss\u00e4 kuuluu olla sana \"and\". Toiseksi viimeisen t\u00e4ytteen per\u00e4ss\u00e4 saa joko olla pilkku tai ei - p\u00e4\u00e4t\u00e4 itse (eli ns. Oxford comma \ud83e\uddd0).</p> Vihje <p>Kenties helpoin ratkaisu ymm\u00e4rt\u00e4\u00e4 on string concatenation-tyyli, jossa ainekset ynn\u00e4t\u00e4\u00e4n merkkijonoon. K\u00e4yt\u00e4 <code>for</code>-silmukkaa, jossa rakennat pilkkuerotellun t\u00e4ytelistan yksi t\u00e4yte kerrallaan. Huomaa, ett\u00e4 teht\u00e4v\u00e4n voi ratkaista my\u00f6s aivan toisin.</p> <pre><code>for ingredient in \"${fav_toppings[@]}\"; do\n    # IMPLEMENT if-else string concatenation here.\n\n    n_toppings=$((n_toppings-1))\ndone\n\necho \"${name} is ${age} years old and likes pizza with ${comma_topping}.\"\n</code></pre> Teht\u00e4v\u00e4: P\u00e4iv\u00e4m\u00e4\u00e4r\u00e4n analysointi <p>Luo skripti, joka analysoi skriptin ajop\u00e4iv\u00e4st\u00e4 seuraavat asiat:</p> <ul> <li>Pariton vai parillinen p\u00e4iv\u00e4m\u00e4\u00e4r\u00e4</li> <li>Onko vuosi karkausvuosi</li> <li>Kuinka monta p\u00e4iv\u00e4\u00e4 on jouluaattoon?</li> </ul> <p>K\u00e4yt\u00e4 apuna funktioita, jotta koodi pysyy modulaarisena ja helposti luettavana. V\u00e4lt\u00e4 pitk\u00e4\u00e4 \"wall of text\" -tyylist\u00e4 koodia. Koodin runko voi my\u00f6t\u00e4ill\u00e4 esimerkiksi alla olevaa rakennetta:</p> dateinfo.sh<pre><code>#!/bin/bash\n\n# Define functions here\nis_odd() {\n    local today\n    local number\n\n    today=$1\n    number= # IMPLEMENT\n\n    # IMPLEMENT\n    echo Something\n}\n\n# ... more functions here ...\n\n# Wrapper function\nmain() {\n    # Declare\n    local default_date\n    local today\n\n    # Assign\n    default_date=$(date +%Y-%m-%d)\n    today=${1:-$default_date}\n\n    # Call\n    is_odd \"$today\"\n    # is_leap_year \"$today\"\n    # n_days_till_xmas \"$today\"\n}\n\nmain \"$@\"\n</code></pre> <p>Skripti\u00e4 voi jatkossa kutsua argumentilla tai ilman. Alla kaksi esimerkki\u00e4, joista alempi on ajettu 7. helmikuuta 2025.</p> \ud83d\udda5\ufe0f Bash<pre><code>./runbash.sh sripts/dateinfo.sh 1600-02-29\n</code></pre> \ud83d\udc33 stdout<pre><code>[INFO] T\u00e4n\u00e4\u00e4n on 1600-02-29\n[INFO] P\u00e4iv\u00e4m\u00e4\u00e4r\u00e4 on pariton. \ud83e\udd84\n[INFO] Karkausvuosi! 366 p\u00e4iv\u00e4\u00e4! \ud83c\udf89\n[INFO] P\u00e4ivi\u00e4 jouluaattoon: 299 \ud83c\udf85\n</code></pre> \ud83d\udda5\ufe0f Bash<pre><code>./runbash.sh sripts/dateinfo.sh\n</code></pre> \ud83d\udc33 stdout<pre><code>[INFO] T\u00e4n\u00e4\u00e4n on 2000-02-29\n[INFO] P\u00e4iv\u00e4m\u00e4\u00e4r\u00e4 on pariton. \ud83e\udd84\n[INFO] Karkausvuosi! 366 p\u00e4iv\u00e4\u00e4! \ud83c\udf89\n[INFO] P\u00e4ivi\u00e4 jouluaattoon: 299 \ud83c\udf85\n</code></pre> Lis\u00e4haastetta? <p>Validoi p\u00e4iv\u00e4m\u00e4\u00e4r\u00e4, jonka k\u00e4ytt\u00e4j\u00e4 antaa argumenttina. Voit esimerkiksi tarkistaa, ett\u00e4 se noudattaa muotoa <code>yyyy-mm-dd</code>, ja ett\u00e4 <code>date</code>-bin\u00e4\u00e4ri saa sen parsittua (eli ei palauta error return codea).</p> Viel\u00e4 lis\u00e4\u00e4 lis\u00e4haastetta? <p>Voit halutessasi toteuttaa itsellesi lis\u00e4haasteena testej\u00e4. T\u00e4m\u00e4 vaatisi, ett\u00e4 esimerkiksi virheherkk\u00e4 karkausvuoden logiikka on testattuna kohtalaisen systemaattisesti. T\u00e4m\u00e4 vaatii, ett\u00e4 funktio <code>is_leap_year</code> palauttaa exit coden: <code>1</code> jos vuosi on karkausvuosi ja <code>0</code> jos ei. T\u00e4m\u00e4 exit code voidaan sitten tarkistaa testiss\u00e4.</p> <pre><code>test_leap_year() {\n    is_leap_year \"$1\" 0\n    local result=$?\n    local expected=$2\n    if (( result != expected )); then echo \"Failed $1 (${result})\"; exit 1; fi\n}\n</code></pre> <p>T\u00e4m\u00e4n j\u00e4lkeen voit ajaa testej\u00e4 esimerkiksi ennen main-funktion kutsua:</p> <pre><code>test_leap_year 1600-01-01 1\ntest_leap_year 1700-01-01 0\ntest_leap_year 2023-01-01 0\ntest_leap_year 2024-01-01 1\ntest_leap_year 2025-12-31 0\ntest_leap_year 2026-01-01 0\ntest_leap_year 2027-01-01 0\ntest_leap_year 2028-01-01 1\nmain \"$@\"\n</code></pre> <p>T\u00e4m\u00e4 on kuitenkin lis\u00e4haaste. Jos t\u00e4m\u00e4 tuntuu mahdottomalta, keskity muuhun.</p> Teht\u00e4v\u00e4: Swap <p>Luoda ohjelma, joka auttaa sinua tilanteessa, jossa olet vahingossa kirjoittanut kahden eri tiedoston sis\u00e4ll\u00f6t ristiin. Toisin sanoen haluat vaihtaa tiedostot p\u00e4ikseen. Miten t\u00e4m\u00e4 onnistuu?</p> <p>K\u00e4ytt\u00f6 (kontin sis\u00e4ll\u00e4):</p> \ud83d\udc33 Bash<pre><code>echo \"I think I'm A\" &gt; b.txt   # note wrong content\necho \"I think I'm B\" &gt; a.txt\n/app/scripts/swap.sh tiedosto1.txt tiedosto2.txt\ncat a.txt\n</code></pre> \ud83d\udc33 stdout<pre><code>I think I'm A\n</code></pre> Vihje <p>K\u00e4yt\u00e4 komentoa <code>mktemp</code> avuksesi. Tutustu sen ohjeisiin: Ubuntu Manuals: mktemp.</p>"},{"location":"bash/99_einsteinium/","title":"\ud83d\udc68\u200d\ud83d\udd2c Einsteinium","text":""},{"location":"bash/99_einsteinium/#docker-vs-multipass","title":"Docker vs. Multipass","text":"<p>Docker sopii moneen, mutta jos tarve on hallita esim. systemd-palveluita, luoda k\u00e4ytt\u00e4ji\u00e4, tai sitoa eri prosesseja yhteen tavalla tai toisella, niin virtuaalikone on parempi ratkaisu. Kehitysymp\u00e4rist\u00f6mme on Ubuntu, joten Canonicalin oma Multipass on oiva valinta. Qemu mahdollistaa rautatason virtualisoinnin (KVM), joten suorituskyky on parempi kuin tyypin 2 hypervisoreilla (VirtualBox, VMware).</p> <p>Muut OS:t?</p> <p>Multipass toimii my\u00f6s macOS ja Windows -k\u00e4ytt\u00f6j\u00e4rjestelmiss\u00e4, mutta n\u00e4iden k\u00e4ytt\u00f6\u00e4 ei erikseen neuvoja t\u00e4ll\u00e4 kurssilla. Windowsissa default <code>local.driver</code> on hyperv, joten jos k\u00e4yt\u00e4t Windowsia, niin Windows Pro on suositeltu. Muutoin joudut tyytym\u00e4\u00e4n VirtualBoxiin driverin\u00e4.</p>"},{"location":"bash/99_einsteinium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Argumenttien parsiminen <p>Luo skripti <code>arguments.sh</code>, joka vastaa seuraavaan k\u00e4ytt\u00f6kuvaukseen: <code>Usage: arguments.sh [-n instance_name] [-c cloud-init-file] [FILE]..</code></p> <p>Skriptin tulee tulostaa argumentit. Alla muutama esimerkki skriptin ajamisesta:</p> \ud83d\udda5\ufe0f Bash<pre><code>./runbash.sh scripts/arguments.sh -n 'Name Here' -c config/notexists.yaml abc def efg\n</code></pre> \ud83d\udc33 stdout<pre><code>Image name: Name Here\nCloud Init file: config/notexists.yaml\nPositional arguments one by one: \n  abc\n  def\n  efg\n</code></pre> \ud83d\udda5\ufe0f Bash<pre><code>./runbash.sh scripts/arguments.sh\n</code></pre> \ud83d\udc33 stdout<pre><code>Image name:\nCloud Init file:\nPositional arguments one by one: \n</code></pre> \ud83d\udda5\ufe0f Bash<pre><code>./runbash.sh scripts/arguments.sh arg1 arg2 arg3 arg4\n</code></pre> \ud83d\udc33 stdout<pre><code>Image name:\nCloud Init file:\nPositional arguments one by one:\n  arg1\n  arg2\n  arg3\n  arg4\n</code></pre> Vihje <p>K\u00e4yt\u00e4 <code>getopts</code>-rakennetta. Ohjeet esim. Greg's Wiki. Mallia voit ottaa my\u00f6s <code>runbash.sh</code>-skriptist\u00e4.</p> Teht\u00e4v\u00e4: Multipass-harjoituskentt\u00e4 <p>Luo skripti, joka alustaa sinulle Multipassin avulla harjoituskent\u00e4n. Tarvitset t\u00e4ss\u00e4 ylemm\u00e4n teht\u00e4v\u00e4n apuja: sinun pit\u00e4\u00e4 voida antaa sille argumentteja.</p> <p>Aloita teht\u00e4v\u00e4 asentamalla Canonical Multipass jos se ei ole jo asennettu. On suositeltavaa tehd\u00e4 t\u00e4m\u00e4 teht\u00e4v\u00e4, kuten muutkin kurssin teht\u00e4v\u00e4t, Ubuntu Linuxissa. Voit omalla vastuulla kuitenkin asentaa Multipassin my\u00f6s macOS- ja Windows-k\u00e4ytt\u00f6j\u00e4rjestelmiin. J\u00e4lkimm\u00e4isess\u00e4 tapauksessa suosittelen Windows Pro -versiota, jotta saat Hyper-V:n k\u00e4ytt\u00f6\u00f6n.</p> <p>Warning</p> <p>Huomaa, ett\u00e4 n\u00e4it\u00e4 komentoja ei ajeta kontissa. N\u00e4m\u00e4 ajetaan sinun host-koneella.</p> <p>Komennon pit\u00e4isi toimia esimerkiksi n\u00e4in:</p> \ud83d\udda5\ufe0f Bash<pre><code>./runmulti.sh -n 'harjoituskentta' scripts/hello.sh\n</code></pre> <p>Komennossa kest\u00e4\u00e4 ymp\u00e4rist\u00f6st\u00e4si riippuen noin minuutti: se lataa ~500 megatavun Ubuntu cloud imagen koneellesi ja k\u00e4ynnist\u00e4\u00e4 sen pohjalta virtuaalikoneen. T\u00e4m\u00e4n j\u00e4lkeen voit ottaa yhteytt\u00e4 koneeseen komennolla <code>multipass shell harjoituskentta</code>. Skripti <code>hello.sh</code> tulisi l\u00f6yty\u00e4 ubuntu-k\u00e4ytt\u00e4j\u00e4n kotihakemistosta. Voit ajaa sen komennolla <code>bash hello.sh</code> tai <code>./hello.sh</code> - aivan kuten olet aiemmin oppinut. P\u00e4\u00e4set ulos koneesta komennolla <code>exit</code> tai Ctrl+D pikan\u00e4pp\u00e4imell\u00e4.</p> Vihje <p>Skriptin pit\u00e4isi ajaisi seuraavanlaisia komentoja:</p> <pre><code># Komento 1: komentoon tulee ujuttaa muuttuja $INSTANCE_NAME\nmultipass launch lts --cpus 1 --disk 5G --memory 1G --name ${INSTANCE_NAME}\n\n# Komento 2[..]: yksi per [FILE]..\nmultipass transfer ${file} ${INSTANCE_NAME}:/home/ubuntu\n</code></pre> <p>Note</p> <p>Kun haluat tuhota komeet, aja <code>multipass delete &lt;koneennimi&gt;</code> tai <code>multipass delete --all</code>. Kone j\u00e4\u00e4 viel\u00e4 kummittelemaan, etk\u00e4 voi luoda uutta samannimist\u00e4 ennen kuin ajat <code>multipass purge</code>.</p> Teht\u00e4v\u00e4: Einstein-level Oppimisp\u00e4iv\u00e4kirja <p>Automatisoi oppimisp\u00e4iv\u00e4kirjan alustaminen Cookiecutter-templaatista ja tarvittavien riippuvuuksien asentaminen.  Luo skripti, joka ottaa argumenttinaan konfiguraatiotiedoston, josta se lukee muuttujat itselleen. N\u00e4m\u00e4 muuttuja-arvot m\u00e4\u00e4r\u00e4\u00e4v\u00e4t, mink\u00e4 kurssin oppimisp\u00e4iv\u00e4kirjan skripti alustaa, mihin lokaatioon se tulee ja kuka on kirjoittaja. N\u00e4iden vaiheiden pit\u00e4isi olla sinulle tuttuja muilta minun kursseiltani.</p> <p>Konfiguraatiotiedosto on YAML. Sen rakenne neuvotaan Cookiecutter: User Config-sivulla. Meid\u00e4n tapauksessa se on esimerkiksi:</p> skriptiohjelmointi-2054.yaml<pre><code>default_context:\n    course_name: \"Skriptiohjelmointi 2054\"\n    author: \"John Anderton\"\n    containing_folder: \"/home/john/Code/skriptiohjelmointi-2054/johnanderton\"\n    __week_nro: \"42\"\n</code></pre> Mit\u00e4 YAML:iin? <p>Default context -arvot eiv\u00e4t ole sattumanvaraisia muuttujanimi\u00e4. K\u00e4ytetty Cookiecutter-templaatti, tai tarkemmin sen gh:sourander/kamk-coociecutters/oppimispaivakirja/cookiecutter.json-tiedosto m\u00e4\u00e4rittelee ne. Tutustu tiedostoon ja sen logiikkaan. Huomaa, ett\u00e4 tiedosto ei ole raakakoodattu JSON vaan Jinja2-pohjainen templaatti - tavallaan skriptausta sekin!</p> <p>Kun olet sit\u00e4 mielt\u00e4, ett\u00e4 skripti on kenties valmis ajettavaksi, aja:</p> \ud83d\udda5\ufe0f Bash<pre><code># Luo\n./runmulti.sh -n oppimispaivakirja scripts/luo-paivakirja.sh config/skriptiohjelmointi-2054.yaml\n\n# Yhdist\u00e4 \u2623\ufe0f-koneeseen\nmultipass shell oppimispaivakirja\n</code></pre> <p>T\u00e4m\u00e4n j\u00e4lkeen olet valmis kokeilemaan skriptin ajamista virtuaalikoneen sis\u00e4ll\u00e4.</p> \u2623\ufe0f Bash<pre><code># Aja ubuntun kotikansiossa\n./luo-paivakirja.sh skriptiohjelmointi-2025.yaml\n</code></pre> <p>Ideaalitilanne on, ett\u00e4 skripti ei kysy k\u00e4ytt\u00e4j\u00e4n sy\u00f6tett\u00e4. Sen sijaan skripti lukee konfiguraatiotiedoston ja suorittaa tarvittavat toimenpiteet, ja lopuksi tulostaa, miss\u00e4 oppimisp\u00e4iv\u00e4kirja sijaitsee. Tarkka tulosteen muotoilu ei ole t\u00e4rke\u00e4, mutta se voi olla n\u00e4tti ja hymi\u00f6it\u00e4 hy\u00f6dynt\u00e4v\u00e4. Esimerkiksi:</p> \u2623\ufe0f stdout<pre><code>[INFO] Learning diary created! \ud83e\udd73\n[INFO] You will find it in: /home/john/Code/skriptiohjelmointi-2054/johnanderton/\n</code></pre> Vihje <p>Tulet ajamaan t\u00e4m\u00e4n sortin komentoa jossain vaiheessa:</p> <pre><code>uv tool run cookiecutter \\\n    --lue cookiecutterin \\\n    --dokumentaatiosta \\\n    --mita \\\n    --argumentteja \\\n    --tarvitset \\\n    gh:sourander/kamk-cookiecutters\n</code></pre> Teht\u00e4v\u00e4: Oppimisp\u00e4iv\u00e4kirjan jatkot <p>T\u00e4m\u00e4 teht\u00e4v\u00e4 on edellisen viimeisen viimeistely\u00e4 ja varmistelua. Kun olet saanut yll\u00e4 olevan teht\u00e4v\u00e4n suoritettua, niin haluat varmasti my\u00f6s n\u00e4hd\u00e4 oppimisp\u00e4iv\u00e4kirjan selaimessa? T\u00e4m\u00e4 onnistuu seuraavilla komennoilla:</p> \u2623\ufe0f Bash<pre><code># Varmista ett\u00e4 uv l\u00f6ytyy PATH:sta\nsource .bashrc \n\n# Mene oikeaan hakemistoon\ncd Code/skriptiohjelmointi-2025/yourname/docs\n\n# Aja mkdocs lis\u00e4osineen uv:lla\nuv tool run \\\n  --with mkdocs-material \\\n  --with mkdocs-awesome-nav \\\n  mkdocs serve --dev-addr 0.0.0.0:8000\n</code></pre> <p>T\u00e4m\u00e4n j\u00e4lkeen selvit\u00e4 virtuaalikoneen IP-osoite ja yhdist\u00e4 siihen. Virtuaaliosoitteen n\u00e4et ajamalla komennon <code>multipass info &lt;koneennimi&gt;</code>. T\u00e4m\u00e4n j\u00e4lkeen voit avata selaimen ja kirjoittaa osoiteriville <code>http://&lt;virtuaalikoneen-ip&gt;:8000</code>.</p> <p>Nyt olet virallisesti varmistanut skriptin toiminnallisuuden, joten se olisi valmiina k\u00e4ytett\u00e4v\u00e4ksi my\u00f6s muuallakin kuin virtuaalikoneessa. Success! \ud83c\udf89</p>"},{"location":"bash/aloita/","title":"Bash 101","text":""},{"location":"bash/aloita/#perusteet","title":"Perusteet","text":""},{"location":"bash/aloita/#missa-ajetaan","title":"Miss\u00e4 ajetaan?","text":""},{"location":"bash/aloita/#docker","title":"Docker","text":"<p>Jos teet skriptej\u00e4, jotka poistavat tiedostoja, asentavat ohjelmia, lis\u00e4\u00e4v\u00e4t k\u00e4ytt\u00e4vi\u00e4 tai tekev\u00e4t jotakin muuta vaikeasti peruutettavaa, on suositeltavaa ajaa Bashi\u00e4 Docker-kontissa. Docker mahdollistaa nopeasti alustettavan \"clean slate\"-ymp\u00e4rist\u00f6n, jossa voit automatisoida esimerkiksi ohjelmistojen asennuksia sotkematta host-konetta. Docker ei ole kokonainen Linux-ymp\u00e4rist\u00f6 vaan yksitt\u00e4inen prosessi, joka on eristetty muusta j\u00e4rjestelm\u00e4st\u00e4. </p>"},{"location":"bash/aloita/#multipass","title":"Multipass","text":"<p>Joissakin teht\u00e4viss\u00e4 voi olla tarve yht\u00e4 prosessia suuremmalle Linux-ymp\u00e4rist\u00f6lle. T\u00e4ll\u00f6in k\u00e4yt\u00e4mme Multipassin luomia koneita, jotka ovat virtuaalikoneiksi varsin kevyit\u00e4: ne voidaan luoda ja tuhota nopeasti, ja niit\u00e4 voidaan kustomoida deklaratiivisilla cloud-init -tiedostoilla.</p>"},{"location":"bash/aloita/#lokaalisti","title":"Lokaalisti","text":"<p>Jos sinulla on Linux tai macOS, sinulla on p\u00e4\u00e4sy Bash-tulkkiin suoraan. Se sopii Hello World -kokeiluihin, mutta tee suuremmat harjoitukset silti Docker/Multipass-ty\u00f6kalujen avulla.</p> <p>\u24c2\ufe0f Windows</p> <p>Jos olet Windows-k\u00e4ytt\u00e4j\u00e4, eth\u00e4n yrit\u00e4 k\u00e4ytt\u00e4\u00e4 Git Bash -emulaattoria. K\u00e4yt\u00e4 suosiolla Docker-kontteja.</p> <p>\ud83c\udf4e macOS</p> <p>Huomaa, ett\u00e4 macOS ei ole linux vaan darwin-ytimen p\u00e4\u00e4lle rakentuva Unix-like OS. Monet <code>/usr/bin/</code>-hakemiston bin\u00e4\u00e4rit odottavat hyvin eri fl\u00e4gej\u00e4 kuin GNU-bin\u00e4\u00e4rit. Suosi Docker-kontteja my\u00f6s macOS-koneella t\u00e4m\u00e4n kurssin yhteydess\u00e4.</p>"},{"location":"bash/aloita/#mika-bash-on","title":"Mik\u00e4 Bash on?","text":"<p>Bash eli Bourne Again SHell on tyypillisesti Linux-distribuutioissa k\u00e4ytetty shell eli suomeksi komentotulkki. Bash on alkuper\u00e4isen Unixin Bourne Shell (eli <code>sh</code>) -tulkin jalanj\u00e4ljiss\u00e4 kulkeva GNU Projectin vastine, kuten sen leikkis\u00e4st\u00e4 nimest\u00e4 voi p\u00e4\u00e4tell\u00e4. Bash on p\u00e4\u00e4osin yhteensopiva Shellin kanssa.</p> <p>Bash itsess\u00e4\u00e4n tukee ohjelmointikielist\u00e4 tuttuja rakenteita, kuten muuttujia, ehtolauseita, silmukoita ja funktioita, joten se on enemm\u00e4n kuin pelkk\u00e4 komentotulkki. T\u00e4st\u00e4 huolimatta se ei kuitenkaan ole t\u00e4ysiverinen ohjelmointikieli, joten monimutkaisemmat ohjelmat kannattaa kirjoittaa jollakin muulla kielell\u00e4, kuten Pythonilla tai C:ll\u00e4 - tai voit kutsua n\u00e4it\u00e4 Bash-skriptist\u00e4 k\u00e4sin. Bash on liima useiden ohjelmien v\u00e4lill\u00e4, ja monimutkaisimpiin operaatioihin kutsutaankin yleens\u00e4 bin\u00e4\u00e4reit\u00e4 kuten <code>awk</code>, <code>sed</code>, <code>grep</code>, <code>bc</code> ja niin edelleen.</p> <p>\"Bash, as a shell, is actually a 'glue' language. It helps programs to cooperate with each other, and benefits from it.\" - Wikibooks: Bash Shell Scripting</p> <p>Jos k\u00e4yt\u00e4t jotekin muuta tulkkia, kuten <code>Z Shell</code> eli <code>zsh</code>, voit silti kirjoittaa ja ajaa skriptit silti Bash-kielell\u00e4. T\u00e4m\u00e4n mahdollista ns. shebang, joka on ensimm\u00e4inen rivi skriptiss\u00e4. Tutustutaan siihen seuraavaksi. Jos kirjoitat POSIX-yhteensopivaa koodia, voit k\u00e4ytt\u00e4\u00e4 <code>#!/bin/sh</code> -shebangia, joka on viel\u00e4 enemm\u00e4n portable.</p>"},{"location":"bash/aloita/#ensimmainen-kontti","title":"Ensimm\u00e4inen kontti","text":"<p>Alla olevan <code>docker container run</code> komennon voi ajaa l\u00e4hes miss\u00e4 tahansa komentotulkissa ja miss\u00e4 tahansa k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4ss\u00e4. Komento kutsuu k\u00e4ynnist\u00e4\u00e4 interaktiivisessa (<code>-it</code> eli <code>--interactive</code> ja <code>--tty</code>) kontissa ajettavan <code>ubuntu:24.04</code> imagen, ja kontti tuhotaan (<code>--rm</code>) kun poistut siit\u00e4. Alla esimerkki ajetuista komennoista.</p> \ud83d\udda5\ufe0f Bash | Git Bash | PowerShell | CMD<pre><code>docker container run --rm -it ubuntu:24.04\n</code></pre> \ud83d\udc33 Bash<pre><code>$ bash --version\nGNU bash, version 5.2.21(1)-release (aarch64-unknown-linux-gnu)\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\n\nThis is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n</code></pre>"},{"location":"bash/aloita/#skripti","title":"Skripti","text":"<p>Huomaa, ett\u00e4 komentotulkki itsess\u00e4\u00e4n on jo \"ohjelmointikieli\", joten voit kirjoittaa ja ajaa skriptej\u00e4 suoraan komentotulkissa. Skriptaus ei siis k\u00e4yt\u00e4nn\u00f6ss\u00e4 ole mit\u00e4\u00e4n muuta kuin sit\u00e4, ett\u00e4 siirr\u00e4t komentoja tiedostoon ja ajat sen sijaan, ett\u00e4 kirjoittaisit ne itse. Toki kylki\u00e4isen\u00e4 tulee muita hy\u00f6tyj\u00e4, kuten mahdollisuus kommentoida koodia, jakaa sit\u00e4 muille, laittaa se versionhallintaan, tarkistaa k\u00e4ytt\u00e4j\u00e4n sy\u00f6tt\u00e4mi\u00e4 parametreja ja t\u00e4ten v\u00e4hent\u00e4\u00e4 inhimillisi\u00e4 virheit\u00e4, ja niin edelleen.</p> <p></p> <p>Kuva 1: Yksinkertainen for-loop Bashissa ilman erillist\u00e4 skriptitiedostoa. Komento on ajettu kontissa. Yksinkertainen prompt johtuu aiemmin ajetusta komennosta: <code>PS1='\\u$ '</code>.</p>"},{"location":"bash/aloita/#sisalto","title":"Sis\u00e4lt\u00f6","text":"<p>Skripti on tiedosto, joka sis\u00e4lt\u00e4\u00e4 yhden tai useamman komennon. Kyseess\u00e4 on siis yh\u00e4 sama komentotulkki, mutta interaktiivisen promptin sijaan komentotulkki lukee komentoja tiedostosta. Tiedosto voi olla mik\u00e4 tahansa, mutta yleens\u00e4 se on <code>.sh</code>-p\u00e4\u00e4tteinen.</p> <p>hello-bad-example.sh<pre><code>echo \"Hello World\"\n</code></pre> K\u00e4yt\u00e4nn\u00f6ss\u00e4 tiedostoon kannattaa kuitenkin lis\u00e4t\u00e4 ensimm\u00e4iseksi riviksi shebang. Shebang on merkkijono, joka kertoo, mill\u00e4 ohjelmalla tiedosto ajetaan. Esimerkiksi:</p> hello.sh<pre><code>#!/bin/bash\necho \"Hello World\"\n</code></pre>"},{"location":"bash/aloita/#ajaminen","title":"Ajaminen","text":"<p>Tiedoston voi ajaa monella tavalla. Yksi tapa on tehd\u00e4 tiedostosta executable ja sitten ajaa se antamalla relatiivinen tai absoluuttinen polku tiedostoon tai siirt\u00e4m\u00e4ll\u00e4 se hakemistoon, joka on m\u00e4\u00e4ritelty PATH-muuttujassa. T\u00e4m\u00e4n pit\u00e4isi olla kertausta Linux Perusteet -kurssilta.</p> Bash<pre><code># Tee ajettavaksi\nchmod +x hello.sh\n\n# Relatiivinen polku\n./hello.sh\n\n# Absoluuttinen polku\n/home/user/hello.sh\n\n# Bashin argumenttina\nbash hello.sh\n\n# Polku, joka on PATH-muuttujassa\nmv hello.sh /usr/local/bin/\nhello.sh\n</code></pre> <p>Tiedosto on tavallinen tekstitiedosto, joten sen voi luoda mill\u00e4 tahansa tekstink\u00e4sittelyohjelmalla. Suosittelen kuitenkin luomaan tiedostot joko Linuxista k\u00e4sin, tai sitten host-tietokoneessa k\u00e4ytt\u00e4en esimerkiksi Visual Studio Codea, joka osaa k\u00e4sitell\u00e4 Unix-tyylisi\u00e4 rivinvaihtoja ja UTF-8 -koodausta.</p> <p></p> <p>Kuva 2: Printf-komennon avulla voi kirjoittaa tiedoston siten, ett\u00e4 <code>\\r</code> korvautuu <code>CR</code>-merkill\u00e4 (<code>hex: 0x0D</code>) ja <code>\\n</code> korvautuu <code>LF</code>-merkill\u00e4 (<code>hex: 0x0A</code>). Kuvassa on luotu kaksi tiedostoa, <code>win.sh</code> ja <code>posix.sh</code>, joista ensimm\u00e4isess\u00e4 rivinvaihtona on CR+LF ja j\u00e4lkimm\u00e4isess\u00e4 LF. Huomaa, ett\u00e4 vaikka <code>win.sh</code>-tiedosto on tehty ajettavaksi, komento <code>./win.sh</code> valittaa, ett\u00e4 tiedostoa ei l\u00f6ydy.</p> <p></p> <p>Kuva 3: <code>cat</code>-komennolla voidaan tulostaa tiedoston sis\u00e4lt\u00f6. Optio <code>-A</code>, eli <code>--show-all</code>, tulostaa my\u00f6s non-printing merkit, kuten <code>CR</code> eli <code>^M</code> ja <code>LF</code> eli <code>$</code>. Yhdess\u00e4 n\u00e4ist\u00e4 tulee <code>^M$</code>, joka on Windows-tiedostoj\u00e4rjestelm\u00e4n rivinvaihto. Heh, seh\u00e4n muistuttaa sanaa Micro$soft!</p>"},{"location":"bash/aloita/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Bash informaatiohaku</p> <p>Muodosta itsellesi katalogi tarpeellisista l\u00e4hteist\u00e4. Huomaa, ett\u00e4 Bashin kohdalla l\u00e4hteen tuoreus ei ole kovin kriittist\u00e4. Alla pari suositusta, mist\u00e4 aloittaa etsint\u00e4:</p> <ol> <li>GNU Bash manual, jonka voit joko ladata PDF-formaatissa tai selata HTML-versiona.</li> <li>DevHints.io: Bash. Cheat sheet, joka sis\u00e4lt\u00e4\u00e4 l\u00e4hes kaiken, mik\u00e4 Bashist\u00e4 pit\u00e4\u00e4 tiet\u00e4\u00e4, tiiviss\u00e4 paketissa.</li> <li>BashGuide - Greg's Wiki. Wiki, josta kenties parasta on FAQ-osio, josta l\u00f6ytyy vastaus useisiin kinkkisiin pulmiin, kuten tiedostojen ja joukkojen (engl. array) k\u00e4sittelyyn.</li> <li>Bash by gh:EbookFoundation/free-programming-books. Parikymment\u00e4 Bash-tutoriaalia tai -kirjaa, joista voit valita mieleisesi. Yll\u00e4 oleva BashGuide l\u00f6ytyy t\u00e4\u00e4lt\u00e4 PDF-muodossa - tosin FAQ pit\u00e4\u00e4 lukea silti online.</li> </ol> <p>My\u00f6s KAMK Finnasta eli korkeakoulumme kirjastosta l\u00f6ytyy \"Bash scripting\"-hakusanoilla kirjoja. Kenties Cookbook-tyylisist\u00e4 kirjoista l\u00f6ytyy puolivalmis ratkaisu, joka on helppo muokata omaan k\u00e4ytt\u00f6\u00f6n?</p> <p>Jos olet valmis sijoittamaan opiskeluusi rahaa, my\u00f6s seuraavat l\u00e4hteet voivat olla varteenotettavia:</p> <ul> <li>\ud83d\udcb0 Humble Bundle. Sivustolla on ajoittain tarjolla kirjoja, jotka k\u00e4sittelev\u00e4t Bash-skriptauksen perusteita. Tarjonta vaihtelee jatkuvasti, joten on tuurista kiinni, l\u00f6ytyyk\u00f6 sielt\u00e4 nyt mit\u00e4\u00e4n hy\u00f6dyllist\u00e4. Kirjapaketit maksavat yleens\u00e4 halvimmillaan noin 1-20 euroa.</li> <li>\ud83d\udcb0 O'Reilly. Kirjastoon kuuluu useiden eri julkaisijoiden kirjoja: O'Reilly, No Starch Press, Manning Publications, Packt, Apress ja monet muut. Luettavissa kuukausimaksulla.</li> </ul>"},{"location":"bash/lukeminen/","title":"Lukeminen","text":""},{"location":"bash/lukeminen/#mista-on-kyse","title":"Mist\u00e4 on kyse?","text":"<p>Aloitetaan jo olemassa olevien skriptien lukemisesta. On kovin tyypillist\u00e4, ett\u00e4 ohjelmiston asennuksen tai k\u00e4ytt\u00f6\u00f6noton yhteydess\u00e4 sinua neuvotaan ajamaan online-hostattu skripti. Tyypillisesti vaihe n\u00e4ytt\u00e4\u00e4 t\u00e4lt\u00e4:</p> Bash<pre><code>curl -sSLf https://example.com/install.sh | bash\n</code></pre> <p>Tip</p> <p>Esimerkiss\u00e4 olevan komennon <code>curl</code> parametrit ovat:</p> <ul> <li><code>-s</code> tai <code>--silent</code>: \u00c4l\u00e4 n\u00e4yt\u00e4 lataustietoja.</li> <li><code>-S</code> tai <code>--show-error</code>: N\u00e4yt\u00e4 virheilmoitukset.</li> <li><code>-L</code> tai <code>--location</code>: Seuraa mahdollisia uudelleenohjauksia.</li> <li><code>-f</code> tai <code>--fail</code>: Lopeta, jos lataus ep\u00e4onnistuu.</li> </ul> <p>Koska netti on pullollaan skriptej\u00e4, joita sinua neuvotaan ajamaan eri tutoriaaleissa ja asennusohjeissa, on hyv\u00e4 osata lukea niit\u00e4. Jos osaat lukea muiden skriptej\u00e4, kynnys kirjoittaa omia madaltuu. Samalla huomaat, ett\u00e4 jopa ammattilaisten laatimat skriptit koostuvat kohtalaisen pienest\u00e4 m\u00e4\u00e4r\u00e4st\u00e4 peruspalikoita.</p>"},{"location":"bash/lukeminen/#esimerkkeja","title":"Esimerkkej\u00e4","text":""},{"location":"bash/lukeminen/#docker","title":"\ud83d\udc33 Docker","text":"<p>Dockerin asennusvaiheeseen kuuluu kasa komentoja, jotka voi automatisoida skriptill\u00e4. Lue lis\u00e4\u00e4 Install Docker Engine on Ubuntu: Install using the convenience script</p> <p>Itse skripti l\u00f6ytyy osoitteesta: get.docker.com/</p>"},{"location":"bash/lukeminen/#homebrew","title":"\ud83c\udf7a Homebrew","text":"<p>Homebrew-paketinhallinta on macOS-k\u00e4ytt\u00e4jille tuttu \"apt:n korvike\", mutta sen voi asentaa my\u00f6s Linuxille. Ohjeistus on heti etusivulla: brew.sh.</p> <p>Itse skripti l\u00f6ytyy osoitteesta: raw.githubusercontent.com/Homebrew/install/HEAD/install.sh</p>"},{"location":"bash/lukeminen/#uv","title":"\ud83d\udc0d Uv","text":"<p>Uv on Pythonin verrattain tuore paketinhallintaty\u00f6kalu, jota k\u00e4ytet\u00e4\u00e4n my\u00f6s t\u00e4ll\u00e4 kurssilla. Sen asennus hoidetaan niin Linux/macOS kuin Windows ymp\u00e4rist\u00f6ss\u00e4 skriptin avulla. Tutustu Installing uv-ohjeeseen.</p> <p>Itse skripti l\u00f6ytyy osoitteesta: astral.sh/uv/install.sh</p>"},{"location":"bash/lukeminen/#rust","title":"\ud83e\udd80 Rust","text":"<p>Rust on tuoreehko, melko paljon p\u00f6hin\u00e4\u00e4 aiheuttava ohjelmointikieli. Sill\u00e4 koodatut sovellukset, kuten yll\u00e4 mainittu uv, muistavat yleens\u00e4 kertoa olevansa blazingly fast. Kieli soveltuu sulautettuihin j\u00e4rjestelmiin ja suorituskyky\u00e4 vaativiin sovelluksiin, aivan kuten C/C++, joten emme suinkaan k\u00e4yt\u00e4 sit\u00e4 t\u00e4ll\u00e4 kurssilla - mutta Rustin asennus onnistuu skriptill\u00e4, ja t\u00e4h\u00e4n me tutustumme. Tutustu Install Rust-ohjeeseen.</p> <p>Itse skripti l\u00f6ytyy osoitteesta: sh.rustup.rs</p>"},{"location":"bash/lukeminen/#volta","title":"\ud83d\udce6 Volta","text":"<p>Volta on Node.js:n versioiden hallintaan tarkoitettu ty\u00f6kalu, joka on jossain m\u00e4\u00e4rin vastaava kuin yll\u00e4 mainittu <code>uv</code>, mutta Pythonin sijasta kielen\u00e4 on JavaScript/Node.js. Tutustu Getting Started-ohjeeseen.</p> <p>Itse skripti l\u00f6ytyy osoitteesta: get.volta.sh</p>"},{"location":"bash/lukeminen/#kokoelmat","title":"Kokoelmat","text":"<p>Lis\u00e4ksi voit tutustua my\u00f6s communityn koostamiin kokoelmiin, joista l\u00f6ytyy yleens\u00e4 hieman lyhyempi\u00e4 snippettej\u00e4. Hyvi\u00e4 ovat ainakin:</p> <ul> <li>gh:djeada/Bash-Scripts</li> <li>gh:awesome-lists/awesome-bash</li> </ul>"},{"location":"bash/lukeminen/#esimerkki-docker-skriptin-parsiminen","title":"Esimerkki: Docker-skriptin parsiminen","text":"<p>T\u00e4m\u00e4 toimii apuna my\u00f6hemp\u00e4\u00e4 teht\u00e4v\u00e4\u00e4 varten. Alla on get.docker.com-skripti avattuna siten, ett\u00e4 siit\u00e4 l\u00f6ytyv\u00e4t uniikit komennot tai syntaksin muodot on listattu auki.</p> <p></p> <p>Kuva 1: Skripti ja muistiinpanot auki VS Codessa. Kun parsit skripti\u00e4, t\u00e4m\u00e4 on yksi potentiaalinen ty\u00f6tapa. Tuhoa vasemmalta rivej\u00e4 sit\u00e4 mukaan kun olet k\u00e4ynyt, ja kirjoita uusia l\u00f6yd\u00f6ksi\u00e4 oikealla olevaan memo-tiedostoon. Lopuksi muotoile muistiinpanot julkaisukuntoon.</p>"},{"location":"bash/lukeminen/#bash-yleiset","title":"Bash-yleiset","text":"Syntaksi Mit\u00e4 se tekee <code>#!/bin/sh</code> M\u00e4\u00e4ritt\u00e4\u00e4, ett\u00e4 skripti ajetaan ko. polun ohjelmalla. <sup>1</sup> <code>set -e</code> Lopeta skripti v\u00e4litt\u00f6m\u00e4sti, jos komento ep\u00e4onnistuu. <sup>2</sup> <code># Lorem ipsum</code> Kommentti. Ei vaikuta skriptin suoritukseen. <code>set +x</code> tai <code>-x</code> Laita debuggaustila p\u00e4\u00e4lle tai pois p\u00e4\u00e4lt\u00e4. <sup>3</sup> <code>exit 1</code> tai <code>0</code> Lopeta skripti ja palauta virhekoodi. <sup>4</sup>"},{"location":"bash/lukeminen/#muuttujat","title":"Muuttujat","text":"Syntaksi Mit\u00e4 se tekee <code>FOO=bar</code> M\u00e4\u00e4ritt\u00e4\u00e4 muuttujan <code>FOO</code> arvolla <code>bar</code>. <code>${VERSION#v}</code> Poistaa muuttujan <code>VERSION</code> arvosta etuliitteen <code>v</code>. <sup>5</sup> <code>DRY_RUN=${DRY_RUN:-}</code> Varmistaa, ett\u00e4 muuttuja <code>DRY_RUN</code> ei ole unset. <code>$(uname -r)</code> Asettaa muuttujaan komennon tulosteen. Esim. <code>TODAY=$(date +%Y-%m-%d)</code>. <sup>6</sup>"},{"location":"bash/lukeminen/#ehtorakenteet","title":"Ehtorakenteet","text":"Syntaksi Mit\u00e4 se tekee <code>if [ ... ]; then ... fi</code> Suorittaa lohkon, jos ehto on tosi. <sup>7</sup> <code>case \"$muuttuja\" in ... esac</code> Valitsee yhden monista vaihtoehdoista. Pitk\u00e4n if elsen korvaaja. <code>[ ehto ]</code> POSIX-yhteensopiva ehto. <code>[ -z \"$CHANNEL\" ]</code> Tarkistaa, ett\u00e4 muuttuja on tyhj\u00e4. <sup>8</sup> <code>[ -n \"$cli_pkg_version\" ]</code> Tarkistaa, ett\u00e4 muuttuja ei ole tyhj\u00e4. <sup>8</sup>"},{"location":"bash/lukeminen/#silmukat","title":"Silmukat","text":"Syntaksi Mit\u00e4 se tekee <code>while [ ... ]; do ... done</code> Suorittaa lohkon niin kauan kuin ehto on tosi. <sup>9</sup>"},{"location":"bash/lukeminen/#funktiot","title":"Funktiot","text":"Syntaksi Mit\u00e4 se tekee <code>command_exists() { ... }</code> M\u00e4\u00e4ritt\u00e4\u00e4 funktion nimelt\u00e4\u00e4n command exists. <code>command_exists</code> Ajaa funktion command_exists."},{"location":"bash/lukeminen/#tulostus","title":"Tulostus","text":"Syntaksi Mit\u00e4 se tekee <code>echo \"Illegal option $1\"</code> Tulostaa merkkijonon terminaaliin. <sup>10</sup> <code>printf \"\\033[91;1mDEPRECATION WARNING\\033[0m\\n\"</code> Tulostaa muotoillun merkkijonon terminaaliin. <sup>11</sup>"},{"location":"bash/lukeminen/#vaikeammat-tapaukset","title":"Vaikeammat tapaukset","text":""},{"location":"bash/lukeminen/#cat-heredoc","title":"cat (heredoc)","text":"<ul> <li> <p>Milt\u00e4 n\u00e4ytt\u00e4\u00e4:</p> <pre><code>cat &gt;&amp;2 &lt;&lt;-'EOF'\n    Warning: the \"docker\" command...\n\n    ... monta rivi\u00e4 teksti\u00e4 ...\n\n    You may press Ctrl+C now to abort this script.\nEOF\n</code></pre> </li> <li> <p>Mit\u00e4 se tekee: Tulostaa monirivisen tekstin terminaaliin. <code>&gt;&amp;2</code> ohjaa tulosteen virhevirtaan.</p> </li> </ul>"},{"location":"bash/lukeminen/#shift","title":"Shift","text":"<ul> <li>Milt\u00e4 n\u00e4ytt\u00e4\u00e4: <code>shift</code></li> <li>Mit\u00e4 se tekee: Siirt\u00e4\u00e4 positionaalisia argumentteja vasemmalle. Esim. jos skripti saa argumentteja, niin ensimm\u00e4inen argumentti poistetaan ja muut siirtyv\u00e4t vasemmalle. Katso alta Positionaaliset argumentit, jossa t\u00e4lle annetaan hieman kontekstia.</li> </ul>"},{"location":"bash/lukeminen/#ternary-operaattori","title":"Ternary operaattori","text":"<ul> <li>Milt\u00e4 n\u00e4ytt\u00e4\u00e4: <code>$(( ehto ? jos_totta : jos_ep\u00e4totta ))</code></li> <li>Mit\u00e4 se tekee: Palauttaa joko <code>jos_totta</code> tai <code>jos_ep\u00e4totta</code> riippuen ehdosta. Katso alta Positionaaliset argumentit, jossa t\u00e4lle annetaan hieman kontekstia.</li> </ul>"},{"location":"bash/lukeminen/#positionaaliset-argumentit","title":"Positionaaliset argumentit","text":"<ul> <li>Milt\u00e4 n\u00e4ytt\u00e4\u00e4: <code>$#</code></li> <li>Mit\u00e4 se tekee: Palauttaa positionaalisten argumenttien m\u00e4\u00e4r\u00e4n.</li> <li>Miksi se on k\u00e4yt\u00f6ss\u00e4: Se parsii skriptille annetut argumentit muuttujiin.</li> </ul> <p>T\u00e4m\u00e4 on muita skriptin tekij\u00f6it\u00e4 haastavampi kokonaisuus, ja on ok, jos se ei heti tunnu ilmiselv\u00e4lt\u00e4. Docker-asennusskriptiss\u00e4 sit\u00e4 k\u00e4ytet\u00e4\u00e4n parsimaan skriptille annetut argumentit muuttujiin, n\u00e4in:</p> <pre><code>while [ $# -gt 0 ]; do\n    case \"$1\" in\n        --foo)\n            FOO=\"$2\"\n            shift\n            ;;\n        --bar)\n            BAR=\"$2\"\n            shift\n            ;;\n        --toggle)\n            TOGGLE=1\n            ;;\n        *)\n            echo \"Illegal option $1\"\n            exit 1\n            ;;\n    esac\n    shift $(( $# &gt; 0 ? 1 : 0 ))  # Siirr\u00e4 argumentteja vasemmalle, jos niit\u00e4 on j\u00e4ljell\u00e4\ndone\n</code></pre> <p>Kyseisen skriptin voisi ajaa:  Bash<pre><code># N\u00e4in\n./skripti.sh --foo arvo1 --bar arvo2 --toggle\n\n# Tai eri j\u00e4rjestyksess\u00e4\n./skripti --toggle -bar arvo2 --foo arvo1\n</code></pre></p> <p>J\u00e4rjestyksest\u00e4 riippumatta lopputulema on, ett\u00e4 <code>FOO=arvo1</code>, <code>BAR=arvo2</code> ja <code>TOGGLE=1</code>. * Lis\u00e4tietoa: Positional Parameters</p>"},{"location":"bash/lukeminen/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Parsi Bash-skripti</p> <p>Ota mallia yll\u00e4 olevasta Docker-skriptin parsimisesta, ja parsi jokin muu:</p> <ul> <li>uv</li> <li>Homebrew</li> <li>Rust</li> <li>...tai jokin l\u00f6yt\u00e4m\u00e4si, joka edustaa samaa vaikeustasoa.</li> </ul> <p>Kirjoita yl\u00f6s l\u00f6yt\u00e4m\u00e4si syntaksin palaset, jotka ovat uniikkeja. Voit tehd\u00e4 t\u00e4m\u00e4n esimerkiksi seuraavasti:</p> <ol> <li>Lataa tiedosto: <code>curl -sSLf https://example.com/install.sh &gt; to-inspect.sh</code></li> <li>Avaa Visual Studio Codessa: <code>code to-inspect.sh</code></li> <li>Aloita tiedoston ylh\u00e4\u00e4lt\u00e4 ja prosessoi se rivi rivilt\u00e4.</li> </ol> <p>Tee seuraavat toimenpiteet jokaiselle koodiriville:</p> <ul> <li>\u2705 Jos koodirivi sis\u00e4lt\u00e4\u00e4 entuudestaan vierasta syntaksia: dokumentoi se. \ud83d\udcc4</li> <li>\ud83d\udd01 Jos koodirivin syntaksi on jo esiintynyt aiemmin scriptiss\u00e4: unohda rivi. \ud83e\udef3</li> <li>T\u00e4m\u00e4n j\u00e4lkeen poista kyseinen koodirivi tiedostosta.</li> </ul> <p>Kun olet k\u00e4ynyt koko tiedoston l\u00e4pi, sinulla pit\u00e4isi olla dokumentoitu lista uniikeista syntaksin palasista. Muotoile t\u00e4m\u00e4 itsellesi sopivaksi listaksi. Lista voi olla kuten yll\u00e4 oleva, tai jos keksit paremman tavan muotoilla samat asiat, k\u00e4yt\u00e4 sit\u00e4.</p> <p>Ajans\u00e4\u00e4st\u00f6\u00e4 teko\u00e4lyll\u00e4! \ud83e\udd16</p> <p>T\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4 on suorastaan suositeltua k\u00e4ytt\u00e4\u00e4 teko\u00e4ly\u00e4 apuna selitt\u00e4m\u00e4\u00e4n, mit\u00e4 kyseiset Bash-kielen entuudestaan tuntemattomat koodirimpsut tekev\u00e4t. Jos muotoilet kysymyksen oikein, kielimalli tarjoaa sinulle jopa linkit Bashin dokumentaatioon. </p> <p>HUOM! Tarkista vastaus, linkki ja linkin sis\u00e4lt\u00f6! Vastuu vastauksen oikeellisuudesta on sinulla!</p>"},{"location":"bash/lukeminen/#lahteet","title":"L\u00e4hteet","text":"<ol> <li> <p>Wikipedia. Shebang (Unix). https://en.wikipedia.org/wiki/Shebang_(Unix)\u00a0\u21a9</p> </li> <li> <p>GNU. The Set Builtin. https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html\u00a0\u21a9</p> </li> <li> <p>The Linux Documentation Project. Bash Guide for Beginners: 2.3. Debugging Bash scripts. https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html\u00a0\u21a9</p> </li> <li> <p>GNU. Bourne Shell Builtins. https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-exit\u00a0\u21a9</p> </li> <li> <p>GNU. Shell Parameter Expansion. https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\u00a0\u21a9</p> </li> <li> <p>GNU. Command Substitution. https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html\u00a0\u21a9</p> </li> <li> <p>GNU. Conditional Constructs. https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html\u00a0\u21a9</p> </li> <li> <p>GNU. Bash Conditional Expressions. https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html\u00a0\u21a9\u21a9</p> </li> <li> <p>GNU. Looping Constructs. https://www.gnu.org/software/bash/manual/html_node/Looping-Constructs.html\u00a0\u21a9</p> </li> <li> <p>GNU. Bash Builtins. https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-echo\u00a0\u21a9</p> </li> <li> <p>GNU. Bash Builtins. https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-printf\u00a0\u21a9</p> </li> </ol>"},{"location":"powershell/31_gallium/","title":"\ud83d\udca1 Gallium","text":""},{"location":"powershell/31_gallium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"powershell/31_gallium/#avainsanat","title":"Avainsanat","text":"<p>Aivan kuten Bashiss\u00e4, my\u00f6s PowerShelliss\u00e4 on varattuja sanoja, joita ei voi k\u00e4ytt\u00e4\u00e4 muuttujanimin\u00e4. T\u00e4ss\u00e4 on lista niist\u00e4:</p> <pre><code>The following are the reserved words in PowerShell:\n\n    assembly         exit            process\n    base             filter          public\n    begin            finally         return\n    break            for             sequence\n    catch            foreach         static\n    class            from (*)        switch\n    command          function        throw\n    configuration    hidden          trap\n    continue         if              try\n    data             in              type\n    define (*)       inlinescript    until\n    do               interface       using\n    dynamicparam     module          var (*)\n    else             namespace       while\n    elseif           parallel        workflow\n    end              param\n    enum             private\n\n    (*) These keywords are reserved for future use.\n</code></pre> <p>Mist\u00e4 n\u00e4m\u00e4 l\u00f6ytyiv\u00e4t?</p> <p>Olettaen ett\u00e4 Help on p\u00e4ivitetty, saat n\u00e4m\u00e4 auki komennolla:</p> <pre><code>help about_reserved_words\n</code></pre> <p>Komennon help l\u00f6ytyy online: about_Reserved_Words.</p>"},{"location":"powershell/31_gallium/#muuttujat","title":"Muuttujat","text":"<p>Koko totuus l\u00f6ytyy PowerShellin dokumentaatiosta (esim. about_Variables), mutta alla on pikaohje, jolla p\u00e4\u00e4set alkuun.</p>"},{"location":"powershell/31_gallium/#dynaaminen","title":"Dynaaminen","text":"<p>PowerShell on dynaamisesti tyypitetty kieli. T\u00e4m\u00e4 tarkoittaa, ett\u00e4 sama muuttuja voi vaihtua kokoluvusta merkkijonoksi ja niin edelleen, ja tyyppi p\u00e4\u00e4tell\u00e4\u00e4n automaattisesti. Merkin <code>=</code> vasemmalle puolella on muuttujanimi, oikealla on lauseke: <code>{variable} = {expression}</code>. Lauseke voi olla literaali, kuten <code>123</code>, tai sis\u00e4lt\u00e4\u00e4 operaattoreita, kuten <code>100 + 125 - 2</code>. Oli niin tai n\u00e4in, tulkki evaluioi <code>=</code>-merkin oikealla puolella olevan lausekkeen ja yritt\u00e4\u00e4 sijoittaa kyseisen arvon muuttujaan. Muuttuja saa t\u00e4m\u00e4n tyypin.</p> <pre><code>$x = 1            # Kokonaisluku (Int32)\n$x = 1 + 2 - 1    # ... kuten t\u00e4m\u00e4kin.\n$x = 3.12         # Liukuluku (Double)\n$x = \"abc\"        # Merkkijono (String)\n$x = @(\"abc\", 42) # Taulukko (Array)\n$x = @{a=1;b=2}   # Hajautustaulu (Hash table)\n</code></pre>"},{"location":"powershell/31_gallium/#vaihtaminen","title":"Vaihtaminen","text":"<p>Tyypin voi my\u00f6s itse m\u00e4\u00e4r\u00e4t\u00e4, jolloin se k\u00e4yt\u00e4nn\u00f6ss\u00e4 castataan kyseiseksi muuttujaksi. Huomaa, ett\u00e4 itse muuttuja on kuitenkin yh\u00e4 dynaaminen:</p> <pre><code>$x = [byte] 255      # Nyt se onkin tavu (Byte)\n$x = [int] 255       # ... eiku kokonaisluku (Int32)\n$x = [string] \"abc\"  # ... eiku merkkijono (String)\n\n# Huomaa my\u00f6s -as operaattori, joka palauttaa null jos castaus ei onnistu\n$y = $x -as [int] # ... null, koska \"abc\" ei taivu luvuksi\n</code></pre>"},{"location":"powershell/31_gallium/#tyypittaminen","title":"Tyypitt\u00e4minen","text":"<p>Voit my\u00f6s k\u00e4ske\u00e4 muuttujan k\u00e4ytt\u00e4m\u00e4\u00e4n tietty\u00e4 tyyppi\u00e4 nyt ja jatkossa. Erona yll\u00e4 olevaan on, ett\u00e4 <code>[type]$variable</code> on nyt vasemmalla puolella <code>=</code>-merkki\u00e4. Kaikki muuttujaan sijoitetut arvot pyrit\u00e4\u00e4n jatkossa muuttamaan t\u00e4h\u00e4n tyyppiin. Jos muutos ei onnistu, saat virheen.</p> <pre><code>[string]$x = 1      # Kerran merkkijono, aina merkkijono\n$x = \"Kissa\"        # ... ja yh\u00e4\n$x = 1              # ... ja yh\u00e4\n\n[int]$y = 12 # Nro\n$y = \"Koira\" # Virhe\n</code></pre> <p>Sokeasti automaattiseen tyypitykseen luottamisessa on omat riskins\u00e4. Mieti tarkkaan, mit\u00e4 seuraavassa tapahtuu:</p> \ud83d\udc33 PowerShell<pre><code>PS /&gt; 4 + \"2\"\n6\nPS /&gt; \"4\" + 2\n42\n</code></pre> <p>Skriptej\u00e4 kirjoittaessa tuskin tarvitset muita simple typej\u00e4 kuin yll\u00e4 listatut, mutta loput l\u00f6ytyv\u00e4t esimerkiksi C# Docs: Simple Types tai DevBlogs: Understanding Numbers in PowerShell. N\u00e4ilt\u00e4 sivuilta selvi\u00e4\u00e4 my\u00f6s numeraalisten tyyppien minimi- ja maksimiarvot, mik\u00e4li tarvitset kertausta asiasta.</p>"},{"location":"powershell/31_gallium/#selvittaminen","title":"Selvitt\u00e4minen","text":"<p>Jos olet ep\u00e4varma, mit\u00e4 jotakin cmdlet palauttaa, voit aina selvitt\u00e4\u00e4 sen n\u00e4in:</p> <pre><code># N\u00e4in saat my\u00f6s metodit ja parametrit esille\nGet-Location | Get-Member\n\n# N\u00e4in saat tyypin tiedot\n(Get-Location).GetType()      # itsess\u00e4\u00e4n System.RuntimeType\n(Get-Location).GetType().Name # itsess\u00e4\u00e4n String\n\n# Jos palautunut arvo on jo muuttujassa\n$var | Get-Member\n# tai\n$var.GetType()\n</code></pre>"},{"location":"powershell/31_gallium/#drives","title":"Drives","text":"<p>PowerShelliss\u00e4 on k\u00e4site \"drive\", joka on hieman erilainen kuin Linuxin tiedostoj\u00e4rjestelm\u00e4. Drive on k\u00e4yt\u00e4nn\u00f6ss\u00e4 jokin abstrakti k\u00e4site, joka voi olla esimerkiksi tiedostoj\u00e4rjestelm\u00e4, rekisteri tai jokin muu. Voit listata kaikki drivet komennolla <code>Get-PSDrive</code>. Voit vaihtaa drive\u00e4 komennolla <code>Set-Location</code>. Alla on komentoja, joissa aloitetaan /home/-hakemistosta, vaihdetaan env:-driveen ja listataan muuttujia, josta vaihdetaan Variable:-driveen, ja lopulta takaisin kotoisin tieodstoj\u00e4rjestelm\u00e4n puolelle.</p> <pre><code>cd /home         # Aloitetaan t\u00e4st\u00e4 (1)\n\ncd env:          # Vaihdetaan env:-driveen (2) \nGet-ChildItem    # Listataan muuttujat\ncd Variable:     # Vaihdetaan Variable:-driveen\ncd /             # Vaihdetaan takaisin kotihakemistoon\n</code></pre> <ol> <li>Huomaa, ett\u00e4 <code>cd</code> on Alias <code>Set-Location</code>-komentoon.</li> <li><code>env:</code>-drive sis\u00e4lt\u00e4\u00e4 ymp\u00e4rist\u00f6muuttujat. Huomaa, ett\u00e4 Bashiss\u00e4 n\u00e4m\u00e4 ovat ihan vain muuttujia samassa namespacessa (esim. <code>$PATH</code>). PowerShell abstrahoi n\u00e4m\u00e4 omaksi drivekseen.</li> </ol>"},{"location":"powershell/31_gallium/#vianetsinta","title":"Vianetsint\u00e4","text":"<p>Voimme k\u00e4ytt\u00e4\u00e4 Bash-kielest\u00e4 tuttuja tapoja, mutta luonnolliseti niille on eri syntaksi. Tuttu <code>set -u</code> korvautuu StrictMode-asetuksella ja <code>set -e</code> korvautuu ErrorActionPreference-asetuksella.</p>"},{"location":"powershell/31_gallium/#strictmode","title":"StrictMode","text":"<p>PowerShellin StrictMode on hieman monimutkaisempi kuin Bashin <code>set -u</code> (eli <code>nounset</code>). K\u00e4yt\u00e4nn\u00f6ss\u00e4 se kuitenkin esimerkiksi tarkistaa, ett\u00e4 et yrit\u00e4 kutsua k\u00e4ytt\u00e4m\u00e4tt\u00f6mi\u00e4 muuttujia. Voit kytke\u00e4 skriptiss\u00e4 sen p\u00e4\u00e4lle n\u00e4in:</p> <pre><code>Set-StrictMode -Version 2.0\n</code></pre> <p>Voit k\u00e4ytt\u00e4\u00e4 my\u00f6s muita versioita, 1.0 tai 3.0. Tutustu niiden dokumentaatioon: Set-StrictMode</p> Kuinka testata? <p>Luo ja aja tiedosto:</p> stictmode_yes.ps1<pre><code>Set-StrictMode -Version 2.0\n\nWrite-Host \"Starting script with strict mode enabled...\"\nWrite-Host \"We are referencing: $undefinedVar\"\nWrite-Host \"This will never print.\"\n</code></pre> <p>Luo my\u00f6s tiedosto <code>strictmode_no.ps1</code>, joka on muutoin identtinen, mutta muokkaa rivi\u00e4 yksi. Aseta se muotoon <code>Set-StrictMode -Off</code>. Aja molemmat tiedostot ja vertaa tuloksia.</p>"},{"location":"powershell/31_gallium/#erroractionpreference","title":"ErrorActionPreference","text":"<p>PowerShelliss\u00e4 on useita preference-muuttujia (ks. about_Preference_Variables), joilla voit s\u00e4\u00e4t\u00e4\u00e4, kuinka PowerShell k\u00e4ytt\u00e4ytyy. N\u00e4ist\u00e4 <code>set -e</code>:t\u00e4 eli <code>errexit</code>-toiminnallisuutta vastaa parhaiten <code>ErrorActionPreference</code>. Voit asettaa sen arvoksi <code>Stop</code>, jolloin skripti pys\u00e4htyy ensimm\u00e4iseen virheeseen. Vakioarvo on <code>Continue</code>, jolloin skripti jatkaa virheist\u00e4 huolimatta.</p> <pre><code>$ErrorActionPreference = \"Stop\"\n</code></pre> Kuinka testata? <p>Luo ja aja tiedosto:</p> preference_stop.ps1<pre><code>$ErrorActionPreference = \"Stop\"\n\nWrite-Host \"Starting script with ErrorActionPreference set to Stop...\"\nSet-Location -Path \"/thisdoesnotexist\" 2&gt;$null\nWrite-Host \"This will never print.\"\n</code></pre> <p>Luo my\u00f6s tiedosto <code>preference_continue.ps1</code>, joka on muutoin identtinen, mutta muokkaa rivi\u00e4 yksi. Aseta se muotoon <code>$ErrorActionPreference = \"Continue\"</code>. Aja molemmat tiedostot ja vertaa tuloksia.</p>"},{"location":"powershell/31_gallium/#write-something","title":"Write-Something","text":"<p>Yksi luonnollinen tapa debugata l\u00e4hes mit\u00e4 tahansa ohjelmointikielt\u00e4 on tulostaa muuttujien arvo kesken skriptin terminaaliin. T\u00e4m\u00e4 ei kuulosta rakettitieteelt\u00e4, mutta voi olla hyvin tehokas tapa debugata. Bashin kanssa ehk\u00e4 opit, ett\u00e4 <code>echo</code>-komentoja on \u00e4rsytt\u00e4v\u00e4 lis\u00e4t\u00e4 ja poistaa tarpeen mukaan. K\u00e4sin lis\u00e4tty <code>-v</code> option (verbose) auttaa, mutta vaatii argumenttien parsimista ja if-lausekkeita. Yksi tapa on ohjata komennot <code>stderr</code>-virtaan, mutta se on sin\u00e4ns\u00e4 v\u00e4\u00e4r\u00e4oppista, ett\u00e4 debug-viestit eiv\u00e4t varsinaisesti ole virheit\u00e4.</p> <p>PowerShell tarjoaa t\u00e4h\u00e4n ratkaisun tukemalla useita eri virtoja. N\u00e4it\u00e4 on useita. Alla olevassa esimerkiss\u00e4 k\u00e4yt\u00e4mme virtoja: Success (1), Verbose (4) ja Warning(3). Verbose ei tulostu ruudulle tavallisesti, mutta jos asetat preference variablen <code>VerbosePreference</code> arvoksi <code>Continue</code>, n\u00e4et my\u00f6s Debug-virran tulosteet. Lue lis\u00e4\u00e4 ohjeista about_Output_Streams sek\u00e4 about_Preference_Variables.</p> streams.ps1<pre><code>Write-Output \"I am typical output!\"\nWrite-Verbose \"Ah, you must have VerbosePreference set up properly! \ud83d\udd75\ufe0f\u200d\u2640\ufe0f\"\nWrite-Warning \"Warning! Warning! \ud83d\udea8\"\n</code></pre>"},{"location":"powershell/31_gallium/#debuggaus","title":"Debuggaus","text":"<p>PowerShelliss\u00e4 on my\u00f6s debugger, joka on k\u00e4ytett\u00e4viss\u00e4 Visual Studion Code -editorissa, olettaen, ett\u00e4 PowerShell Extension on asennettuna. Voit k\u00e4ynnist\u00e4\u00e4 sen painamalla <code>F5</code>. Se on erityisen hy\u00f6dyllinen breakpoint-toiminnon avulla esimerkiksi silmukoiden debuggaamisessa.</p> <p>Tutustumme t\u00e4m\u00e4n k\u00e4ytt\u00f6\u00f6n live-tunneilla.</p>"},{"location":"powershell/31_gallium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runpwsh.sh <p>Warning</p> <p>Huomaa, ett\u00e4 jos ty\u00f6skentelet siten, ett\u00e4 Windows on host-k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4si, voit kirjoittaa t\u00e4m\u00e4n saman skriptin PowerShell-kielell\u00e4. T\u00e4ss\u00e4 esimerkiss\u00e4 k\u00e4ytet\u00e4\u00e4n Bashia, koska kurssin oletuksena on Linux-host.</p> <p>PowerShell-osion ensimm\u00e4isess\u00e4 koodausteht\u00e4v\u00e4ss\u00e4 luot itsellesi devausymp\u00e4rist\u00f6n. Pohja t\u00e4t\u00e4 varten sinulla pit\u00e4isi olla jo olemassa Bash-osiosta. K\u00e4yt\u00e4nn\u00f6ss\u00e4 luot:</p> <ul> <li>Hakemistorakenteen teht\u00e4vien vastauksia varten</li> <li>Skriptin <code>runpwsh.sh</code>, joka joko:<ul> <li>Ajaa valitun skriptin kontissa</li> <li>K\u00e4ynnist\u00e4\u00e4 interaktiivisen shellin (pwsh)</li> </ul> </li> <li>Varmistat, ett\u00e4 kaikki on versionhallinnassa</li> </ul> <p>Jatka samassa repositoriossa ty\u00f6skentely\u00e4, miss\u00e4 olet jo aiemmin ty\u00f6skenenlly. Jatka rakennetta seuraavanalaisesti:</p> <pre><code>johnanderton\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 bash/\n\u251c\u2500\u2500 pwsh\n|   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 runpwsh.sh                  # Uusi tiedosto\n\u2502   \u251c\u2500\u2500 .help/powershell-help/      # Uusi hakemisto\n\u2502   \u2514\u2500\u2500 scripts/                    # Uusi hakemisto\n\u2514\u2500\u2500 python\n    \u2514\u2500\u2500 .gitkeep\n</code></pre> <p>Tiedoston <code>runpwsh.sh</code> luominen olisi hyv\u00e4\u00e4 kertausta Bash-osiosta, mutta jotta voimme keskitty\u00e4 PowerShell-osioon, voit ladata skriptin t\u00e4m\u00e4n repositorion polusta: gh:sourander/skriptiohjelmointi/exercise-assets/scripts/runpwsh.sh</p> Teht\u00e4v\u00e4: PowerShell Hello World <p>Luo skripti `hello.ps1, joka tulostaa terminaaliin tekstin \"Hello World!\".</p> <p>Sijoita se repositorion juuresta lukien relatiiviseen polkuun <code>pwsh/scripts/hello.ps1</code>. Aja skripti <code>./runpwsh.sh scripts/hello.ps1</code> ja varmista, ett\u00e4 se tulostaa \"Hello World!\". K\u00e4yt\u00e4 alla olevaa templaattia:</p> hello.ps1<pre><code># IMPLEMENT\n</code></pre> Teht\u00e4v\u00e4: PowerShell Turboahdettu Hello World hello_turbo.ps1<pre><code>&lt;#\n.SYNOPSIS\n    Prints \"Hello World!\" to the terminal.\n\n... ADD MORE HELP HERE ...\n#&gt;\n\n# IMPLEMENT\n</code></pre> <p>Jalosta yll\u00e4 n\u00e4kyv\u00e4\u00e4 skriptin alkua. Lopullisen skriptin tulisi:</p> <ul> <li>tulostaa absoluuttinen polku ty\u00f6hakemistoon</li> <li>tulostaa absoluuttinen polku skriptin sijaintiin</li> <li>tulostaa <code>PSEdition</code>-muuttujan arvon, mutta vain Debug-virtaan.</li> <li>tukea <code>Get-Help</code>-komentoa. Implementoi ainakin:<ul> <li>Synopsis (yll\u00e4)</li> <li>Description</li> <li>Example</li> </ul> </li> </ul> <p>Ohjelman tulosteen pit\u00e4isi k\u00e4ytt\u00e4yty\u00e4 seuraavanlaisesti:</p> \ud83d\udc33 PowerShell<pre><code>PS&gt; pwsh /app/scripts/hello_turbo.ps1\n========= Turbo Hello World! =========\nCurrent working directory:     /\nScript directory:              /app/scripts\n\nPS&gt; cd root\n\nPS&gt; $VerbosePreference = \"Continue\"\n\nPS&gt; pwsh /app/scripts/hello_turbo.ps1\n========= Turbo Hello World! =========\nCurrent working directory:     /root\nScript directory:              /app/scripts\nVERBOSE: Your PowerShell Edition:       Core\n</code></pre> <p>Varmista, ett\u00e4 osaat tulostaa komennon helpin termiinaaliin.</p> Vinkki: Get-Help <p>Huomaa <code>&lt;# ... #&gt;</code> tiedoston alussa. T\u00e4m\u00e4 on monirivinen kommentti.</p> Vinkki: src_path <p>Katso <code>about_automatic_variables</code> ja <code>$MyInvocation</code>.</p> Teht\u00e4v\u00e4: Save-Help <p>Teht\u00e4v\u00e4n\u00e4si on tallentaa <code>.help/powershell-help</code>-hakemistoon PowerShellin help-tiedostot.</p> <p>Jos ajoit PowerShell 101-osion komentoja, huomasit varmasti, ett\u00e4 <code>Update-Help</code>-komennon suorittamisessa kest\u00e4\u00e4 tovin. Se lataa Help-tiedostot verkosta. T\u00e4m\u00e4 pit\u00e4isi ajaa joka kerta uusiksi, kun avaamme PowerShellin konttiin. Nopeutetaan t\u00e4t\u00e4 siten, ett\u00e4 tallennetaan meille lokaali offline-kopio helpist\u00e4.</p> <p>Skriptiss\u00e4 <code>runpwsh.sh</code> on m\u00e4\u00e4ritetty bind mount read-write oikeuksin seuraavasti:</p> Host Container <code>.help/powershell-help</code> <code>/srv/powershell-help</code> <p>Nyt teht\u00e4v\u00e4n\u00e4si on tallentaa help-tiedostot kontin hakemistoon, joka on bind-mountattu sinun host-koneellesi. Alla on ajettavat komennot. Huomaa, ett\u00e4 komennot tulee ajaa kontissa, ei sinun host-koneellasi.</p> \ud83d\udc33 PowerShell<pre><code># Create the directory\nNew-Item -ItemType Directory -Path /.help/PowerShellHelp\n\n# Save the help files\nSave-Help -DestinationPath /.help/PowerShellHelp\n</code></pre> <p>Tip</p> <p>Vaihtoehtoinen tapa t\u00e4lle teht\u00e4v\u00e4lle olisi luoda oma Dockerfile ja rakentaa silt\u00e4 pohjalta image, joka sis\u00e4lt\u00e4\u00e4 p\u00e4ivitetyn helpin. V\u00e4ltell\u00e4\u00e4n kuitenkin <code>docker buildx</code>:\u00e4\u00e4 t\u00e4ll\u00e4 kursilla ja pysyt\u00e4\u00e4n skriptien ajamisen parissa.</p> Teht\u00e4v\u00e4: gitignore .help <p>Lis\u00e4\u00e4 lopuksi <code>.help/</code>-hakemisto sinun <code>.gitignore</code>-tiedostoon. Tiedostot ovat aina ladattavissa netist\u00e4, joten niiden s\u00e4il\u00f6minen pitk\u00e4aikaisesti omana kopiona Gitlabiin olisi turhuutta.</p> .gitignore<pre><code># ...ehk\u00e4 jotain muuta...\n\n# PowerShell help\n.help/\n</code></pre> Teht\u00e4v\u00e4: localhelp.ps1 <p>Jatkossa voit instansoida uuden kontin ja ottaa lokaalisti tallennetun helpin k\u00e4ytt\u00f6\u00f6n n\u00e4in:</p> \ud83d\udc33 PowerShell<pre><code>Update-Help -SourcePath /srv/powershell-help\n</code></pre> <p>Hakemisto on kuitenkin <code>.gitignore</code>-tiedostossa, joten voi olla, ett\u00e4 p\u00e4\u00e4dyt ajamaan t\u00e4t\u00e4 koodia uudella koneella. Siisp\u00e4 on tarpeellista luoda <code>localhelp.ps1</code>-skripti, joka:</p> <ul> <li>P\u00e4ivitt\u00e4\u00e4 helpin aina, jos <code>-Update</code>-parametri on annettu<ul> <li>Ajaa: <code>Save-Help -DestinationPath /var/powershell-help</code></li> </ul> </li> <li>Lataa helpin, p\u00e4ivittyi se tai ei.<ul> <li>Ajaa: <code>Update-Help -SourcePath /var/powershell-help</code></li> </ul> </li> </ul>"},{"location":"powershell/38_strontium/","title":"\ud83c\udf86 Strontium","text":""},{"location":"powershell/38_strontium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"powershell/38_strontium/#format-operator","title":"Format Operator","text":"<p>L\u00f6yd\u00e4t t\u00e4st\u00e4 lis\u00e4tietoa about_Operators-dokumentaatiosta. Alla lyhyt k\u00e4ytt\u00f6ohje:</p> <pre><code>$a = 42\n$b = \"The Universe\"\n$c = \"Life\"\n$d = \"Everything\"\n\n# Tulostaessa tarvit sulut\nWrite-Host (\"The answer to {0}, {1}, and {2} is: {3}\" -f $c, $b, $d, $a)\n</code></pre>"},{"location":"powershell/38_strontium/#mukavuus","title":"Mukavuus","text":""},{"location":"powershell/38_strontium/#visual-studio-coden-kaytto","title":"Visual Studio Coden k\u00e4ytt\u00f6","text":"<p>Warning</p> <p>Mukavuus-otsikon alla on oletus, ett\u00e4 sinulla on k\u00e4yt\u00f6ss\u00e4 Visual Studio Code, PowerShell Extension ja lokaalisti asennettu PowerShell.</p> <p>Bash-kieless\u00e4 on hyvin pieni m\u00e4\u00e4r\u00e4 sis\u00e4\u00e4nrakennettuja komentoja, joten kyseist\u00e4 kielt\u00e4 kirjoittaa melko kevyesti ilman code autocompletion ominaisuutta. PowerShellin kanssa t\u00e4t\u00e4 kannattaa opetella hy\u00f6dynt\u00e4m\u00e4\u00e4n. Voit lukea lis\u00e4\u00e4 VS Code: IntelliSense-dokumentaatiosta.</p> <p></p> <p>Kuva 1: Kun kirjoitat <code>Get-</code>, aukeaa valikko, josta voit valita haluamasi cmdletin. PowerShell Extensionin k\u00e4ytt\u00f6 nopeuttaa kirjoittamista ja v\u00e4hent\u00e4\u00e4 virheit\u00e4.</p> <p>Muita hy\u00f6dyllisi\u00e4 pikaneuvoja ovat:</p> <ul> <li>F8 : Aja maalattu osa komentoa VS Code Terminalissa (ei kontissa!)</li> <li>F1 : Avaa komentopaneeli.<ul> <li>Kirjoita hakukentt\u00e4\u00e4n <code>PowerShell</code> ja katso mit\u00e4 kaikkea l\u00f6yd\u00e4t.</li> </ul> </li> <li>Ctrl+, : Avaa asetukset. <ul> <li>Kirjoita hakukentt\u00e4\u00e4n <code>@ext:ms-vscode.powershell</code> ja saat esille kaikki PowerShell Extensionin asetukset. (\ud83c\udf4e Mac: Cmd+,:)</li> </ul> </li> </ul> <p>PowerShell Extensionin asetuksiin p\u00e4\u00e4set painamalla <code>Ctrl+,</code> ja kirjoittamalla hakukentt\u00e4\u00e4n <code>PowerShell</code>. T\u00e4\u00e4lt\u00e4 l\u00f6yd\u00e4t kaikki asetukset, joita voit muokata.</p>"},{"location":"powershell/38_strontium/#promptin-muokkaus","title":"Promptin muokkaus","text":"<p>Jos/kun k\u00e4yt\u00e4t lokaalia PowerShelli\u00e4 syntax highlightingin toimivuuden takaamiseksi tai ymp\u00e4rist\u00f6\u00e4 muokkaamattomien srkriptien ajamiseksi, olet varmasti huomannut, ett\u00e4 prompt on tyypillisesti melko pitk\u00e4. Se on esimerkiksi:</p> <pre><code>PS /home/john/Code/johnanderton/skriptiohjelmointi-2025/pwsh&gt;\n</code></pre> <p>Eik\u00f6 olisi mukavampaa, jos prompt olisi:</p> <pre><code>PS pwsh&gt;\n</code></pre> <p>Bashist\u00e4 sinulle pit\u00e4isi olla tuttua Start-up -tiedosto <code>.bashrc</code> ja ymp\u00e4rist\u00f6muuttuja <code>PS1</code>, joka s\u00e4\u00e4t\u00e4\u00e4 sinun promptiasi. PowerShelliss\u00e4 hitusen vastaava tiedosto on profiilitiedosto, jonka sijainti sinulle selvi\u00e4\u00e4 komennolla:</p> \ud83d\udda5\ufe0f PowerShell<pre><code>PS&gt; $profile\n\n# tai ks. kaikki\nPS&gt; $profile | Select-Object *\n\n# avaa haluamasi VS Codessa\nPS&gt; code $profile.CurrentUserAllHosts\n\n# kun olet muokannut, k\u00e4ynnist\u00e4 joko shell tai sourcea profiilitiedosto\nPS&gt; . $profile.CurrentUserAllHosts\n</code></pre> <p>Promptin muotoilusta vastaa funktio <code>prompt</code>. Voit ylikirjoittaa t\u00e4m\u00e4n funktion yhden istunnon ajaksi terminaalissa. Pysyv\u00e4mpi muutos syntyy muokkaamalla profiilitiedostoa, koska se ladataan joka kerta PowerShellin k\u00e4ynnistyess\u00e4. Tutustu t\u00e4h\u00e4n liittyviin helppeihin (about_Prompts, about_Profiles).</p> \ud83d\udda5\ufe0f /path/to/your/profile.ps1<pre><code>function prompt {\n    switch ((Get-Location).Provider.Name) {\n        FileSystem { $p = Split-Path -leaf -path (Get-Location) }\n        Default { $p = (Get-Location).Drive.Name }\n    }\n\n    \"PS $p&gt; \"\n  }\n</code></pre> <p>Py\u00f6r\u00e4\u00e4 ei kannata keksi\u00e4 uusiksi. Yll\u00e4 oleva prompt on muokattu superuser: Configure Windows PowerShell to display only the current folder name in the shell prompt-keskustelun vastauksista. Vaihtoehtoinen tapa olisi k\u00e4ytt\u00e4\u00e4 valmiita teemoja esimerkiksi oh-my-posh:n avulla.</p> <p>Warning</p> <p>Muista, ett\u00e4 sinun on pit\u00e4nyt ajaa <code>/app/scripts/localhelp.ps1</code>, joka lataa koneelle tallennetun helpin, tai komento <code>Update-Help</code>, joka lataa helpin netist\u00e4, jotta help oikeasti sis\u00e4lt\u00e4\u00e4 jotakin. Vaihtoehto on toki lukea esimerkiksi about_Prompts verkosta.</p>"},{"location":"powershell/38_strontium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Arvaa numero <p>Luo ohjelma, joka generoi luvun v\u00e4lilt\u00e4 1-1000 ja pyyt\u00e4\u00e4 k\u00e4ytt\u00e4j\u00e4\u00e4 arvaamaan sen. Ohjelma antaa vihjeen, onko arvattu luku suurempi vai pienempi kuin generoitu luku. Ohjelma lopettaa, kun k\u00e4ytt\u00e4j\u00e4 arvaa oikein. T\u00e4m\u00e4 on jo kerran tehty Bashilla, joten voit k\u00e4ytt\u00e4\u00e4 sit\u00e4 pohjana logiikan suhteen.</p> <p>Lis\u00e4\u00e4 ohjelmaan ominaisuus, ett\u00e4 se kellottaa k\u00e4ytt\u00e4j\u00e4n peliajan ja tulostaa sen lopuksi ruudulle. Pelatessa tulosteen pit\u00e4isi my\u00f6t\u00e4ill\u00e4 alla olevaa esimerkki\u00e4:</p> <pre><code>Arvaa luku v\u00e4lilt\u00e4 1-1000\n=================================================\nArvaa luku: 369\n\ud83d\udcc9 Liian pieni \n\nArvaa luku: 371\n\ud83d\udcc8 Liian suuri \n\nArvaa luku: 370\n\ud83c\udf89 Oikein! Arvasit luvun 370 \n\nPeliaika: 00:00:10.1029581\n</code></pre> <p>Varmista, ett\u00e4 pelaaja voi halutessaan lopettaa pelin. Minun toteutuksessa mik\u00e4 tahansa muu sy\u00f6te kuin kokonaisluvuksi parsittava sy\u00f6te lopettaa pelin (esim. <code>exit</code> tai tyhj\u00e4 merkkijono).</p> Vihje <pre><code>help *random*\n</code></pre> Vihje <p>Peliajan kellottamiseen voit k\u00e4ytt\u00e4\u00e4 <code>System.Diagnostics.Stopwatch</code>-luokkaa. Ohje l\u00f6ytyy PowerShell Communityn DevBlogs: Measuring average download time -artikkelista.</p> Teht\u00e4v\u00e4: Reminder <p>Aivan kuten ylempi, my\u00f6s t\u00e4m\u00e4 teht\u00e4v\u00e4 on sinulle tuttu Bash-osiosta. Luo kaksi ohjelmaa, jotka toimivat yhdess\u00e4. Toinen luo, toinen n\u00e4ytt\u00e4\u00e4 muistiinpanoja.</p> <ul> <li><code>install_remind.ps1</code><ul> <li>Luo aliakset <code>remind</code> ja <code>remember</code>, jotka suorittavat <code>remind.ps1</code>- ja <code>remember.ps1</code>-skriptit.</li> </ul> </li> <li><code>remember</code><ul> <li>Kysyy k\u00e4ytt\u00e4j\u00e4lt\u00e4 muistutuksia, jotka tallennetaan <code>$HOME/.reminder</code>-tiedostoon. </li> <li>Tyhj\u00e4 sy\u00f6te lopettaa muistutusten kirjoittamisen.</li> <li>Formaatti: <code>[timestamp] Muistutus</code></li> </ul> </li> <li><code>reminder</code><ul> <li>Tulostaa koko muistutustiedoston sis\u00e4ll\u00f6n.</li> </ul> </li> </ul> <p>Alla esimerkki asennuksen ja kummankin sovelluksen toiminnasta. Komentojen v\u00e4liin on lis\u00e4tty tyhj\u00e4 rivi lukemisen helpottamiseksi:</p> \ud83d\udc33 PowerShell<pre><code>PS /&gt; . /app/scripts/remind_install.ps1\n\nPS /&gt; remember\nEnter note (quit with empty note)\n&gt;&gt;&gt; : Buy an egg\n&gt;&gt;&gt; : Buy a chicken\n&gt;&gt;&gt; : Which one first? Help!\n&gt;&gt;&gt; :\n\nPS /&gt; remind\nYour reminders are as follows:\n[1739541147]    Buy an egg\n[1739541151]    Buy a chicken\n[1739541156]    Which one first? Help!\n</code></pre> Teht\u00e4v\u00e4: Verb-Noun generaattori <p>Kehit\u00e4 generaattori, <code>rnd-cmdlet.ps1</code>, joka luo uudenlaisia cmdlet-p\u00e4tevi\u00e4 nimi\u00e4, kuten <code>Get-Pizza</code> tai <code>Set-Spam</code>. Tee ohjelma siten, ett\u00e4, verbi arvotaan PowerShellin k\u00e4yt\u00f6ss\u00e4 olevista verbeist\u00e4. Substantiivi sen sijaan noudattaa seuraavaa logiikkaa:</p> <ul> <li>Jos k\u00e4ytt\u00e4j\u00e4 antaa argumentin skriptille, k\u00e4yt\u00e4 sit\u00e4.</li> <li>Jos ei, yrit\u00e4 noutaa substantiivi REST API:sta.<ul> <li>Osoite: <code>https://random-word-api.herokuapp.com/word</code></li> </ul> </li> <li>Jos ei onnistu, poimi satunnainen sana sanakirjasta.</li> </ul> <p>REST API:n kutsumiseen saat apua alemmasta vinkist\u00e4, jos et itse keksi ratkaisua.</p> <p>Jos tarvitset helpomman teht\u00e4v\u00e4n</p> Vinkki Verbi <p>Kokeile komentoa <code>Get-Verb</code>.</p> Vinkki REST API <pre><code>function getNoun {\n    try {\n        $url = \"https://random-word-api.herokuapp.com/word\"\n        $response = Invoke-RestMethod -Uri $url -Method Get\n        $noun = (Get-Culture).TextInfo.ToTitleCase($response[0])\n    }\n    catch {\n        Write-Warning \"Using a predefined list.\"\n        $noun = Get-Random -InputObject $nounVocabulary\n    }\n\n    return $noun\n}\n</code></pre> Teht\u00e4v\u00e4: Staattinen analyysi (PSScriptAnalyzer) <p>Bashin kanssa k\u00e4ytimme ohjelmaa <code>shellcheck</code>, joka analysoi skriptin ja antaa palautetta mahdollisista virheist\u00e4. PowerShellille vastaava ty\u00f6kalu on <code>PSScriptAnalyzer</code>. Sen pit\u00e4isi olla asennettuna ja aktiivsena, mutta voit tarkistaa, l\u00f6ytyyk\u00f6 se Get-Module cmdletill\u00e4:</p> <pre><code>PS&gt; Get-Module\n</code></pre> <p>Jos ei ole:</p> <pre><code>PS&gt; Install-Module -Name PSScriptAnalyzer -Force\n</code></pre> <p>T\u00e4m\u00e4n j\u00e4lkeen tarkista skriptisi:</p> <pre><code>PS&gt; Invoke-ScriptAnalyzer -Path ./scripts/*.ps1\n</code></pre> <p>Korjaa kaikki virheet ja varoitukset. Jos jokin virhe toistuu useita kertoja, harkitse Find &amp; Replace -toiminnon k\u00e4ytt\u00f6\u00e4 Visual Studio Codessa. Ole kuitenkin varovainen, ettet korvaa jotain, mit\u00e4 et halua korvata!</p> <p>Tip</p> <p>Saatat huomata varoituksia, joiden kuvaus on: <code>Missing BOM encoding for non-ASCII encoded file 'some_file.ps1</code>.</p> <p>N\u00e4m\u00e4 liittyv\u00e4t Windows PowerShell -yhteensopivuuteen. T\u00e4ll\u00e4 kurssilla helpoin tapa sivuuttaa ongelma on hiljent\u00e4\u00e4 n\u00e4m\u00e4 varoitukset. T\u00e4m\u00e4 onnistuu helpoiten luomalla seuraava tiedosto skriptihakemistoon:</p> scripts/PSScriptAnalyzerSettings.psd1<pre><code>@{\n    ExcludeRules=@('PSUseBOMForUnicodeEncodedFile')\n}\n</code></pre> <p>Huomaa, ett\u00e4 tiedoston nimen tulee olla juurikin tuo sama. Muutoin <code>Invoke-ScriptAnalyzer</code> ei osaa etsi\u00e4 sit\u00e4.</p>"},{"location":"powershell/96_curium/","title":"\ud83d\udc69\u200d\ud83d\udd2c Curium","text":""},{"location":"powershell/96_curium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"powershell/96_curium/#pipeline","title":"Pipeline","text":"<p>PowerShelliss\u00e4 on huomattavan tehokasta hy\u00f6dynt\u00e4\u00e4 sit\u00e4, ett\u00e4 merkkijonon sijasta meill\u00e4 on k\u00e4sitelt\u00e4v\u00e4n\u00e4 objekteja. T\u00e4h\u00e4n voi tutustua esimerkiksi seuraavan koodin avulla:</p> \ud83d\udc33 PowerShell<pre><code>Get-Item Env:PATH `\n    | Select-Object -ExpandProperty Value `\n    | ForEach-Object { $_ -Split [System.IO.Path]::PathSeparator } `\n    | Resolve-Path `\n    | Select-Object -Property Drive, Path, Provider \n</code></pre> <p>Kyseinen koodi ajaa <code>Get-Item</code> komennon <code>Env:PATH</code>:iin. Palautuva entiteetti on tyyppi\u00e4 <code>System.Collections.DictionaryEntry</code>. T\u00e4ss\u00e4 tyypiss\u00e4, eli dictionaryst\u00e4, on kent\u00e4t <code>Key</code> ja <code>Value</code>. N\u00e4ist\u00e4 meit\u00e4 kiinnostaa vain <code>Value</code>, joka on jatkossa vain tavallinen <code>[System.String]</code> eli merkkijono. Sen sijaan <code>Resolve-Path</code>:n j\u00e4lkeen merkkijonosta muotoutuu merkitt\u00e4v\u00e4sti abstraktimpi olio <code>[System.Management.Automation.PathInfo]</code>. T\u00e4m\u00e4 olio sis\u00e4lt\u00e4\u00e4 tietoa polusta, asemasta ja palveluntarjoajasta - ja se automaattisesti tarkistaa, onko koko hakemisto olemassa.</p> <p>Jos haluat muotoilla jotakin kentt\u00e4\u00e4 <code>Select-Object</code>-yhteydess\u00e4, se onnistuu alla olevalla komennolla. Kent\u00e4n nimen sijasta sy\u00f6t\u00e4t <code>@{}</code>-kent\u00e4n eli hashtaulun, jossa on <code>Name</code> ja <code>Expression</code>-kent\u00e4t. Expressinin sis\u00e4ll\u00e4 <code>$_</code> viittaa jokaiseen objektiin pipelinesta eli t\u00e4ss\u00e4 tapauksessa <code>PathInfo</code>-olioon.</p> env_objects.ps1<pre><code>$custom = @{ Name=\"Provider\"; Expression={$_.Provider.Name} }\n\nGet-Item Env:PATH \n    | Select-Object -ExpandProperty Value \n    | ForEach-Object { $_ -Split [System.IO.Path]::PathSeparator } \n    | Resolve-Path \n    | Select-Object -Property Drive, Path, $custom\n</code></pre> \ud83d\udc33 Tuloste<pre><code>PS/&gt; /app/scripts/env_objects.ps1\nDrive Path                        Provider\n----- ----                        --------\n/     /opt/microsoft/powershell/7 FileSystem\n/     /usr/local/sbin             FileSystem\n/     /usr/local/bin              FileSystem\n/     /usr/sbin                   FileSystem\n/     /usr/bin                    FileSystem\n/     /sbin                       FileSystem\n/     /bin                        FileSystem\n</code></pre> <p>Tip</p> <p>Huomaa, ett\u00e4 yll\u00e4 oleva esimerkki on tarpeettoman monimutkainen t\u00e4h\u00e4n use caseen. Se on esill\u00e4, koska ymp\u00e4rist\u00f6muuttuja PATH on meille jo entuudestaan tuttu. Jos haluat yksinkertaisesti listata, mit\u00e4 PATH sis\u00e4lt\u00e4\u00e4, riitt\u00e4\u00e4 k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4n mukaan jompi kumpi seuraavista riveist\u00e4:</p> <pre><code>$env:PATH -Split \":\"  # Linux\n$env:PATH -Split \";\"  # Windows\n</code></pre>"},{"location":"powershell/96_curium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Pingviinien laskeminen <p>PowerShelliss\u00e4 pipeline siirt\u00e4\u00e4 datan objektin muodossa. Joskus se on ihan vain <code>System.String</code>, joskus se edustaa jotakin spesifi\u00e4 luokkaa. Huomaa, ett\u00e4 aiemmin oppimassamme Bashiss\u00e4 data on aina tekstirivej\u00e4. Jos haluaisit parsia sarakkeita, joudut k\u00e4ytt\u00e4m\u00e4\u00e4n <code>awk</code>-ty\u00f6kalua tai vastaavaa.</p> <p>Selvit\u00e4, mit\u00e4 kukin rivi alla olevassa koodissa tekee. Tutki, mit\u00e4 dataa kukin komento saa ja mit\u00e4 se palauttaa. Mik\u00e4 olio on kyseeess\u00e4 miss\u00e4kin v\u00e4liss\u00e4?</p> <p>Koodirivit on valmiiksi numeroitu. K\u00e4yt\u00e4 kyseisi\u00e4 numeroita viittaamaan riveihin ja kirjoita vastauksesi erilliseen moniriviseen kommenttiblokkiin. Halutessasi voit kirjoittaa dokumentaation esimerkiksi erilliseen Markdown-tiedostoon ja viitata siihen.</p> penguins.ps1<pre><code>$URL = \"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/penguins.csv\"\n$df = Invoke-WebRequest -Uri $URL               # 1\n    | Select-Object -ExpandProperty Content     # 2\n    | ConvertFrom-Csv                           # 3\n    | Group-Object -Property species            # 4\n    | Sort-Object -Property Count -Descending   # 5\n    | Select-Object -Property Name, Count       # 6\n\n&lt;#\n1: Select-Object\n    Dokumentoi t\u00e4h\u00e4n ensimm\u00e4inen komento eli Select-Object.\n    Teksti\u00e4 teksti\u00e4 teksti\u00e4 ja teksti\u00e4 et cetera et cetera.\n    Teksti\u00e4 teksti\u00e4 teksti\u00e4 ja teksti\u00e4 et cetera et cetera.\n2: ConvertFromCsv\n    ...\n6: Select-Object\n    ...\n#&gt;\n\nWrite-Output $df\n</code></pre> Vinkki <p>Kommentoi muut paitsi ensimm\u00e4inen rivi blokista pois ja lis\u00e4\u00e4 seuraavaksi elementiksi pipelineen <code>| Get-Member</code> tai <code>| Format-Table</code>. Sitten t\u00e4\u00e4 t\u00e4m\u00e4 seuraavalle riville ja niin edelleen.</p> Teht\u00e4v\u00e4: Suurimmat ohjelmat <p>Luo skripti, joka tulostaa <code>n</code> kappaletta suurimpia bin\u00e4\u00e4ritiedostoja <code>/usr/bin</code>-hakemistossa. Vakio <code>n = 5</code>, mutta k\u00e4ytt\u00e4j\u00e4 voi sy\u00f6tt\u00e4\u00e4 sen. Esimerkki k\u00e4yt\u00f6st\u00e4 alla:</p> \ud83d\udc33 PowerShell<pre><code>PS/&gt; /app/scripts/largest_binaries.ps1 -n 7\nName       Size (MB)\n----       ---------\ngpg2           1.124\nbash           0.938\nssh            0.825\nopenssl        0.818\ngpgsm          0.566\ngpgv2          0.520\nssh-keygen     0.499\n</code></pre> Teht\u00e4v\u00e4: Duplikaattitiedostojen luominen <p>T\u00e4m\u00e4 teht\u00e4v\u00e4 toimii esiasteena seuraavalle teht\u00e4v\u00e4lle. Luo skripti, joka kirjoittaa tiedostoihin sis\u00e4lt\u00f6\u00e4 siten, ett\u00e4 osa tiedostoista on tarkoituksella toistensa kopioita. Osa tiedostoista tulee sen sijaan olla uniikkeja. Voit k\u00e4ytt\u00e4\u00e4 apuna seuraavanlaista jakoa:</p> add_duplicates.ps1<pre><code>$duplicateFiles = @(\n    \"$DTEMP/foo.txt\",\n    \"$DTEMP/foo_copy.txt\",\n    \"$DTEMP/nested/foo_copy_nested.txt\"\n)\n\n$uniqueFiles = @(\n    \"$DTEMP/unicorn_a.txt\",\n    \"$DTEMP/nested/unicorn_b.txt\"\n)\n</code></pre> <p>Lopulta ohjelmaa tulisi voida k\u00e4ytt\u00e4\u00e4 seuraavanlaisesti:</p> \ud83d\udc33 PowerShell<pre><code>PS /&gt; /app/scripts/add_duplicates.ps1\nDuplicate files have been created in: /tmp/20250217_duplicates\n\nPS /&gt; Get-Content /tmp/20250217_duplicates/foo.txt\nThis is some duplicate content.\n\nPS /&gt; Get-Content /tmp/20250217_duplicates/nested/foo_copy_nested.txt\nThis is some duplicate content.\n\nPS /&gt; Get-Content /tmp/20250217_duplicates/unicorn_a.txt             \n5f976325-d704-403f-8442-66b626989aa0\n\nPS /&gt; Get-Content /tmp/20250217_duplicates/nested/unicorn_b.txt      \ne3c216bf-f020-402a-beb4-7e838044776d\n</code></pre> <p>Uniikki sis\u00e4lt\u00f6</p> <p>Uniikki\u00e4 sis\u00e4lt\u00f6\u00e4 on helppo luoda <code>Get-Uuid</code>-funktiolla.</p> Teht\u00e4v\u00e4: Duplikaattien tunnistaminen <p>Luo skripti, joka tunnistaa duplikaatit annetussa hakemistossa. Mik\u00e4li <code>-Recurse</code> option on annettu, sen tulisi k\u00e4yd\u00e4 my\u00f6s alihakemistot l\u00e4pi. Duplikaatit tulisi tunnistaa tiedoston MD5-hashin perusteella. Lopullisen sovelluksen tulisi vastata <code>Get-Help</code>-komentoon seuraavaa sis\u00e4lt\u00f6\u00e4 my\u00f6t\u00e4ilev\u00e4ll\u00e4 tavalla:</p> <pre><code>NAME\n/app/scripts/find_duplicates.ps1\n\nSYNOPSIS\n    Find duplicate files in a directory (or recursively in subdirectories).\n\nSYNTAX\n    /app/scripts/find_duplicates.ps1 [[-Path] &lt;String&gt;] [-Recurse] [&lt;CommonParameters&gt;]\n</code></pre> <p>Testaa ohjelma sek\u00e4 <code>-Recurse</code> parametrilla ett\u00e4 ilman k\u00e4ytt\u00e4en kohteena aiemman <code>add_duplicates.ps1</code>-skriptin luomaa hakemistoa. Esimerkki alla:</p> \ud83d\udc33 PowerShell<pre><code>PS /&gt; /app/scripts/find_duplicates.ps1 /tmp/20250217_duplicates/ -Recurse\nWARNING: Duplicate files found:\n\nFullName                                            Hash\n--------                                            ----\n/tmp/20250217_duplicates/foo_copy.txt               EAACC3FB772804B7670032CF1ACCBF79\n/tmp/20250217_duplicates/foo.txt                    EAACC3FB772804B7670032CF1ACCBF79\n/tmp/20250217_duplicates/nested/foo_copy_nested.txt EAACC3FB772804B7670032CF1ACCBF79\n</code></pre> <p>Warning</p> <p>Varmista, ett\u00e4 uniikit <code>/tmp/yyyymmdd_duplicates/unicorn_a.txt</code> ja <code>.../nested/unicorn_b.txt</code> eiv\u00e4t n\u00e4y duplikaatteina.</p> <p>Tip</p> <p>Muistathan yh\u00e4 ajaa <code>Invoke-ScriptAnalyzer</code>-komennon kaikille skripteillesi! T\u00e4m\u00e4n skriptin kohdalla tulet huomaamaan varoituksen: <code>The Algorithm parameter of cmdlet 'Get-FileHash' was used with the broken algorithm 'MD5'.</code></p> <p>MD5 ei suinkaan ole rikki, mutta se ei ole kryptaukseen liittyviss\u00e4 yhteyksiss\u00e4 riitt\u00e4v\u00e4n vahva. Voit sivuuttaa t\u00e4m\u00e4n varoituksen lis\u00e4\u00e4m\u00e4ll\u00e4 seuraavat rivit skriptisi alkuun:</p> <pre><code>[Diagnostics.CodeAnalysis.SuppressMessage(\n\"PSAvoidUsingBrokenHashAlgorithms\",\n\"\",\nJustification = \"We are using MD5 for non-cryptographic purposes.\"\n)]\n</code></pre>"},{"location":"powershell/99_einsteinium/","title":"\ud83d\udc68\u200d\ud83d\udd2c Einsteinium","text":""},{"location":"powershell/99_einsteinium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"powershell/99_einsteinium/#invoke-expression","title":"Invoke-Expression","text":"<p><code>Invoke-Expression</code>-funktio on hy\u00f6dyllinen, kun haluat ajaa dynaamisesti generoituja komentoja. Staattinen koodianalyysi tulee varoittamaan t\u00e4st\u00e4, koska se on potentiaalinen tietoturvariski, ja voi altistaa sinut injection-hy\u00f6kk\u00e4yksille. K\u00e4yt\u00e4 siis harkiten. Alla esimerkki:</p> <pre><code># Lista komennon palasista\n$dockerCmd = @(\n    \"docker run\",\n    \"--rm\"\n)\n\n# Lis\u00e4\u00e4 komentoon osia valitsemallasi logiikalla\n# K\u00e4yt\u00e4 esimerkiksi if-lauseita.\n$dockerCmd += \"--some-other-part\"\n\n# Lopulta yhdist\u00e4 komennon palaset toisiinsa k\u00e4ytt\u00e4en v\u00e4lily\u00f6nti\u00e4\n# erotinmerkkin\u00e4 ja aja komento.\nInvoke-Expression ($dockerCmd -join ' ')\n</code></pre>"},{"location":"powershell/99_einsteinium/#what-if","title":"What If","text":"<p>Jos haluat varmistaa, ett\u00e4 komento toimii oikein, mutta et halua sit\u00e4 viel\u00e4 ajaa, voit k\u00e4ytt\u00e4\u00e4 <code>-WhatIf</code>-parametria. Alla on minimaalinen skripti, joka tukee toiminnallisuutta ja k\u00e4ytt\u00e4\u00e4 sit\u00e4 yhdess\u00e4 funktiossa:</p> what_if.ps1<pre><code># This activates the script to support WhatIf\n[CmdletBinding(SupportsShouldProcess)]\nparam(\n    [string]$Name='Unknown Person'\n)\n\nfunction Write-Name {\n    [CmdletBinding(SupportsShouldProcess)]\n    param (\n        [string]$Name\n    )\n\n    # This is where the WhatIf is checked.\n    if ($PSCmdlet.ShouldProcess($Name)) {\n        Write-Output \"Hello, $Name!\"\n    }\n}\n\n#                       This passes the WhatIf to the function\nWrite-Name -Name $Name -WhatIf:$WhatIfPreference\n</code></pre>"},{"location":"powershell/99_einsteinium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: PowerShell Docker Wrapper</p> <p>Olet varmasti kurssin aikana huomannut oudon riippuvuuden Bashiin: sinulla on lokaali PowerShell asennettuna syntax highlighti\u00e4 varten, mutta kun haluat ajaa PowerShelli\u00e4 kontin sis\u00e4ll\u00e4, p\u00e4\u00e4dyt ajamaan <code>./runpwsh.sh</code>-skriptin Bash-terminaalissa.</p> <p>Toteuta <code>runpwsh.sh</code>-skriptin vastine PowerShellille. T\u00e4m\u00e4 <code>runpwsh.ps1</code>-skripti tulisi olla vastaavalla tavalla k\u00e4ytett\u00e4viss\u00e4 kuin edelt\u00e4j\u00e4ns\u00e4. Alla karkea esimerkki:</p> <pre><code>PS /&gt; ./runpwsh.ps1 scripts/hello.ps1\nHello, World!\n\nPS /&gt; ./runpwsh.ps1\nPS /app&gt;              # &lt;= In the container\n</code></pre> <p>Tee skriptist\u00e4 helposti luettava. K\u00e4yt\u00e4 funktioita, jotta skripti on helposti yll\u00e4pidett\u00e4viss\u00e4 ja luettavissa. \u00c4l\u00e4 my\u00f6sk\u00e4\u00e4n unohda helppi\u00e4 (ks. about_Comment_Based_Help) !</p> Vinkki: Dry Run <p>Jos k\u00e4yt\u00e4t t\u00e4rpeiss\u00e4 esitelty\u00e4 tapaa eli kasaat komennon osatekij\u00e4t listaksi ja lopulta ajat sen <code>Invoke-Expression</code>-funktiolla, kannattaa toteuttaa \"Dry Run\"-toiminnallisuus. T\u00e4m\u00e4n voi tehd\u00e4 joko kotikutoisesti tai seuraten PowerShell-k\u00e4yt\u00e4nt\u00f6j\u00e4 eli k\u00e4ytt\u00e4m\u00e4ll\u00e4 <code>SupportsShouldProcess</code>-attribuuttia. N\u00e4in skriptin voi ajaa <code>-WhatIf</code>-parametrilla, ja se tulostaa potentiaalisesti vaaralliset rivit ajamisen sijasta.</p>"},{"location":"powershell/aloita/","title":"PowerShell 101","text":""},{"location":"powershell/aloita/#perusteet","title":"Perusteet","text":""},{"location":"powershell/aloita/#missa-ajetaan","title":"Miss\u00e4 ajetaan?","text":""},{"location":"powershell/aloita/#docker","title":"Docker","text":"<p>Jotta sinun on mahdollista tehd\u00e4 t\u00e4m\u00e4n kurssin teht\u00e4vi\u00e4, sinulla on oltava PowerShell k\u00e4yt\u00f6ss\u00e4. Jos teet skriptej\u00e4, jotka poistavat tiedostoja tai tekev\u00e4t jotakin muuta vaarallista, on suositeltavaa ajaa PowerShelli\u00e4 Docker-kontissa. T\u00e4m\u00e4n pit\u00e4isi olla sinulle tuttua jo aiemmasta Bash-osiosta. Kontti noudetaan Docker Hubin sijasta Microsoft Artifact Registry: PowerShell-katalogista. Kontti rakentuu Ubuntun p\u00e4\u00e4lle, mutta siihen on asennettu PowerShell riippuvuuksineen, ja vakio CMD ei ole <code>bash</code>, vaan <code>pwsh</code>.</p> <p>Tip</p> <p>Jos haluat harjoitella Microsoft Windows -spesifisi\u00e4 komentoja, kuten <code>Get-Service</code>, tarvitset Windows-ymp\u00e4rist\u00f6n. Docker luo Linux-kontteja. Emme k\u00e4sittele Windows-komentoja t\u00e4ss\u00e4 kurssissa, mutta voit kokeilla niit\u00e4 omalla koneellasi, mik\u00e4li sinulla on Windows-kone k\u00e4yt\u00f6ss\u00e4si.</p>"},{"location":"powershell/aloita/#local-machine","title":"Local Machine","text":"<p>On kovin tyypillist\u00e4, ett\u00e4 Dockeria suositellaan l\u00e4\u00e4kkeeksi aivan kaikkeen. Tulet huomaamaan, ett\u00e4 jos ajat kaiken koodin v\u00e4liaikaisessa kontissa, koodin syntaksia v\u00e4ritt\u00e4v\u00e4 VS Code PowerShell Extension ei toimi. Kyseinen Extension, aivan kuten muiden kielten vastaavat, tarvitsev\u00e4t p\u00e4\u00e4syn kielen runtimeen, jotta ne voivat tarjota sinulle koodin t\u00e4ydennyst\u00e4, syntaksiv\u00e4rittely\u00e4 ja muuta.</p> <p>Helpoin tapa ratkaista t\u00e4m\u00e4? Asenna PowerShell lokaalisti, olit sitten Windows-, macOS- tai Linux-k\u00e4ytt\u00e4j\u00e4. Voit yh\u00e4 ajaa vaaralliset tai ep\u00e4varmat skriptit Docker-kontissa, mutta voit kirjoittaa ja testata skriptisi lokaalisti.</p>"},{"location":"powershell/aloita/#dev-container","title":"Dev Container","text":"<p>Voit yritt\u00e4\u00e4 best of both worlds-ratkaisua Visual Studio Coden Dev Containers -ominaisuuden avulla. T\u00e4m\u00e4 on kuitenkin edistyneempi aihe. Emme k\u00e4sittele sit\u00e4 t\u00e4ss\u00e4 kurssissa.</p>"},{"location":"powershell/aloita/#mika-se-on","title":"Mik\u00e4 se on?","text":"<p>PowerShell on Microsoftin kehitt\u00e4m\u00e4 skriptauskieli ja komentotulkki. Se on suunniteltu alunperin Windows-ymp\u00e4rist\u00f6\u00f6n, mutta nyky\u00e4\u00e4n se on saatavilla my\u00f6s Linuxille ja macOS:lle. Jos tarkkoja ollaan, niin tuotteita on kaksi, joista vain toinen on saatavilla muille kuin Windowsille:</p> <ul> <li>\u24c2\ufe0f Windows PowerShell<ul> <li>Asentuu Windowsin mukana. Perustuu kaupalliseen .NET Frameworkiin. Tuorein versio on 5.1 eik\u00e4 Microsoft en\u00e4\u00e4 kehit\u00e4 sit\u00e4.</li> <li>Executable: <code>powershell.exe</code></li> </ul> </li> <li>\u24c2\ufe0f\ud83c\udf4e\ud83d\udc27 PowerShell<ul> <li>Asennetaan erikseen. Tuorein versio on 7.x ja Microsoft kehitt\u00e4\u00e4 sit\u00e4 aktiivisesti.</li> <li>Executable: <code>pwsh</code></li> </ul> </li> </ul> <p>Warning</p> <p>Huomaa, ett\u00e4 kaikkia moduuleita tai cmdlettej\u00e4 ei ole saataville kaikille alustoille. Esimerkiksi moduulin <code>Microsoft.PowerShell.Management</code> komento <code>Get-Service</code> ei toimi Linuxissa. T\u00e4m\u00e4 johtuu .NET Frameworkin ja .NET Coren eroista. <sup>2</sup></p>"},{"location":"powershell/aloita/#entapa-net","title":"Ent\u00e4p\u00e4 .NET?","text":"<p>Dotnet (.NET) on kehitysymp\u00e4rist\u00f6 (engl. developer platform), jolla on useita teht\u00e4vi\u00e4 ja joka koostuu useista eri osista. Ekosysteemiin kuuluu esimerkiksi ajoymp\u00e4rist\u00f6 (engl. runtime envinronment) Common Language Runtime (CLR), joka on vastuussa koodin suorittamisesta Java-virtuaalikoneen tapaan. Suoritettava koodi on Common Intermediate Language (CIL) tavukoodia. Ekosysteemi sis\u00e4lt\u00e4\u00e4 n\u00e4iden lis\u00e4ksi kirjastoja, k\u00e4\u00e4nt\u00e4j\u00e4n, SDK ja muuta. Varsinaiset CIL-kieleksi k\u00e4\u00e4nnett\u00e4v\u00e4t dotnet-ohjelmointikielet ovat C# ja F#. PowerShell on sek\u00e4 tulkki (komentokehote, CLI) ett\u00e4 skriptauskieli, joka k\u00e4ytt\u00e4\u00e4 .NETin kirjastoja. Sit\u00e4 ei k\u00e4\u00e4nnet\u00e4, vaan sit\u00e4 tulkataan dynaamisesti ajon aikana PowerShell runtimen toimesta. <sup>1</sup></p> <p>Jos ylempi kappale meni aivan ohi, niin t\u00e4rke\u00e4\u00e4 on sis\u00e4ist\u00e4\u00e4, ett\u00e4 .NET kirjastoja voi kutsua PowerShellist\u00e4, koska se on .NET-ymp\u00e4rist\u00f6ss\u00e4 toimiva kieli. PowerShellin cmdletit ovat k\u00e4\u00e4nnettyj\u00e4 .NET-kirjastojen kutsuja. K\u00e4yt\u00e4nn\u00f6ss\u00e4 seuraavat kaksi tekev\u00e4t jossain m\u00e4\u00e4rin saman asian, joskin alempaa muotoa on luonteva k\u00e4ytt\u00e4\u00e4 vain silloin, kun sopivaa cmdleti\u00e4 ei ole olemassa:</p> <pre><code># PowerShell cmdlet\nGet-Process\n\n# .NET Library the cmdlet wraps\n[System.Diagnostics.Process]::GetProcesses()\n</code></pre> <p>Info</p> <p>Namespacen ensimm\u00e4inen osa, esim. <code>System</code>, voidaan usein j\u00e4tt\u00e4\u00e4 pois. N\u00e4in esimerkiksi <code>[System.Math]</code> on sama kuin <code>[Math]</code>.</p> <p>Dotnet-kirjastojen avulla voi saada C#:st\u00e4 tuttuja toiminnallisuuksia ty\u00f6kalupakkiisi. Esimerkkin\u00e4 t\u00e4st\u00e4 olkoot luvun korottaminen potenssiin, joka hoituu PowerShelliss\u00e4 n\u00e4in:</p> PowerShell<pre><code>$result = [Math]::Pow(10, 2)\n\nWrite-Host $result\n</code></pre> <p>Ja C#:ss\u00e4 n\u00e4in:</p> C#<pre><code>using System;\n\nclass Program {\n    static void Main() {\n        double result = Math.Pow(10, 2);\n        Console.WriteLine(result);\n    }\n}\n</code></pre>"},{"location":"powershell/aloita/#erot-bashiin","title":"Erot Bashiin","text":"<p>PowerShelliss\u00e4 k\u00e4sitell\u00e4\u00e4n p\u00e4\u00e4asiassa objekteja. T\u00e4m\u00e4 tulee jatkumaan my\u00f6hemmin Python-osiossa: my\u00f6s se kieli on rankasti objekteihin suuntautunut.</p> <p>\"A key difference with Bash is that it is mostly objects that you manipulate rather than plain text\" <sup>3</sup></p> <p>K\u00e4yt\u00e4nn\u00f6ss\u00e4 t\u00e4m\u00e4 tarkoittaa sit\u00e4, ett\u00e4 esimerkiksi kokonaisluku on objekti, ja objektilla on metodeja. K\u00e4rjistettyn\u00e4 Bashiss\u00e4 kaikki on vain teksti\u00e4, eli merkkijonoa, jota voidaan tulkita esimerkiksi lukuja aritmeettisissa operaatioissa (<code>let</code> tai <code>$(( expression ))</code>). PowerShelliss\u00e4 luku on luku, merkkijono on merkkijono ja esimerkiksi IP-osoite on IP-osoite. Kaikilla niill\u00e4 on omat metodinsa. Jos putkitat yhden komennon tulosteen toisen komennon sy\u00f6tteeksi, niin kyseinen komentoketju (engl. command chain) sis\u00e4lt\u00e4\u00e4 useita eri objekteja listana. Bashist\u00e4 tuttu <code>grep</code>, <code>awk</code> tai <code>sed</code> parsiminen vaihtuu objektien k\u00e4sittelyksi. Tulet tutustumaan t\u00e4h\u00e4n my\u00f6hemmin harjoitusten muodossa.</p> <p>Tip</p> <p>Voit siis ajaa one-liner komennon: <code>$number = 10; $number.GetType()</code>. Ruutuun tulostuu taulukkomuotoinen n\u00e4kym\u00e4, jonka sis\u00e4ll\u00f6st\u00e4 ja muodosta vastaa Out-Default. Huomaa, ett\u00e4 komennossa kutsutaan numeron omaa metodia <code>GetType()</code>, joka palauttaa tiedon siit\u00e4, mink\u00e4 tyyppinen objekti on kyseess\u00e4. T\u00e4t\u00e4 et voi Bashiss\u00e4 tehd\u00e4.</p>"},{"location":"powershell/aloita/#ensimmainen-kontti","title":"Ensimm\u00e4inen kontti","text":"<p>Alla olevan <code>docker container run</code> komento on Bash-osiosta tuttu, joskin k\u00e4yt\u00e4mme eri imagea. Komento k\u00e4ynnist\u00e4\u00e4 PowerShellin Docker-kontissa.</p> Bash | Git Bash | PowerShell | CMD<pre><code>docker container run --rm -it mcr.microsoft.com/powershell \n</code></pre> \ud83c\udf4e Apple Silicon -k\u00e4ytt\u00e4jille <p>Yll\u00e4 mainittu image ei v\u00e4ltt\u00e4m\u00e4tt\u00e4 toimi macOS-koneella, jossa on Silicon-prosessi (M1, M2, ...). Voi toki olla, ett\u00e4 tilanne on muuttunut sitten t\u00e4m\u00e4n ohjeen kirjoittamisen, mutta jos kyseinen image kaataa Terminaalin jatkuvasti, kokeile arm64:lle k\u00e4\u00e4nnetty\u00e4 imagea, joka perustuu Microsoftin kehitt\u00e4m\u00e4\u00e4n Mariner-jakeluun (alias Azure Linux).</p> <pre><code># macOS ARM64\ndocker container run --rm -it mcr.microsoft.com/powershell:mariner-2.0-arm64\n</code></pre> <p>Docker-komento ja sen parametrit (<code>--rm</code> ja <code>-it</code>) ovat sinulle jo tuttuja Bash-osiosta. Alla olevassa koodissa tulostetaan PowerShellin versiotiedot Docker-kontissa. Alempana n\u00e4et tulosteen. Komento on ajettu samana p\u00e4iv\u00e4n\u00e4 sek\u00e4 Ubuntu- ett\u00e4 macOS-koneella, j\u00e4lkimm\u00e4isess\u00e4 k\u00e4ytt\u00e4en <code>mariner</code>-imagea.</p> PowerShell @ Docker<pre><code>$PSVersionTable\n</code></pre> Ubuntu amd64macOS arm64 stdout @ Docker<pre><code>Name                           Value\n----                           -----\nPSVersion                      7.4.2\nPSEdition                      Core\nGitCommitId                    7.4.2\nOS                             Ubuntu 22.04.4 LTS\nPlatform                       Unix\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\nWSManStackVersion              3.0\n</code></pre> stdout @ Docker<pre><code>Name                           Value\n----                           -----\nPSVersion                      7.4.6\nPSEdition                      Core\nGitCommitId                    7.4.6\nOS                             CBL-Mariner/Linux\nPlatform                       Unix\nPSCompatibleVersions           {1.0, 2.0, 3.0, 4.0\u2026}\nPSRemotingProtocolVersion      2.3\nSerializationVersion           1.1.0.1\nWSManStackVersion              3.0\n</code></pre>"},{"location":"powershell/aloita/#komennot-ja-apu","title":"Komennot ja apu","text":"<p>Varsinaiset komennot ovat <code>cmdlet</code>-tyyppisi\u00e4. Ne koostuvat verbist\u00e4 ja substantiivista. Alla esimerkki:</p> <ul> <li><code>Verb-Noun</code>: pseudoesimerkki</li> <li><code>Get-Process</code>: hakee prosessit</li> <li><code>Get-Alias</code>: hakee aliasit komennoilla (esim. <code>dir</code> on <code>Get-ChildItem</code> komennon alias)</li> <li><code>Update-Help</code>: p\u00e4ivitt\u00e4\u00e4 PowerShellin helpin, ladaten rutkasti esimerkkej\u00e4 ja lis\u00e4apua.</li> </ul> <p>Mist\u00e4 tahansa komennosta saat helpin muutamalla eri tavalla. Alla esimerkkej\u00e4, joissa halutaan saada lis\u00e4\u00e4 tietoa Get-ChildItem-komennosta:</p> <pre><code># Kenties alkuun haluat ajaa:\nUpdate-Help\n\n# Get-Noun muoto\nGet-Help Get-ChildItem\n\n# Huomaa, ett\u00e4 se ei ole case-sensitiivinen\nget-help get-childitem\n\n# Output on helpompi lukea less-ohjelmassa\nGet-Help Get-ChildItem | less\n\n# Lyhyt muoto (alias)\nhelp Get-ChildItem\n\n# Kysymysmerkki\nGet-ChildItem -?\n</code></pre> <pre><code>Verb-Noun -parameter value -anotherparameter anothervalue -switch\n</code></pre> <p>Kyseinen <code>Verb-Noun</code>-cmdlet-pohjainen syntaksi on PowerShellin ydin. Esimerkiksi <code>Get-Process</code> hakee prosessit ja <code>Stop-Process</code> pys\u00e4ytt\u00e4\u00e4 prosessin.</p>"},{"location":"powershell/aloita/#skripti","title":"Skripti","text":"<p>Aivan kuten Bashin kohdalla, my\u00f6s PowerShelliss\u00e4 skripti on tiedosto, joka sis\u00e4lt\u00e4\u00e4 yhden tai useamman komennon. Aivan kuten Bash, PowerShell on my\u00f6skin tulkki, jossa toimii samat komennot kuin skriptitiedostoissa.</p> <p></p> <p>Kuva 1: Yksinkertainen for-silmukka PowerShelliss\u00e4 ilman erillist\u00e4 skriptitiedostoa. Komento on ajettu kontissa.</p>"},{"location":"powershell/aloita/#sisalto","title":"Sis\u00e4lt\u00f6","text":"<p>Skripti on tiedosto, joka sis\u00e4lt\u00e4\u00e4 yhden tai useamman komennon. T\u00e4m\u00e4 on sinulle Bashista tuttua, mutta PowerShellin kohdalla konvention mukainen tiedostop\u00e4\u00e4te on <code>.ps1</code>. Huomaa, ett\u00e4 shebang ei ole tarpeen, jos tiedosto ajetaan nimenomaan PowerShelliss\u00e4. Tiedoston ei my\u00f6sk\u00e4\u00e4n tarvitse olla executable eli <code>chmod +x</code> ei ole tarpeen.</p> hello.ps1<pre><code>Write-Host \"Hello, World!\"\n</code></pre>"},{"location":"powershell/aloita/#suorituspolitiikka-m-win","title":"Suorituspolitiikka (\u24c2\ufe0f Win)","text":"<p>On t\u00e4rke\u00e4\u00e4 huomata, ett\u00e4 jos ajat PowerShelli\u00e4 Windows-ymp\u00e4rist\u00f6ss\u00e4, sinun tulee ottaa huomioon execution policy. Kyseinen asetus s\u00e4\u00e4t\u00e4\u00e4 sit\u00e4, miss\u00e4 tapauksissa skriptej\u00e4 saa suorittaa. Tavallisessa Windows Home/Pro -ymp\u00e4rist\u00f6ss\u00e4 execution policy on Restricted, joka tarkoittaa, ett\u00e4 mit\u00e4\u00e4n skriptej\u00e4 ei saa ajaa. Yleisesti suositeltu asetus on RemoteSigned.</p> <p>Jos et ole aikaisemmin tehnyt mit\u00e4\u00e4n PowerShell-skriptien ajoon liittyvi\u00e4 toimenpiteit\u00e4, suorita seuraava komento:</p> PowerShell in Windows<pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre> <p>Tip</p> <p>Jos ajat PowerShelli\u00e4 Docker-kontissa tai muutoin Linuxissa, sinun ei tarvitse huolehtia t\u00e4st\u00e4: policy on vakiona Unrestricted, eik\u00e4 RemoteSigned ole edes tuettu.</p> Tietoturva-offtopic <p>RemoteSigned ei v\u00e4ltt\u00e4m\u00e4tt\u00e4 toimi aivan kuten sen arvaisi toimivan. Se, onko tiedosto Internetist\u00e4 ladattu vai ei, m\u00e4\u00e4rittyy <code>Zone.Identifier</code> -attribuutin perusteella. T\u00e4m\u00e4 ongelma on kuitenkin helppo kiert\u00e4\u00e4: poista attribuutti tiedostosta. Jos kokeilet ladata <code>Invoke-RestMethod</code>-komennolla skriptin, saatat yll\u00e4tty\u00e4, kun sill\u00e4 ei olekaan koko Zone.Identifieri\u00e4 asetettuna, vaikka voisi kuvitella. My\u00f6s koko policy on helposti kierr\u00e4viss\u00e4.</p> <p>Execution Policy ei ole siis sin\u00e4ns\u00e4 vahva turvamekanismi. Se l\u00e4hinn\u00e4 ehk\u00e4isee k\u00e4ytt\u00e4j\u00e4\u00e4 ajamasta skriptej\u00e4 huomaamattaan.</p>"},{"location":"powershell/aloita/#tiedoston-luominen","title":"Tiedoston luominen","text":"<p>Tiedoston voi luoda mill\u00e4 tahansa tekstieditorilla, mutta on suositeltavaa k\u00e4ytt\u00e4\u00e4 Visual Studio Codea. T\u00e4m\u00e4n k\u00e4ytt\u00f6\u00f6n tutustutaan l\u00e4sn\u00e4tunneilla.</p>"},{"location":"powershell/aloita/#skriptin-ajaminen","title":"Skriptin ajaminen","text":"<p>Skriptin voi ajaa monella tapaa. Tyypillinen tapa on relatiivinen polku. Koska me olemme samassa hakemistossa kuin skripti, relatiivinen polku on yksintaisesti <code>./&lt;tiedostonimi&gt;</code>:</p> <pre><code># Relatiivinen polku\n./hello.ps1\n</code></pre> <p>Absoluuttista polkua k\u00e4ytt\u00e4en:</p> <pre><code># Linux\n/root/hello.ps1\n\n# Windows\nC:\\Users\\user\\hello.ps1\n</code></pre> <p>Kyseisen bin\u00e4\u00e4rin argumenttina:</p> <pre><code># PowerShell Core\npwsh ./hello.ps1\n\n# Windows PowerShell\npowershell.exe ./hello.ps1\n</code></pre>"},{"location":"powershell/aloita/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: PowerShell Hello World</p> <p>Luo skriptitiedosto <code>hello.ps1</code>, joka tulostaa tekstin \"Hello World\". </p> <p>Varmista, ett\u00e4 saat sen ajettua ymp\u00e4rist\u00f6ss\u00e4, jossa koet kehitt\u00e4misen mieluisaksi. Saat k\u00e4ytt\u00e4\u00e4 fyysist\u00e4 konetta, virtuaalikonetta, Dockeria tai vastaavaa.</p> <p>Suositus: Docker</p> <p>Teht\u00e4v\u00e4: PowerShell informaatiohaku</p> <p>Toimi kuten aiemmassa Bash-tiedonhakuteht\u00e4v\u00e4ss\u00e4. Muodosta itsellesi hy\u00f6dyllinen katalogi l\u00e4hteist\u00e4. Alla muutama suositus, mist\u00e4 aloittaa etsint\u00e4:</p> <ol> <li>PowerShell Documentation. Virallinen dokumentaatio. Varmista, ett\u00e4 seuraat oikean version dokumentaatiota.</li> <li>Markus Fleschutzin PowerShell repo. Sis\u00e4lt\u00e4\u00e4 sek\u00e4 cheat sheetin ett\u00e4 satoja PowerShell-skriptej\u00e4.</li> <li>Learn PowerShell in Y Minutes. Cheat Sheet -tyylinen opas, josta selvi\u00e4\u00e4 ydinasiat.</li> <li>KAMK Finna. Hakusanalla \"PowerShell\" l\u00f6ytyy esimerkiksi Jonathan Hassellin kirja \"Learning PowerShell\" vuodelta 2017.</li> </ol> <p>My\u00f6s Bashin kohdalla mainitut kirjal\u00e4hteet eli KAMK Finna, Humble Bundlen ja O'Reillyn kirjasto ovat toimivia paikkoja etsi\u00e4 tietoa - j\u00e4lkimm\u00e4iset kaksi ovat toki maksullisia. Erityismaininnan arvoinen maksullinen kirja on Don Jones ja Jeffrey Hicksin Learn PowerShell Scripting in a Month of Lunches 2nd ed. (Manning).</p>"},{"location":"powershell/aloita/#lahteet","title":"L\u00e4hteet","text":"<ol> <li> <p>Microsoft. Introduction to .NET. https://learn.microsoft.com/en-us/dotnet/core/introduction\u00a0\u21a9</p> </li> <li> <p>Microsoft. Differences between Windows PowerShell 5.1 and PowerShell 7.x. https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell\u00a0\u21a9</p> </li> <li> <p>Schandevijl et. al. 2025. Learning PowerShell in Y Minutes. https://learnxinyminutes.com/powershell/\u00a0\u21a9</p> </li> </ol>"},{"location":"powershell/lukeminen/","title":"Lukeminen","text":""},{"location":"powershell/lukeminen/#mista-on-kyse","title":"Mist\u00e4 on kyse?","text":"<p>Aloitetaan jo olemassa olevien skriptien lukemisesta. On kovin tyypillist\u00e4, ett\u00e4 ohjelmiston asennuksen tai k\u00e4ytt\u00f6\u00f6noton yhteydess\u00e4 sinua neuvotaan ajamaan online-hostattu skripti. Tyypillisesti vaihe n\u00e4ytt\u00e4\u00e4 t\u00e4lt\u00e4:</p> PowerShell<pre><code># N\u00e4in\nInvoke-RestMethod -Uri https://example.com/install.ps1 | Invoke-Expression\n\n# Tai n\u00e4in\nInvoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://ohmyposh.dev/install.ps1'))\n</code></pre> <p>Jos olet ep\u00e4varma, mit\u00e4 komennot tekev\u00e4t, aja <code>Get-Help</code> kullekin cmdletille.</p> <p>Koska kehitt\u00e4j\u00e4yhteis\u00f6jen kirjoittamaa koodia on Internet pullollaan, niin tutustutaan n\u00e4ihin esimerkkien kautta.</p>"},{"location":"powershell/lukeminen/#esimerkkeja","title":"Esimerkkej\u00e4","text":""},{"location":"powershell/lukeminen/#scoop","title":"Scoop","text":"<p>Komentorivilt\u00e4 ajettava Scoop on ohjelmisto, joka asentaa ohjelmia Windowsille. Se on er\u00e4\u00e4nlainen vastine Linuxin <code>apt</code>- ja <code>yum</code>-paketinhallintaj\u00e4rjestelmille. Scoop asentaa hieman Linuxista tuttuun tapaan ohjelmia k\u00e4ytt\u00e4j\u00e4n kotihakemistoon. Vakiona ohjelmat asennetaan vain k\u00e4ytt\u00e4j\u00e4n scopeen. Scoopin asennus hoituu melko pitk\u00e4n PS1-scriptin avulla.</p> <p>Itse skripti l\u00f6ytyy: https://get.scoop.sh</p>"},{"location":"powershell/lukeminen/#chocolatey","title":"Chocolatey","text":"<p>Scoopin kilpailija Chocolatey on hyvin vastaava ohjelmisto Windowsille. Se on hieman erilainen, sill\u00e4 se on enemm\u00e4n pakettienhallintaj\u00e4rjestelm\u00e4 kuin ohjelmistojen asentaja. Toisin kuin Scoop, Chocolatey asentaa ohjelmia j\u00e4rjestelm\u00e4nlaajuisesti, perinteiseen Program Files lokaatioon.</p> <p>Itse skripti l\u00f6ytyy: https://community.chocolatey.org/install.ps1</p>"},{"location":"powershell/lukeminen/#oh-my-posh","title":"Oh My Posh","text":"<p>Oh My Posh on cross-platform teema- ja prompt-asetusten hallintaty\u00f6kalu PowerShellille (ja my\u00f6s muille shelliymp\u00e4rist\u00f6ille). Se on er\u00e4\u00e4nlainen vastine Zsh:n <code>oh-my-zsh</code>-teemalle. Sen voi asentaa Microsoftin ohjeiden mukaan wingetill\u00e4, mutta my\u00f6s suoraan skriptill\u00e4. T\u00e4h\u00e4n l\u00f6ytyy ohjeet Oh My Posh: Installation Windows -sivulta.</p> <p>Itse skripti l\u00f6ytyy: https://ohmyposh.dev/install.ps1</p>"},{"location":"powershell/lukeminen/#docker-build-script","title":"Docker Build Script","text":"<p>T\u00e4ll\u00e4 kurssilla k\u00e4ytetty <code>mcr.microsoft.com/powershell</code> Docker-image k\u00e4\u00e4nnet\u00e4\u00e4n PowerShell-skriptill\u00e4 CI/CD-automatisaation toimesta. Skripti on pitk\u00e4, mutta siit\u00e4 huolimatta uniikit syntaksinpalat ovat helppoja tunnistaa.</p> <p>Itse skripti l\u00f6yty: gh:PowerShell/PowerShell-Docker/build.ps1</p>"},{"location":"powershell/lukeminen/#kokoelmat","title":"Kokoelmat","text":"<p>Voit tutustua my\u00f6s Markus Fleschutzin kokoelmaan PowerShell-skriptej\u00e4 gh:fleschutz/PowerShell/. Repositoriosta l\u00f6ytyv\u00e4t skriptit ovat tyypillisesti huomattavasti lyhyempi\u00e4 kuin ylemm\u00e4t, joten jos parsit n\u00e4it\u00e4, niin parsi ainakin 5 kappaletta l\u00e4pi.</p>"},{"location":"powershell/lukeminen/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Parsi PowerShell-skripti</p> <p>Tee sama kuin teit Bashin vastaavassa teht\u00e4v\u00e4ss\u00e4. Valitse yll\u00e4 olevista skripteist\u00e4 yksi (tai monta, jos parsit kokoelman). Kirjoita yl\u00f6s l\u00f6yt\u00e4m\u00e4si syntaksin palaset, jotka ovat uniikkeja. Voit noudattaa samaa prosessia kuin Bashin vastaavassa teht\u00e4v\u00e4ss\u00e4:</p> <ol> <li>Lataa tiedosto: <code>curl -sSLf https://example.com/install.ps1 &gt; to-inspect.ps1</code></li> <li>Avaa Visual Studio Codessa: <code>code to-inspect.ps1</code></li> <li>Aloita tiedoston ylh\u00e4\u00e4lt\u00e4 ja prosessoi se rivi rivilt\u00e4.</li> </ol> <p>Tee seuraavat toimenpiteet jokaiselle koodiriville:</p> <ul> <li>\u2705 Jos koodirivi sis\u00e4lt\u00e4\u00e4 entuudestaan vierasta syntaksia: dokumentoi se. \ud83d\udcc4</li> <li>\ud83d\udd01 Jos koodirivin syntaksi on jo esiintynyt aiemmin scriptiss\u00e4: unohda rivi. \ud83e\udef3</li> <li>T\u00e4m\u00e4n j\u00e4lkeen poista kyseinen koodirivi tiedostosta.</li> </ul> <p>T\u00e4m\u00e4n pit\u00e4isi olla sinulle tuttua Bash-osuudesta.</p> <p>Ajans\u00e4\u00e4st\u00f6\u00e4 teko\u00e4lyll\u00e4! \ud83e\udd16</p> <p>T\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4 on suorastaan suositeltua k\u00e4ytt\u00e4\u00e4 teko\u00e4ly\u00e4 apuna selitt\u00e4m\u00e4\u00e4n, mit\u00e4 kyseiset Powershell-kielen entuudestaan tuntemattomat koodirimpsut tekev\u00e4t. Promptia muotoillessa kannattaa harkita Bash-osaamisesi esittely: kielimalli voi selitt\u00e4\u00e4 sinulle termej\u00e4 siten, ett\u00e4 se vertaa niit\u00e4 Bashin vastaaviin.</p>"},{"location":"python/31_gallium/","title":"\ud83d\udca1 Gallium","text":""},{"location":"python/31_gallium/#avainsanat","title":"Avainsanat","text":"<p>Aivan kuten Bashiss\u00e4 ja PowerShelliss\u00e4, my\u00f6s Pythonissa on varattuja sanoja, joita ei voi k\u00e4ytt\u00e4\u00e4 muuttujanimin\u00e4. T\u00e4ss\u00e4 on lista niist\u00e4:</p> <pre><code>False     None      True      and       as\nassert    async     await     break     class\ncontinue  def       del       elif      else\nexcept    finally   for       from      global\nif        import    in        is        lambda\nnonlocal  not       or        pass      raise\nreturn    try       while     with      yield\n</code></pre> <p>Lis\u00e4ksi on sis\u00e4\u00e4nrakennettuja funktioita, joita toki voit k\u00e4ytt\u00e4\u00e4 muuttujanimin\u00e4, mutta jyr\u00e4\u00e4t sivuoireena Pythonin toiminnallisuuksia. T\u00e4m\u00e4 ei siis ole suositeltavaa. N\u00e4it\u00e4 ovat:</p> <pre><code>abs           aiter         all           anext         any           ascii\nbin           bool          breakpoint    bytearray     bytes         callable\nchr           classmethod   compile       complex       copyright     credits\ndelattr       dict          dir           display       divmod        enumerate\neval          exec          execfile      filter        float         format\nfrozenset     get_ipython   getattr       globals       hasattr       hash\nhelp          hex           id            input         int           isinstance\nissubclass    iter          len           license       list          locals\nmap           max           memoryview    min           next          object\noct           open          ord           pow           print         property\nrange         repr          reversed      round         runfile       set\nsetattr       slice         sorted        staticmethod  str           sum\nsuper         tuple         type          vars          zip\n</code></pre> Kuinka tulostettiin? <p>Yll\u00e4 olevat listat on tulostettu seuraavalla skriptill\u00e4.</p> <pre><code>import keyword\nimport builtins\n\ndef print_as_tabular(words:list[str], columns:int=5, margin:int=2):\n\n    # Calculate variables\n    column_width = max([len(x) for x in words]) + margin\n\n    # Loop and print\n    for batch in range(0, len(words), columns):\n        row_words = words[batch:batch + columns]\n        for word in row_words:\n            print(f\"{word:&lt;{column_width}}\", end=\"\")\n        print()\n    print()\n\n\n# Print the reserved keywords\nprint_as_tabular(keyword.kwlist)\n\n# Print the built-ins\nlow_case_builtins = [x for x in dir(builtins) if x[0].islower()]\nprint_as_tabular(low_case_builtins, columns=6)\n</code></pre>"},{"location":"python/31_gallium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"python/31_gallium/#muuttujat","title":"Muuttujat","text":"<p>Koko totuus l\u00f6ytyy Pythonin dokumentaatiosta (esim. Built-In Types), mutta alla on pikaohje, jolla p\u00e4\u00e4set alkuun.</p>"},{"location":"python/31_gallium/#dynaaminen","title":"Dynaaminen","text":"<p>Aivan kuten PowerShell, my\u00f6s Python dynaamisesti tyypitetty kieli. Alla oleva esimerkki on sinulle hyvinkin tuttu PowerShellin puolelta:</p> <pre><code>x = 1                 # Kokonaisluku (class 'int')\nx = 3.12              # Liukuluku (class 'float')\nx = \"abc\"             # Merkkijono (class 'str')\nx = [1, 2, 3]         # Lista (class 'list')\nx = (1,2,3)           # Tuple (class 'tuple')\nx = {1,2,3}           # Set (class 'set')\nx = {\"a\": 1, \"b\": 2}  # Sanakirja (class 'dict')\nx = True              # Boolean (class 'bool')\nx = None              # NoneType (class 'NoneType')\n</code></pre> <p>KAMK:n opiskelijana olet k\u00e4ynyt mit\u00e4 todenn\u00e4k\u00f6isimmin Python Perusteet -kurssin, joten n\u00e4iden pit\u00e4isi olla sinulle tuttuja tyyppej\u00e4. Jos et ole varma, niin suosittelen kertaamaan materiaalia. Erityisesti listan, tuplen ja setin ero on hyv\u00e4 tunnistaa, koska ne muistuttavat toisiaan, mutta eroavat k\u00e4ytt\u00f6tarkoitukseltaan.</p>"},{"location":"python/31_gallium/#tyypittaminen","title":"Tyypitt\u00e4minen","text":"<p>Python ja PowerShell eroavat merkitt\u00e4v\u00e4sti toisistaan tyypityksen ja tyypin vaihtamisen suhteen. Muistat toivon mukaan PowerShellist\u00e4, ett\u00e4 muuttujan voi pakottaa tiettyyn tyyppin kirjoittamalla tyypin hakasulkeisiin ennen muuttujaa (esim. <code>[int]$x = \"42\"</code>). Pythonissa on vastaava syntaksi, mutta se on vain type hint dokumentaatiota varten, ei pakottava tyypitys. Alla esimerkki:</p> Python REPL<pre><code>&gt;&gt;&gt; x: int = 42\n&gt;&gt;&gt; x = \"thingy\"\n&gt;&gt;&gt; type(x)\n&lt;class 'str'&gt;\n</code></pre> <p>\ud83e\udd86 Terminologia</p> <p>Termi, jota k\u00e4ytet\u00e4\u00e4n Pythonin \u00e4\u00e4rimm\u00e4isen liberaalista tyypityksest\u00e4, on duck typing. Lause, johon kenties olet jo t\u00f6rm\u00e4nnyt, m\u00e4\u00e4rittelee sen n\u00e4in: If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p> <p>Pythonin tyypitys on siis vapaaehtoista, mutta se ei tarkoita, ett\u00e4 sit\u00e4 ei kannattaisi k\u00e4ytt\u00e4\u00e4. Kevyimmill\u00e4\u00e4n kannattaa m\u00e4\u00e4ritt\u00e4\u00e4 type hinting tyylill\u00e4. K\u00e4ytt\u00e4m\u00e4si IDE, kuten Visual Studio Code lis\u00e4osineen, osaa hy\u00f6dynt\u00e4\u00e4 t\u00e4t\u00e4 tietoa ja tarjota parempaa koodiautomaatiota ja -tarkistusta.</p> \u26d4\ufe0f Ei n\u00e4in<pre><code>def add(a, b):\n    return a + b\n\na = 2\nb = 3\nprint(add(a, b))\n</code></pre> \u2705 N\u00e4in<pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n\na: int = 2\nb: int = 3\nprint(add(a, b))\n</code></pre>"},{"location":"python/31_gallium/#ulkoista-apua","title":"Ulkoista apua","text":"<p>Dynaaminen tyypitys ei ole kaikkien mieleen, ja se altistaa koodin virheille, jotka voitaisiin havaita staattisella tyypityksell\u00e4. Tyyppivirheisiin perustuvat bugit ovat usein vaikeita l\u00f6yt\u00e4\u00e4 ja korjata. T\u00e4m\u00e4n vuoksi on olemassa ty\u00f6kaluja, jotka tarkistavat koodin tyypityksen ennen sen suorittamista. Visual Studio Codessa on Microsoftin yll\u00e4pit\u00e4m\u00e4 ja t\u00e4ten hyvinkin virallinen lis\u00e4osa Python, jonka mukana asentuu vakiona Pylance. J\u00e4lkimm\u00e4isen voi vaihtaa sen tuoreeseen kilpailijaan nimelt\u00e4\u00e4n Ruff tai mypy.</p> <p>Tutustumme Visual Studion Coden asetuksiin tarkemmin live-tunneilla. T\u00e4ss\u00e4 materiaalissa neuvotaan ty\u00f6kalujen k\u00e4ytt\u00f6 Dockerin avulla yht\u00e4 skripti\u00e4 vasten.</p> <p>Aloitetaan ty\u00f6kalulla nimelt\u00e4\u00e4n mypy.</p> <pre><code># Run mypy against a single script\ndocker run --rm -v $(pwd):/data:ro cytopia/mypy scripts/hello_turbo.py\n\n# Or maybe with a strict mode to be more pedantic\ndocker run --rm -v $(pwd):/data:ro cytopia/mypy --strict scripts/hello_turbo.py\n</code></pre> <p>Tuore haastaja Python-ekosysteemiss\u00e4 on Astral, jonka ty\u00f6kalu Ruff toimii sek\u00e4 linterin\u00e4 ett\u00e4 formatterina. Linter tarkistaa koodin virheist\u00e4 ja formatter muotoilee koodin yhten\u00e4iseen tyyliin. Sit\u00e4 voit k\u00e4ytt\u00e4\u00e4 Dockerin kautta n\u00e4in:</p> <pre><code># Tarkista virheet\ndocker run --rm -v $(pwd):/io ghcr.io/astral-sh/ruff:latest check scripts/hello_turbo.py\n\n# Korjaa automaattisesti virheet (1)\ndocker run --rm -v $(pwd):/io ghcr.io/astral-sh/ruff:latest check scripts/hello_turbo.py --fix\n\n# Muotoile teksti vakiotyyliin\ndocker run --rm -v $(pwd):/io ghcr.io/astral-sh/ruff:latest format scripts/hello_turbo.py\n</code></pre> <p>Warning</p> <p>Ruff-komennot ajetaan ilman <code>:ro</code> eli read-only volumea. Ruff tarvitsee kirjoitusoikeudet muokatakseen tiedostoa ja luodakseen v\u00e4liaikaisia tiedostoja. N\u00e4m\u00e4 tiedostot ilmestyv\u00e4t <code>.ruff_cache</code>-hakemistoon. Kylki\u00e4isen\u00e4 tulee <code>.gitignore</code>-tiedosto, joka est\u00e4\u00e4 n\u00e4iden tiedostojen p\u00e4\u00e4tymisen versionhallintaan.</p>"},{"location":"python/31_gallium/#vianetsinta","title":"Vianetsint\u00e4","text":""},{"location":"python/31_gallium/#print","title":"Print","text":"<p>Bashist\u00e4 ja PowerShellist\u00e4 tuttu <code>echo</code>-komennon vastine Pythonissa on <code>print</code>. Hyvin primitiivinen, mutta silti tehokas tapa debugata koodia on tulostaa muuttujien arvoja konsoliin.</p> <pre><code>user_input = input(\"Give me a number: \")\nprint(f\"User input was: {user_input}\")\n</code></pre>"},{"location":"python/31_gallium/#assert","title":"Assert","text":"<p>On tilanteita, joissa haluat skriptin kaatuvan, jos jokin ehto ei t\u00e4yty. T\u00e4m\u00e4 onnistuu <code>assert</code>-lausekkeella. Alla esimerkki:</p> <pre><code>x = 1\nassert x == 2, \"x should be 2\"\n</code></pre>"},{"location":"python/31_gallium/#logging","title":"Logging","text":"<p>Toivon mukaan muistat yh\u00e4 PowerShellin puolelta eri virrat, joihin pystyy kirjoittamaan viestej\u00e4. Pythonissa vastaava toiminnallisuus l\u00f6ytyy <code>logging</code>-moduulista. Alla esimerkki:</p> logger_practice.py<pre><code>import logging\nimport random\n\n\ndef pick_random_level() -&gt; int:\n    level = random.choice(\n        [\n            logging.DEBUG,\n            logging.INFO,\n            logging.WARNING,\n            logging.ERROR,\n            logging.CRITICAL,\n        ]\n    )\n\n    name = logging._levelToName[level]\n    print(f\"Randomly chosen level: {name} (no. {level})\")\n    return level\n\n\n# Set the logging level and format\nrnd_level = pick_random_level()\nFORMAT: str = \"%(asctime)s - %(levelname)s - %(message)s\"\nlogging.basicConfig(level=rnd_level, format=FORMAT, datefmt=\"%H:%M:%S\")\n\n# Call each level once\nlogging.critical(\"DON'T PANIC!\")\nlogging.warning(\"It worked on my machine...\")\nlogging.error(\"Have you tried turning it off and on again?\")\nlogging.info(\"Must be a cosmic ray. Try running it again.\")\nlogging.debug(\"I'm sure it's just a typo.\")\n</code></pre> <p>Skripti arpoo satunnaisen loggaustason ja tulostaa viestin jokaisella tasolla. Vain valitun tason ylitt\u00e4v\u00e4t viestit tulostuvat konsoliin. Alla esimerkki skriptin ajosta:</p> <pre><code>$ ./runpy.py scripts/logger_practice.py\nRandomly chosen level: INFO (no. 20)\n11:24:23 - CRITICAL - DON'T PANIC!\n11:24:23 - WARNING - It worked on my machine...\n11:24:23 - ERROR - Have you tried turning it off and on again?\n11:24:23 - INFO - Must be a cosmic ray. Try running it again.\n</code></pre>"},{"location":"python/31_gallium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Devausymp\u00e4rist\u00f6 ja runpy.py <p>Loit ajo aiemmassa teht\u00e4v\u00e4ss\u00e4 <code>python/</code>-hakemiston, jotta sait kopioitua skriptin avulla virtuaalikoneesta kaikki Python-srkriptit sinun host-koneellesi. Jatketaan saman hakemiston k\u00e4ytt\u00f6\u00e4, mutta Multipass-koneen sijaan k\u00e4ytet\u00e4\u00e4n Docker-konttia. Lis\u00e4ksi Bash-skriptin sijasta k\u00e4yt\u00e4mme Python-skripti\u00e4. Vaiheet:</p> <ol> <li>Lataa gh:sourander/skriptiohjelmointi/exercise-assets/scripts/runpy.py</li> <li>Tee tiedostosta ajettava (tai aja jatkossa <code>python runpy.py</code>)</li> <li>Lue tiedoston sis\u00e4lt\u00f6 l\u00e4pi ja selvit\u00e4, mit\u00e4 se tekee.</li> </ol> <p>Referenssiksi hakemistorakenteen kuuluisi olla:</p> <pre><code>johnanderton\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 bash\n\u2502   \u2514\u2500\u2500 .gitkeep \n\u251c\u2500\u2500 pwsh\n\u2502   \u2514\u2500\u2500 .gitkeep \n\u2514\u2500\u2500 python\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 getscripts.sh\n    \u2514\u2500\u2500 scripts\n        \u2514\u2500\u2500 hello.py  # &lt;= Seuraava teht\u00e4v\u00e4!\n</code></pre> Teht\u00e4v\u00e4: Python Hello World <p>Luo skripti <code>hello.py</code>, joka tulostaa konsoliin <code>Hello, World!</code>. Aja sitten:</p> <pre><code>$ ./runpy.py --dryrun scripts/hello.py\n[DRY] Cmd that would run: LUE T\u00c4M\u00c4 OUTPUT!!\n\n$ ./runpy.py scripts/hello.py\nHello, World!\n\n$ ./runpy.py --bash --dryrun\n[DRY] Cmd that would run: LUE T\u00c4M\u00c4 OUTPUT!!\n\n$ ./runpy.py --bash\n# python3 /app/scripts/hello.py\nHello, World!\n</code></pre> <p>Huomaa, ett\u00e4 tiedoston ei tarvitse olla executable, koska kontin sis\u00e4ll\u00e4 ajetaan komento <code>python &lt;tiedosto&gt;</code> eik\u00e4 <code>./&lt;tiedosto&gt;</code>.</p> Teht\u00e4v\u00e4: Python Turboahdettu Hello World <p>Luo skripti, joka tulostaa:</p> <ul> <li>absoluuttinen polku ty\u00f6hakemistoon</li> <li>absoluuttinen polku skriptin sijaintiin</li> <li>polut, joista Python etsii moduuleja</li> </ul> <p>Tiedoston tulisi alkaa n\u00e4in:</p> hello_turbo.py<pre><code>#!/usr/bin/env python3\n\n# Implement\n</code></pre> <p>Alla esimerkkik\u00e4ytt\u00f6 Dockerin kanssa:</p> <pre><code>$ runpy.py scripts/hello_turbo.py\n\n========= Turbo Hello World! =========\nCurrent working dir:          : /app\nSkriptin sijainti:            : /app/scripts/hello_turbo.py\nPython moduulien hakupolut:\n    /app/scripts\n    /usr/local/lib/python312.zip\n    /usr/local/lib/python3.12\n    /usr/local/lib/python3.12/lib-dynload\n    /usr/local/lib/python3.12/site-packages\n</code></pre> <p>Ja t\u00e4ss\u00e4 viel\u00e4 Multipassin kanssa:</p> <pre><code>$ multipass launch --name helloturbo 24.04\n$ multipass transfer scripts/hello_turbo.py helloturbo:.\n$ multipass exec helloturbo -- python3 hello_turbo.py\n========= Turbo Hello World! =========\nCurrent working dir:          : /home/ubuntu\nSkriptin sijainti:            : /home/ubuntu/hello_turbo.py\nPython moduulien hakupolut:\n    /home/ubuntu\n    /usr/lib/python312.zip\n    /usr/lib/python3.12\n    /usr/lib/python3.12/lib-dynload\n    /usr/local/lib/python3.12/dist-packages\n</code></pre> Vinkki: Moduulit <p>Katso, mit\u00e4 <code>sys.path</code> sis\u00e4lt\u00e4\u00e4. Huomaa, ett\u00e4 <code>sys</code>-moduuli pit\u00e4\u00e4 importoida ensin.</p> Teht\u00e4v\u00e4: Interaktiivinen Python <p>Harjoittele t\u00e4ss\u00e4 teht\u00e4v\u00e4ss\u00e4 interaktiivista Python Shelli\u00e4 eli REPL:i\u00e4 kontin sis\u00e4ll\u00e4. Saat sen auki ajamalla aiemmin lataamasi <code>runpy.py</code>-skriptin ilman argumentteja. Kokeile seuraavia:</p> <ol> <li>Laske 2+2</li> <li>Luo muuttuja <code>x</code> ja anna sille arvoksi 42</li> <li>Tulosta muuttujan <code>x</code> arvo</li> <li>Luo lista <code>lista</code> ja anna sille arvoksi <code>[1, 2, 3]</code></li> <li>Tulosta listan <code>lista</code> arvot</li> </ol> <pre><code>$ runpy.py\nPython 3.1x.x (main, ...) [GCC xx.x.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; # T\u00e4ss\u00e4 voit kirjoittaa Python-koodia\n</code></pre> <p>Kun olet valmis, voit poistua painamalla <code>Ctrl+D</code> tai kirjoittamalla <code>exit()</code>.</p> <p>Miksi REPL?</p> <p>Interaktiivinen Python on hyv\u00e4 tapa kokeilla nopeasti koodinp\u00e4tki\u00e4 ja testata, miten Python toimii. Materiaalin kirjoittanut opettaja k\u00e4ytt\u00e4\u00e4 sit\u00e4 usein my\u00f6s nopeana laskimena.</p> Teht\u00e4v\u00e4: Interaktiivinen Python Pt. 2 <p>\u00c4\u00e4rimm\u00e4isen n\u00e4pp\u00e4r\u00e4 komento lyhyit\u00e4 skriptej\u00e4 debugatessa on <code>-i</code>-flagi, joka j\u00e4tt\u00e4\u00e4 Pythonin auki skriptin suorituksen j\u00e4lkeen interaktiiviseen tilaan. Dokumentaatiossa se on m\u00e4\u00e4ritelty n\u00e4in: \"When a script is passed as first argument (...) enter interactive mode after executing the script (...)\" <sup>1</sup>. Lokaalisti ajettuna se olisi n\u00e4inkin helppoa:</p> <pre><code>$ python -i scripts/hello_turbo.py\n</code></pre> <pre><code>$ ./runpy.py --dryrun --interactive scripts/hello_turbo.py\n[DRY] Cmd that would run: LUE T\u00c4M\u00c4 OUTPUT!!\n\n$ ./runpy.py --interactive scripts/hello_turbo.py\n========= Turbo Hello World! =========\nCurrent working dir:          : /app\nSkriptin sijainti:            : /app/scripts/hello_turbo.py\nPython moduulien hakupolut:\n    /app/scripts\n    /usr/local/lib/python312.zip\n    /usr/local/lib/python3.12\n    /usr/local/lib/python3.12/lib-dynload\n    /usr/local/lib/python3.12/site-packages\n&gt;&gt;&gt;\n</code></pre> <p>Mit\u00e4 me voitimme? Sinulla on kaikki skriptiss\u00e4 importatut moduulit k\u00e4yt\u00f6ss\u00e4, kuten my\u00f6s muuttujat ja funktiot. T\u00e4m\u00e4 on yksi monista vaihtoehdoista debugata ja/tai kehitt\u00e4\u00e4 skriptej\u00e4. Kukin skriptaaja l\u00f6yt\u00e4\u00e4 oman tyylins\u00e4, joka sopii parhaiten omaan tapaansa ty\u00f6skennell\u00e4 \u2013 on kuitenkin hyv\u00e4 tuntea vaihtoehdot eik\u00e4 tarttua ensimm\u00e4iseen. Omia ty\u00f6skentelytapojaan kannattaa my\u00f6s jatkuvasti haastaa ja kehitt\u00e4\u00e4.</p> Teht\u00e4v\u00e4: Tiedostoon loggaus <p>Ota mallia yll\u00e4 olevasta <code>logger_practice.py</code>-skriptist\u00e4 ja luo oma skripti, joka loggaa viestit konsolin sijasta tiedostoon (esim. <code>logger_practice.log</code>). Pythonin oma Logging HOWTO on hyv\u00e4 paikka aloittaa.</p> <p>Tip</p> <p>Huomaa, ett\u00e4 jos ajat skripti\u00e4 kontin sis\u00e4ll\u00e4, niin tiedosto tallentuu kontin sis\u00e4lle. Eth\u00e4n yrit\u00e4 tallentaa tiedostoa <code>/app</code>-hakemistoon, koska se on read-only. Voit tallentaa tiedoston esimerkiksi <code>/tmp</code>-hakemistoon.</p> <p>Muista my\u00f6s, ett\u00e4 kontti on v\u00e4liaikainen, joten tiedosto katoaa, kun kontti tuhotaan. On kannattavaa ajaa kontti siten, ett\u00e4 CMD on bash, ja k\u00e4yt suorittamassa skriptin k\u00e4sin. Eli siis:</p> \ud83d\udda5\ufe0f Bash<pre><code>$ ./runpy.py --bash\n</code></pre> <p>...joka avaa bashin kontin sis\u00e4ll\u00e4. T\u00e4m\u00e4n j\u00e4lkeen voit ajaa skriptin k\u00e4sin ja k\u00e4yd\u00e4 tarkistamassa, ett\u00e4 tiedosto on luotu.</p> \ud83d\udc33 Bash<pre><code># python3 /app/scripts/logger_practice.py\n</code></pre> Teht\u00e4v\u00e4: Ruff <p>Yll\u00e4 on esitelty Ruff-ty\u00f6kalun k\u00e4ytt\u00f6 Docker-kontissa. K\u00e4yt\u00e4 sit\u00e4 ja korjaa kaikkien tiedostojen virheet (sek\u00e4 check ett\u00e4 format), jotka olet t\u00e4h\u00e4n asti luonut <code>scripts/</code>-hakemistoon.</p> <p>Saat k\u00e4ytt\u00e4\u00e4 parhaaksi katsomallasi tavalla joko Dockerissa ajettua Ruffia, lokaalisti asettua Ruff:ia (esim. <code>uv tool install ruff</code>) tai Visual Studio Coden lis\u00e4osaa. Docker on helpoin, koska se on neuvottu yll\u00e4. Muita varten sinun tarvitsee ottaa omatoimisesti selv\u00e4\u00e4.</p> <p>Warning</p> <p>Muista ottaa t\u00e4m\u00e4 tavaksi jatkossa! On oletus, ett\u00e4 kurssilla kirjoittamasi skriptit l\u00e4p\u00e4isev\u00e4t Ruffin tarkistukset. Kenties haluat kirjoittaa skriptin, joka ajaa pitk\u00e4n Docker-komennon puolestasi? \ud83e\udd14</p>"},{"location":"python/31_gallium/#lahteet","title":"L\u00e4hteet","text":"<ol> <li> <p>Python Docs. Command line and environment. https://docs.python.org/3/using/cmdline.html#cmdoption-i\u00a0\u21a9</p> </li> </ol>"},{"location":"python/38_strontium/","title":"\ud83c\udf86 Strontium","text":""},{"location":"python/38_strontium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"python/38_strontium/#format-operator","title":"Format Operator","text":"<p>Pythonin f-string on tehokas tapa formatoida merkkijonoja. Se on ollut k\u00e4yt\u00f6ss\u00e4 Python 3.6:sta l\u00e4htien. F-stringin avulla voit lis\u00e4t\u00e4 muuttujia suoraan merkkijonoon. F-stringin tunnistaa siit\u00e4, ett\u00e4 merkkijonon alkuun tulee <code>f</code>-kirjain. Esimerkiksi:</p> <pre><code>name = \"John\"\nage = 42\n\nprint(f\"My name is {name} and I am {age} years old.\")\n</code></pre> <p>Huomaa, ett\u00e4 yksinkertaisen muuttujan ujuttamisen lis\u00e4ksi f-string sallii uskomattoman m\u00e4\u00e4r\u00e4n muotoilua, ja tyypillisen Python-lausekkeen k\u00e4yt\u00f6n. Esimerkiksi:</p> <pre><code>print(f\"2 + 2 = {2 + 2}\")\nprint(f\"216 can be written as hex {216:X} and as binary {216:b}\")\n</code></pre> <p>Voit tutustua t\u00e4h\u00e4n muotoiluun Python f-string cheat sheets -sivuston avulla tai suoraan Python Docs: String &gt; Format String Syntax.</p>"},{"location":"python/38_strontium/#mukavuus","title":"Mukavuus","text":""},{"location":"python/38_strontium/#visual-studio-coden-kaytto","title":"Visual Studio Coden k\u00e4ytt\u00f6","text":"<p>Mukavuus-otsikon alla on oletus, ett\u00e4 sinulla on k\u00e4yt\u00f6ss\u00e4 Visual Studio Code, Python Extension ja lokaalisti asennettu Python 3.1x. Python voi olla Ubuntun mukana tullut, Python.org-sivustolta ladattu, uv-ty\u00f6kalulla asennettu tai jokin muu. T\u00e4rkeint\u00e4 on, ett\u00e4 Python on lis\u00e4tty k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4si PATH:iin ja on t\u00e4ten ajettavissa terminaalista komennolla <code>python</code> tai <code>python3</code>.</p>"},{"location":"python/38_strontium/#venv","title":"Venv","text":"<p>Warning</p> <p>Pythonin virtuaaliymp\u00e4rist\u00f6t eiv\u00e4t ole maailman helpoin aihe. Tulethan l\u00e4sn\u00e4tunneille paikalle, jotta saat t\u00e4h\u00e4n tukea ja neuvoja!</p> <p>Kun luot uudet Python-projektin Visual Studio Codessa, sinulla voi olla tarve asentaa joitakin moduuleita. Olet jo aiemmin oppinut, ett\u00e4 Debian-pohjaisessa ymp\u00e4rist\u00f6ss\u00e4 on <code>dist-packages</code>-hakemisto, jossa on esimerkiksi <code>requests</code>-moduuli asennettuna. Jos olet jossakin toisesssa k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4ss\u00e4 tai jakelussa, se voi hyvin puuttua sinulta. T\u00e4ss\u00e4 tapauksessa tarvitset virtuaaliymp\u00e4rist\u00f6n.</p> <p>Virtuaaliymp\u00e4rist\u00f6 kuulostanee monimutkaiselta, mutta k\u00e4yt\u00e4nn\u00f6n tasolla se on kopio Python-asennuksesta. Luo se <code>uv</code>:n avulla:</p> uvWindows (vain h\u00e4t\u00e4tilanteessa) <p>Jos sinulla on uv, k\u00e4yt\u00e4 ihmeess\u00e4 sit\u00e4! Jos ei ole, asenna se. Asennus vaatii yhden komennon ajamisen, joka l\u00f6ytyy  Uv uv:n etusivulta. Ty\u00f6kalu toimii Windowsissa, Linuxissa ja macOS:ss\u00e4 samoin tavoin.</p> \ud83d\udda5\ufe0f Bash<pre><code># Varmista, ett\u00e4 olet projektisi hakemistossa\n$ cd mene/sinun/projektisi/hakemistoon\n\n# Mene ALIHAKEMISTOON python/\n$ cd python\n\n# Asenna haluamasi Python\n$ uv install 3.12\n$ uv pin 3.12\n$ uv init --name \"skriptiohjelmointi\" --bare --app .\n\n# Asenna virtuaaliymp\u00e4rist\u00f6\u00f6n requests\n$ uv add requests\n\n# Aja uv:n hallinnoima Python\n$ uv python scripts/hello.py\n</code></pre> <p>Tutustu syntyneisiin tiedostoihin, kuten <code>.python-version</code> ja <code>pyproject.toml</code>. Kysy opettajalta apua, jos jokin asia askarruttaa.</p> <p>Jos sinulla on Windowsiin asennettuna Python 3.xx, etk\u00e4 jostain syyst\u00e4 saa uv:ta asennettua, voit k\u00e4ytt\u00e4\u00e4 Python-osion teht\u00e4viss\u00e4 <code>venv</code>-moduulia. My\u00f6hemmin Ansible-osiossa k\u00e4ytet\u00e4\u00e4n kuitenkin <code>uv</code>:ta Linuxissa, joten tee t\u00e4m\u00e4 vain jos ei ole muita vaihtoehtoja!. Jos sinulla on <code>uv</code> tai mahdollisuus asentaa se, valitse ylh\u00e4\u00e4lt\u00e4 <code>uv</code>-v\u00e4lilehti.</p> \ud83d\udda5\ufe0f PowerShell<pre><code># Varmista, ett\u00e4 olet projektisi hakemistossa\nPS&gt; cd mene/sinun/projektisi/hakemistoon\n\n# Mene ALIHAKEMISTOON python/\nPS&gt; cd python\n\n# Suositeltu: kiell\u00e4 pip:n k\u00e4ytt\u00f6 virtuaaliymp\u00e4rist\u00f6n ulkopuolella\nPS&gt; pip3 config set global.require-virtualenv true\n\n# Luo virtuaaliymp\u00e4rist\u00f6\nPS&gt; python3 -m venv .venv\n\n# Aktivoi virtuaaliymp\u00e4rist\u00f6\nPS&gt; .venv\\Scripts\\Activate.ps1\n\n# Asenna haluamasi moduulit\n(.venv) PS&gt; pip install requests\n\n# Aja Python\n(.venv) PS&gt; python scripts/hello.py\n\n# Deaktivoi virtuaaliymp\u00e4rist\u00f6\n(.venv) PS&gt; deactivate\n</code></pre> <p>Muista Git Ignore!</p> <p>Eth\u00e4n unohda lis\u00e4t\u00e4 kyseist\u00e4 hakemistoa <code>.gitignore</code>-tiedostoon, jotta se ei p\u00e4\u00e4dy versionhallintaan! Se on kopio Pythonista, joten se sis\u00e4lt\u00e4\u00e4 satoja bin\u00e4\u00e4ritiedostoja, jotka eiv\u00e4t todellakaan kuulu versionhallintaan. Kukin k\u00e4ytt\u00e4j\u00e4 luo oman virtuaaliymp\u00e4rist\u00f6ns\u00e4 itse.</p> <p>Lis\u00e4\u00e4 siis seuraava rivi <code>.gitignore</code>-tiedostoon:</p> <pre><code>.venv/\n</code></pre> <p>Tarkista, ett\u00e4 tiedostoja ei n\u00e4y versionhallinnassa komennolla <code>git status -u</code>.</p> <p>Huomaa, ett\u00e4 on kaksi eri asiaa: k\u00e4ytt\u00e4\u00e4 virtuaaliymp\u00e4rist\u00f6\u00e4 shell-istunnossa ja Visual Studio Coden GUI:ssa. Visual Studio Code yleens\u00e4 havaitsee, jos luot virtuaaliymp\u00e4rist\u00f6n, mutta ei aina. Visual Studio Code saattaa my\u00f6s jatkossa aktivoida sen automaattisesti shell-istuntoon, mutta t\u00e4m\u00e4 riippuu asetuksesta:</p> $HOME/.config/Code/User/settings.json<pre><code>{\n    // ...\n    \"python.terminal.activateEnvironment\": false,\n    // ...\n}\n</code></pre> <p>Sen sijaan VS Coden GUI-editorin, eli ei siis integroidun terminaalin, k\u00e4ytt\u00e4m\u00e4 Python on valittavissa painamalla <code>F1</code> ja kirjoittamalla <code>Python: Select Interpreter</code>. Yleens\u00e4 VS Code avaa alla n\u00e4kyv\u00e4n (ks. Kuva 1) pop-up -ikkunan ruudun oikeaan alalaitaan kun olet luonut virtuaaliymp\u00e4rist\u00f6n. Jos t\u00e4m\u00e4 popup menee sinulta ohi syyst\u00e4 tai toisesta, voit valita Workspace-kohtaisen virtuaaliymp\u00e4rist\u00f6n painamalla <code>F1</code> ja kirjoittamalla <code>Python: Select Interpreter</code>. Kentt\u00e4\u00e4n voi kirjoittaa relatiivisen polun projektin uudesta esimerkiksi n\u00e4in: <code>${workspaceFolder}/python/.venv/</code>. T\u00e4m\u00e4 polun k\u00e4sin kirjoittaminen on tarpeen vain, jos executable on jossakin muualle kuin avoinna olevan kansion juuressa (kuten <code>python/.venv</code> eik\u00e4 <code>.venv/</code>).</p> <p></p> <p>Kuva 1: Visual Studio Code ilmoittaa, ett\u00e4 se on havainnut uuden virtuaaliymp\u00e4rist\u00f6n, ja tarjoaa sinun valita sen kyseist\u00e4 worskpacea varten. Klikkaa Yes.</p>"},{"location":"python/38_strontium/#intellisense","title":"Intellisense","text":"<p>Aivan kuten PowerShell, my\u00f6s Python on hyvin vahvasti object-oriented -kieli. T\u00e4m\u00e4 tarkoittaa, ett\u00e4 Pythonissa kaikki on objekteja, ja objekteilla on metodeja ja ominaisuuksia. Olet jo kokeillut samaa ominaisuutta PowerShellin kanssa, mutta kokeile uusiksi Pythonin kanssa. Luo esimerkiksi seuraava skripti:</p> testing_context_menu.py<pre><code>name = \"John Anderton\"\nname\n</code></pre> <p>Kun lis\u00e4\u00e4t sanan <code>name</code> per\u00e4\u00e4n viel\u00e4 pisteen, aukeaa lista objektin metodeista ja ominaisuuksista. Kokeile esimerkiksi <code>name.upper()</code>. Jos lista ei aukea, paina Ctrl+Space. Huomaa, ett\u00e4 IntelliSense k\u00e4ytt\u00e4\u00e4 sit\u00e4 Python-versiota, joka on valittu Visual Studio Codessa. T\u00e4m\u00e4 neuvotaan yll\u00e4.</p> <p>\ud83c\udf4e macOS</p> <p>Sama pikan\u00e4pp\u00e4in on Fn+Ctrl+Space</p>"},{"location":"python/38_strontium/#run-selection","title":"Run Selection","text":"<p>Joskus voi olla tarpeen ajaa valittu koodinp\u00e4tk\u00e4 lokaalin koneen terminaalissa. Kenties haluat nopeasti kokeilla, kuinka keskell\u00e4 pitk\u00e4\u00e4 skripti\u00e4 m\u00e4\u00e4ritelty funktio toimii ajamatta muuta koodia? T\u00e4m\u00e4 onnistuu Visual Studio Codessa valitsemalla koodinp\u00e4tk\u00e4 ja painamalla Shift+Enter. Vaiheoehtoinen tapa on context menu. Klikkaa hiiren oikealla korvalla valittuja koodirivej\u00e4, valitse Run Python &gt; ja Run Selection/Line in Python Terminal.</p> <p></p> <p>Kuva 2: Skripist\u00e4 on valittuna vain yksi funktio, <code>function_i_wanna_test</code>, ja se ajetaan terminaalissa.</p> <p>Kun ajat koodin n\u00e4in, huomaat, ett\u00e4 alle Terminal-kohtaan ilmestyy uusi Python-niminen terminaali, jossa koodi suoritetaan REPL-tilassa. T\u00e4m\u00e4 on vastaava tapa kuin ajaa aiemmin n\u00e4kem\u00e4si <code>python -i scripts/some.py</code>, mutta voit valita juuri ne rivit, jotka haluat suoritettavaksi. Kuten alla olevasta snippetist\u00e4 n\u00e4et, funktio on jatkossa kutsuttavissa kyseisess\u00e4 terminaalissa.</p> \ud83d\udda5\ufe0f Python REPL (VS Code Terminal)<pre><code>&gt;&gt;&gt; function_i_wanna_test([1,2,3,4,5,6], 3)\n([1, 2], [3, 4, 5, 6])\n</code></pre>"},{"location":"python/38_strontium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Arvaa numero <p>Luo ohjelma, joka generoi luvun v\u00e4lilt\u00e4 1-1000 ja pyyt\u00e4\u00e4 k\u00e4ytt\u00e4j\u00e4\u00e4 arvaamaan sen. Ohjelma antaa vihjeen, onko arvattu luku suurempi vai pienempi kuin generoitu luku. Ohjelma lopettaa, kun k\u00e4ytt\u00e4j\u00e4 arvaa oikein. Olet tehnyt ohjelman jo aiemmin (Bash ja PowerShell), joten voit lainata sielt\u00e4 logiikan.</p> <pre><code>$ ./runpy.py scripts/arvaaluku.py\nArvaa luku v\u00e4lilt\u00e4 1-1000.\nMuu sy\u00f6te kuin positiviinen kokoluku poistuu ohjelmasta.\n\nSy\u00f6t\u00e4 arvaus:\n9\n\ud83d\udcc9 Luku on pienempi kuin 9.\n\nSy\u00f6t\u00e4 arvaus:\n7\n\ud83d\udcc8 Luku on suurempi kuin 7.\n\nSy\u00f6t\u00e4 arvaus:\n8\n\ud83c\udf89 Oikein! Arvasit luvun 8. (Peliaika: 0h 4m 18s)\n</code></pre> <p>Varmista, ett\u00e4 pelaaja voi halutessaan lopettaa pelin. Minun toteutuksessa mik\u00e4 tahansa muu sy\u00f6te kuin kokonaisluvuksi parsittava sy\u00f6te lopettaa pelin (esim. exit tai tyhj\u00e4 merkkijono).</p> <p>\u26a0\ufe0f T\u00c4RKE\u00c4\u00c4</p> <p>Kirjoita ohjelman <code>input()</code> ilman promptia. Anna prompti erillisell\u00e4 print-komennolla. T\u00e4m\u00e4 helpottaa kurssin my\u00f6hemp\u00e4\u00e4 teht\u00e4v\u00e4\u00e4, jossa rakennamme skriptin, joka pelaa peli\u00e4 meid\u00e4n puolestamme. Eli siis:</p> <pre><code># \u26d4\ufe0f Ei n\u00e4in\nguess = input(\"Guess a number: \")\n\n# \u2705 Vaan n\u00e4in\nprint(\"Guess a number: \")\nguess = input()\n</code></pre> Teht\u00e4v\u00e4: Reminder <p>T\u00e4m\u00e4n pit\u00e4isi olla sinulle jo tuttua. Luo kaksi ohjelmaa, jotka toimivat yhdess\u00e4. Toinen luo, toinen n\u00e4ytt\u00e4\u00e4 muistiinpanoja. Lis\u00e4ksi on olemassa apuohjelma, joka lis\u00e4\u00e4 n\u00e4m\u00e4 PATH:iin.</p> <ul> <li><code>install_reminder.py</code><ul> <li>Lis\u00e4\u00e4 <code>remind</code> ja <code>remember</code> symboliset linkit PATH:iin.</li> </ul> </li> <li><code>remember</code><ul> <li>Kysyy k\u00e4ytt\u00e4j\u00e4lt\u00e4 muistutuksia, jotka tallennetaan <code>~/.reminder</code>-tiedostoon.</li> <li>Tyhj\u00e4 sy\u00f6te lopettaa ohjelman.</li> <li>Formaatti: <code>[YYYY-MM-DD HH:MM] Muistutus</code></li> </ul> </li> <li><code>remind</code><ul> <li>Tulostaa muistutukset</li> <li>Antaa mahdollisuuden poistaa muistutuksia TUI-k\u00e4ytt\u00f6liittym\u00e4ll\u00e4.</li> </ul> </li> </ul> <p>K\u00e4yt\u00e4 TUI:n (Text User Interface) luomiseen <code>curses</code>-moduulia. Moduuli tulee Pythonin mukana Unix-like -j\u00e4rjestelmiss\u00e4, joten sit\u00e4 ei tarvitse asentaa erikseen.</p> <p>Lopulta k\u00e4ytt\u00f6 n\u00e4ytt\u00e4\u00e4 t\u00e4lt\u00e4, kun komennot ajetaan kontin sis\u00e4ll\u00e4 (<code>python runpy.py --bash</code>):</p> <p>\ud83d\udc33 Bash<pre><code># python scripts/install_reminder.py\nCreated symbolic link: /usr/local/bin/remind -&gt; /app/scripts/remind.py\nCreated symbolic link: /usr/local/bin/remember -&gt; /app/scripts/remember.py\n\n# remember\nEnter a reminder: Learn Bash\nEnter a reminder: Learn PowerShell\nEnter a reminder: Learn Python\nEnter a reminder: Eat spam\nEnter a reminder: \nGoodbye \ud83d\udc4b! To view reminders, run: remind\n\n# remind\nks. kuva alta\n</code></pre> </p> <p>Kuva 3: Muistutusten lis\u00e4\u00e4minen ja poistaminen TUI:n avulla.</p> Executable <p>Huomaa, ett\u00e4 sinun tulee tehd\u00e4 skripteist\u00e4 suoritettavia host-koneellasi, sill\u00e4 kontissa kyseinen volume on read-only. Jos teet t\u00e4t\u00e4 kurssin osuutta Windowsista k\u00e4sin, etk\u00e4 voi tehd\u00e4 t\u00e4t\u00e4, luo skripti siten, ett\u00e4 se luo symbolisen linkin sijasta aliaksen:</p> <pre><code>alias remember=\"python3 /app/scripts/remember.py\"\nalias remind=\"python3 /app/scripts/remind.py\"\n</code></pre> <p>Kuinkahan t\u00e4m\u00e4 onnistuu Pythonissa?</p> Opettajan versio <p>Alla on opettajan versio siten, ett\u00e4 osa riveist\u00e4 on jemmattu. Muista, ett\u00e4 t\u00e4ll\u00e4 kurssilla koodin ymm\u00e4rt\u00e4minen on t\u00e4rke\u00e4\u00e4. Jos opettaja kysyy sinulta, mit\u00e4 jokin rivi tekee, osaatko vastata?</p> <pre><code>#!/bin/env python3\n\nimport curses\nfrom pathlib import Path\n\nTARGET = Path(\"~/.reminder\").expanduser()\n\ndef load_reminders() -&gt; list[str]:\n    pass\n\ndef save_reminders(reminders: list[str]):\n    pass\n\ndef filter_and_save(reminders: list[str], sel: set[int]):\n    kept_reminders = [\n        rem for idx, rem in enumerate(reminders) if idx not in sel\n    ]\n    save_reminders(kept_reminders)\n\ndef draw_menu(stdscr: curses.window, rem: list[str], curr: int, sel: set[int]):\n    stdscr.clear()\n    stdscr.addstr(\n        0, 2, \"Press SPACE to mark as done, Q to save and quit\", curses.A_BOLD\n    )\n\n    for idx, reminder in enumerate(rem):\n        # Highlight the current row\n        attr = curses.A_REVERSE if idx == curr else curses.A_NORMAL\n\n        # Add checkboxes\n        if idx in sel:\n            button = \"[X] \"\n        else:\n            button = \"[ ] \"\n        stdscr.addstr(idx + 2, 2, button + reminder, attr)\n\n\n\ndef reminder_app(stdscr: curses.window):\n    curses.curs_set(0)   # Hide text cursor\n    stdscr.keypad(True)  # Enable arrow keys\n    stdscr.clear()\n\n    reminders = load_reminders()\n    if not reminders:\n        raise SystemExit(\"No reminders found!\")\n\n    selected = set()\n    current_row = 0\n\n    while True:\n\n        draw_menu(stdscr, reminders, current_row, selected)\n\n        # Get event \n        key = stdscr.getch()\n\n        if key == curses.KEY_UP and current_row &gt; 0:\n            current_row -= 1\n        elif key == curses.KEY_DOWN and current_row &lt; len(reminders) - 1:\n            current_row += 1\n        elif key == curses.KEY_RIGHT:\n            selected.add(current_row)\n        elif key == curses.KEY_LEFT:\n            selected.remove(current_row)\n        elif key in (ord(\"Q\"), ord(\"q\")):\n            filter_and_save(reminders, selected)\n            break\n\nif __name__ == \"__main__\":\n    curses.wrapper(reminder_app)\n</code></pre> Teht\u00e4v\u00e4: breakpoint() <p>Koska k\u00e4yt\u00e4mme Visual Studio Codea, voimme k\u00e4ytt\u00e4\u00e4 sen interaktiivista debuggeria CLI-pohjaisen Pdb:n (Python Debugger) sijasta. T\u00e4m\u00e4n k\u00e4ytt\u00f6 esitell\u00e4\u00e4n l\u00e4sn\u00e4tunneilla. On kuitenkin suositeltavaa kokeilla Pdb:t\u00e4 lyhyesti ihan sivistyksen t\u00e4hden. Vastaavia ty\u00f6kaluja l\u00f6ytyy my\u00f6s muista kielist\u00e4, kuten Pdb:n esikuva GDB, joka voi k\u00e4ytt\u00e4\u00e4 useissa kieliss\u00e4: C, C++, Rust ja moni muu.</p> <p>Yksi tapa aktivoida Pdb on sijoittaa skriptiin alla olevassa code snippetiss\u00e4 oleva rivi. Rivin voi tarpeen mukaan ujuttaa useisiin paikkoihin, jolloin debuggeri pys\u00e4htyy jokaisen rivin kohdalla.</p> <pre><code>breakpoint()\n</code></pre> <p>Koodi pys\u00e4ytt\u00e4\u00e4 suorituksen kyseiseen kohtaan ja avaa Pdb:n. T\u00e4ss\u00e4 tilassa ei ole tarkoitus kirjoittaa interaktiivisesti Pythonia vaan tarkkailla muuttujien arvoja esimerkiksi looppia ajettaesa.</p> breakpoint_practice.py<pre><code>#!/usr/bin/env python3\n\nn = 5\ncounter = 0\n\nfor i in range(n):\n    breakpoint()\n    counter += 1\n</code></pre> <pre><code>$ ./runpy.py scripts/breakpoint_practice.py\n(Pdb) p counter\n0\n(Pdb) continue\n&gt; /app/scripts/breakpoint_practice.py(8)&lt;module&gt;()\n-&gt; counter += 1\n(Pdb) p counter\n1\n</code></pre> <p>Debuggerissa toimivat muiden muassa seuraavat komennot [^pdb]:</p> <p>[^pdb] Python Docs. The Python Debugger. https://docs.python.org/3/library/pdb.html</p> <p>Peruskomennot</p> Komento Kuvaus `h(elp) N\u00e4yt\u00e4 ohjeet (eli kaikki n\u00e4m\u00e4 komennot) `q(uit) Poistu debuggerista <code>c(ontinue)</code> Jatka suoritusta seuraavaan breakpointtiin asti <code>n(ext)</code> Suorita seuraava rivi (astu funktiokutsun yli) <code>s(tep)</code> Astu funktiokutsuun <code>r(eturn)</code> Suorita loppuun nykyinen funktio <p>Tarkastelu</p> Komento Kuvaus <code>l(ist)</code> N\u00e4yt\u00e4 koodi breakpointin l\u00e4heisill\u00e4 riveill\u00e4 <code>p expr</code> Tulosta lausekkeen arvo <code>pp expr</code> Tulosta lausekkeen arvo (prettify) <code>whatis</code> N\u00e4yt\u00e4 lausekkeen tyyppi <p>Lauseke (engl. expression) on usein muuttuja, mutta voi olla my\u00f6s esimerkiksi funktio tai moduuli.</p> Teht\u00e4v\u00e4: IP Address <p>Kirjoita Python-skripti, joka:</p> <ol> <li>K\u00e4ytt\u00e4\u00e4 built-in kirjastoa <code>ipaddress</code>.</li> <li>Kysyy k\u00e4ytt\u00e4j\u00e4lt\u00e4 IP-osoitteen CIDR-notaatiolla (esim. <code>192.168.0.12/24</code>).</li> <li>Tulostaa seuraavat sek\u00e4 desimaali- ett\u00e4 bin\u00e4\u00e4rimuodossa:<ul> <li>Verkon osoite</li> <li>Verkon maski</li> <li>Ensimm\u00e4inen host ip</li> <li>Viimeinen host ip</li> <li>Broadcast ip</li> </ul> </li> </ol> <p>Alla esimerkki k\u00e4yt\u00f6st\u00e4. Huomaa, ett\u00e4 tulosteen ei tarvitse olla merkist\u00e4 merkkiin muotoiltu samalla tavalla.</p> \ud83d\udda5\ufe0f Bash<pre><code>./runpy.py scripts/cidr_range.py\nEnter a network (CIDR notation): 10.0.2.42/23\n\nLabel            IP Address       Binary                          \n---------------------------------------------------------------------\nNetwork:         10.0.2.0         00001010 00000000 00000010 00000000\nNetmask:         255.255.254.0    11111111 11111111 11111110 00000000\nFirst IP:        10.0.2.1         00001010 00000000 00000010 00000001\nLast IP:         10.0.3.254       00001010 00000000 00000011 11111110\nBroadcast:       10.0.3.255       00001010 00000000 00000011 11111111\n</code></pre> Host-ip verkon osoitteeksi <p>Verkon osoite on se osoite, joka on ensimm\u00e4inen mahdollinen osoite kyseisess\u00e4 verkossa. K\u00e4ytt\u00e4j\u00e4 saattaa ajatuksissaan antaa osoitteen, joka ei ole verkon vaan yksitt\u00e4isen laitteen ip, kuten yll\u00e4 olevassa esimerkiss\u00e4 (<code>192.168.0.12/24</code>). Saat muunnettua t\u00e4m\u00e4n verkon osoitteeksi k\u00e4ytt\u00e4m\u00e4ll\u00e4 <code>network_address</code>-metodin parametrina <code>strict=False</code>.</p> Miss\u00e4 IP:t? <p>Huomaa, ett\u00e4 <code>network.broadcast_address</code> palauttaa IPv4Network-olion. Kenties keksit k\u00e4ytt\u00f6\u00e4 seuraaville:</p> <ul> <li><code>network.broadcast_address</code></li> <li><code>list(network.hosts())</code> palauttaa <code>list[IPv4Address]</code> sis\u00e4lt\u00e4en vain hostit</li> <li><code>int(some_ipv4)</code> palauttaa desimaalimuodossa olevan ip:n</li> </ul> IP nelj\u00e4ksi oktetiksi <p>Mik\u00e4 tahansa numero on helppo tulostaa 32-bitti\u00e4 pitk\u00e4n\u00e4 bin\u00e4\u00e4rin\u00e4. Se onnistuu f-stringin avulla (<code>{int(ip):032b}</code>). Sen tulostaminen 4 eri osassa, eli oktetissa, vaatii hieman koodia, mutta parantaa tulosteen luettavuutta. T\u00e4m\u00e4n voi luonnollisesti tehd\u00e4 monella tapaa. Alla helppolukuinen tapa:</p> <pre><code>def ip2bin(ip: ipaddress.IPv4Address) -&gt; str:\n\"\"\"\nConvert an IPv4 address to binary format with whitespace between octets, like:\n10000001 10000001 10000001 10000001\n\"\"\"\n\nbit_32 = f\"{int(ip):032b}\"\n\noctets = []\nfor i in range(0, 32, 8):\n    octet = bit_32[i : i + 8]\n    octets.append(octet)\nreturn \" \".join(octets)\n</code></pre>"},{"location":"python/96_curium/","title":"\ud83d\udc69\u200d\ud83d\udd2c Curium","text":""},{"location":"python/96_curium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"python/96_curium/#valiaikaiset-tiedostot","title":"V\u00e4liaikaiset tiedostot","text":"<p>Skriptej\u00e4 kirjoittaessa sinulla voi hyvinkin olla tarve esimerkiksi ladata suuri <code>zip</code> tai <code>tar.gz</code> paketti verkosta ja purkaa se. N\u00e4it\u00e4 ei luonnollisesti kannata s\u00e4il\u00f6\u00e4 pitk\u00e4aikaisesti. Pythonin tempfile-moduuli tarjoaa v\u00e4liaikaisten tiedostojen luomisen ja hallinnan. Se soveltuu useisiin k\u00e4ytt\u00f6tapauksiin, mutta t\u00e4ss\u00e4 esittelemme kaksi.</p> <p>K\u00e4ytt\u00f6tapaus 1 on, ett\u00e4 haluat k\u00e4ytt\u00e4\u00e4 internetist\u00e4 l\u00f6ytyv\u00e4\u00e4 tiedostoa, mutta et halua ladata sit\u00e4 joka kerta uusiksi. Voit k\u00e4ytt\u00e4\u00e4 <code>tempfile.gettempdir()</code>-funktiota saadaksesi j\u00e4rjestelm\u00e4n v\u00e4liaikaisten tiedostojen hakemiston ja luoda tiedoston sinne. T\u00e4m\u00e4 on hy\u00f6dyllist\u00e4 esimerkiksi, jos haluat ladata tiedoston vain kerran ja k\u00e4ytt\u00e4\u00e4 sit\u00e4 sen j\u00e4lkeen paikallisesti. Huomaa, ett\u00e4 k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4 voi poistaa tmp-tiedostoja mielivaltaisesti esimerkiksi k\u00e4ynnistyksen yhteydess\u00e4 tai levytilan k\u00e4ydess\u00e4 v\u00e4hiin. Lue toiminnallisuus koodista:</p> cache_internet_file.py<pre><code>import tempfile\nimport requests\n\nfrom pathlib import Path\n\nURI = \"https://www.example.com/index.html\"\n\ndef cache_internet_file(uri: str) -&gt; Path:\n    temp_dir = tempfile.gettempdir() # (1)!\n    temp_file_path = Path(temp_dir) / \"etusivu.html\" # (2)!\n\n    if not temp_file_path.exists():\n        print(\"[INFO] Downloading data from the internet...\")\n        response = requests.get(URI)\n        with open(temp_file_path, 'wb') as temp_file:\n            temp_file.write(response.content)\n\n    return temp_file_path\n\nlocal_file_path = cache_internet_file(URI)\nprint(f\"[INFO] Downloaded data is available at: {local_file_path}\")\n</code></pre> <ol> <li><code>tempfile.gettempdir()</code> palauttaa j\u00e4rjestelm\u00e4n v\u00e4liaikaisten tiedostojen hakemiston. Windowsissa t\u00e4m\u00e4 voi olla esimerkiksi <code>C:\\Users\\user\\AppData\\Local\\Temp</code>, Linuxissa <code>/tmp</code> ja macOS:ss\u00e4 <code>/var/folders/.../T/</code>.</li> <li>Yksinkertaisuuden vuoksi tiedostonimi on kovakoodattu. Kenties haluaisit poimia tiedostonimen URI:sta urlib.parse.urlparse()-funktiolla? Tai antaa tiedostonimen argumenttina funktiolle? Tai k\u00e4ytt\u00e4\u00e4 sanitoitua urlia tiedostonimen\u00e4?</li> </ol> <p>K\u00e4ytt\u00f6tapaus 2 on hetkellisen hakemiston tai tiedoston luominen, jota tarvitaan vain ja ainoastaan skriptin ajon verran. T\u00e4m\u00e4 on hy\u00f6dyllist\u00e4, jos skriptisi ajon sivutuotteena syntyy tiedosto, jota ei tarvita jatkossa. L\u00f6yd\u00e4t lis\u00e4\u00e4 esimerkkej\u00e4 tempfile-moduulin dokumentaatiosta. Alla hyvin yksinkertainen esimerkki.</p> use_temporary_file.py<pre><code>import tempfile\n\nfrom pathlib import Path\n\nwith tempfile.NamedTemporaryFile(delete_on_close=True) as temp_file: # (1)!\n    temp_file.write(b\"Hello world!\")\n    temp_file.flush()\n    temp_path = Path(temp_file.name)\n\nif temp_path.exists():\n    print(f\"\u26d4\ufe0f Oh no! Temporary file is still available at: {temp_path}\")\nelse:\n    print(f\"\u2705 Temporary file was deleted! (rip {temp_path})\")\n</code></pre> <ol> <li>T\u00e4ss\u00e4 k\u00e4ytet\u00e4\u00e4n context manageria eli <code>with</code>-lauseketta. Context manager kutsuu luokan <code>__enter__</code>- ja <code>__exit__</code>-metodeja automaattisesti, joten et tarvitse <code>temp_file.close()</code>-kutsua.</li> </ol>"},{"location":"python/96_curium/#kirjastot-kontissa","title":"Kirjastot kontissa","text":"<p>Jos ajat yll\u00e4 olevan <code>cache_internet_file.py</code>-esimerkin kontissa, saat alla n\u00e4kyv\u00e4n virheen. T\u00e4m\u00e4 johtuu siit\u00e4, ett\u00e4 <code>python:3.12</code>-image sis\u00e4lt\u00e4\u00e4 vain ja ainoastaan Pythonin sis\u00e4\u00e4nrakennetut moduulit. Sen sijaan Ubuntussa <code>requests</code>-moduuli on asennettu j\u00e4rjestelm\u00e4tasolla - t\u00e4h\u00e4n <code>dist-packages</code>-hakemistoon olet tutustunut jo aiemmin.</p> \ud83d\udda5\ufe0f Bash<pre><code>$ python runpy.py scripts/cache_internet_file.py \nTraceback (most recent call last):\n  File \"/app/scripts/cache_internet_file.py\", line 2, in &lt;module&gt;\n    import requests\nModuleNotFoundError: No module named 'requests'\n</code></pre> <p>Voimme toki ajaa <code>pip install requests</code>-komennon kontin sis\u00e4ll\u00e4, mutta t\u00e4m\u00e4 pit\u00e4isi ajaa joka kerta uudestaan, sill\u00e4 kontit ovat ephemeral eli niiden tila ei pysy tallennettuna. Jos haluat pysyvi\u00e4 muutoksia, sinun tulee luoda oma Dockerfile ja sen pohjalta oma image. Tehd\u00e4\u00e4n siis n\u00e4in!</p> <p>Luo tiedostot <code>build-skroh-python.py</code> ja <code>skroh-python.Dockerfile</code> haluamaasi lokaatioon. T\u00e4ss\u00e4 esimerkiss\u00e4 ne on luotu projektikansion <code>python/</code>-alihakemistoon.</p> build-skroh-python.pyskroh-python.Dockerfile build-skroh-python.py<pre><code>#!/usr/bin/env python3\nimport subprocess\n\ndef build_docker_image():\n    command = [\n        \"docker\", \"buildx\", \"build\",\n        \"-t\", \"skroh-python:3.12\",\n        \"-f\", \"skroh-python.Dockerfile\",\n        \".\"\n    ]\n    subprocess.run(command)\n\nif __name__ == \"__main__\":\n    build_docker_image()\n</code></pre> skroh-python.Dockerfile<pre><code>FROM python:3.12\n\nRUN pip install requests\n</code></pre> <p>Nyt voit ajaa <code>build-skroh-python.py</code>-skriptin, joka luo uuden Docker-imagen. Skripti on Python-skripti, joten sen pit\u00e4isi toimia eri k\u00e4ytt\u00f6j\u00e4rjestelmiss\u00e4. Seuraa alla olevia komentoja ajatuksella. Komentojen tulostetta on lyhennetty luettavuuden parantamiseksi.</p> \ud83d\udda5\ufe0f Bash | CMD | PowerShell<pre><code>$ python build-skroh-python.py\n=&gt; [internal] load build definition from skroh-python.Dockerfile\n=&gt; [1/2] FROM docker.io/library/python:3.12\n=&gt; [2/2] RUN pip install requests\n=&gt; =&gt; naming to docker.io/library/skroh-python:3.12\n\n$ docker image ls\n\u279c  python git:(main) \u2717 docker image ls            \nREPOSITORY                                TAG                   IMAGE ID       CREATED          SIZE\nskroh-python                              3.12                  ad99a641fce3   28 minutes ago   1.03GB\npython                                    3.12                  ba0500f08e94   12 days ago      1.02GB\n\n$ python runpy.py --image skroh-python:3.12 scripts/cache_internet_file.py \n[INFO] Downloading data from the internet...\n[INFO] Downloaded data is available at: /tmp/etusivu.html\n</code></pre> <p>Huomaa, ett\u00e4 jos ajat alimman komennon uusiksi, tiedosto ladataan uudestaan. T\u00e4m\u00e4 johtuu siit\u00e4, ett\u00e4 kontti on ephemeral ja sen tila ei pysy tallennettuna. Jos haluat hy\u00f6ty\u00e4 t\u00e4m\u00e4n sortin cachetuksesta, nopein tapa on k\u00e4ytt\u00e4\u00e4 Bash-istuntoa kontissa ja ajaa skripti useita kertoja saman istunnon aikana. Muista, ett\u00e4 <code>scripts/</code>-hakemisto on mountattu kontin sis\u00e4lle, joten voit muokata tiedostoja suoraan hostilla ja muutokset n\u00e4kyv\u00e4t kontissa v\u00e4litt\u00f6m\u00e4sti.</p> \ud83d\udda5\ufe0f Bash | CMD | PowerShell<pre><code>$ python runpy.py --image skroh-python:3.12 --bash\n\n\ud83d\udc33 # python scripts/cache_internet_file.py \n[INFO] Downloading data from the internet...\n[INFO] Downloaded data is available at: /tmp/etusivu.html\n\n\ud83d\udc33 # python scripts/cache_internet_file.py \n[INFO] Downloaded data is available at: /tmp/etusivu.html\n</code></pre>"},{"location":"python/96_curium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Pingviinien laskeminen <p>T\u00e4m\u00e4 on sinulle PowerShell-osiosta tuttua dataa. Lue skripti, joka lukee tiedoston penguins.csv ja laskee pingviinit lajeittain. Tulosta lajit ja niiden lukum\u00e4\u00e4r\u00e4t.</p> <p>Huomaa, ett\u00e4 meid\u00e4n k\u00e4yt\u00f6ss\u00e4 on j\u00e4rjestelm\u00e4tason Python ja siten vain Pythonin sis\u00e4\u00e4nrakennetut (ja ehk\u00e4 debianin) kirjastot. \u00c4l\u00e4 asenna datank\u00e4sitelykirjastoja. K\u00e4yt\u00e4 sis\u00e4\u00e4nrakennettua csv-moduulia.</p> <pre><code>import csv\n\n# Steps:\n# 1. Read the file if exists\n# 2. Download the file otherwise\n# 3. Count the penguins\n# 4. Print the results\n</code></pre> <p>Lopulta sen pit\u00e4isi k\u00e4ytt\u00e4yty\u00e4 n\u00e4in:</p> \ud83d\udda5\ufe0f Bash<pre><code>$ python runpy.py --image skroh-python:3.12 scripts/penguins.py\n[INFO] Downloading data from the internet...\nDownloaded data is available at: /tmp/penguins.csv\nRead 344 rows from the CSV file.\nAdelie: 152\nChinstrap: 68\nGentoo: 124\n</code></pre> CSV <pre><code>import csv\n\n# ...\ncsv_reader = csv.DictReader(csv_file)\nlist(csv_reader)\n</code></pre> Counting <p>Lajien laskemisen voi tehd\u00e4 usealla eri tavalla. Voit esimerkiksi k\u00e4ytt\u00e4\u00e4 <code>collections.Counter</code>-luokkaa, saman kirjaston defaultdicti\u00e4, sqlite\u00e4, tai ihan tavallista dictionary\u00e4. Counterilla se hoituu n\u00e4in:</p> <pre><code>from collections import Counter\n\n# ...\nc = Counter(entry[\"species\"] for entry in penguin_dict)\ndict(c)\n</code></pre> Teht\u00e4v\u00e4: Suurimmat ohjelmat <p>Luo skripti, joka tulostaa n kappaletta suurimpia bin\u00e4\u00e4ritiedostoja /usr/bin-hakemistossa. Vakio n = 5, mutta k\u00e4ytt\u00e4j\u00e4 voi sy\u00f6tt\u00e4\u00e4 sen. Voit l\u00e4hesty\u00e4 ongelmaa kahdella tavalla:</p> <ul> <li><code>subprocess.run([\"du\", \"-a\", \"/usr/bin\"])</code></li> <li><code>Path(\"/usr/bin/some_executable\").stat()</code></li> </ul> <p>J\u00e4lkimm\u00e4inen tapa s\u00e4\u00e4st\u00e4\u00e4 sinut <code>du</code>-komennon tuloksen parsimiselta ja on muutenkin more pythonic. Se palauttaa itemin, joka sis\u00e4lt\u00e4\u00e4 muun muassa seuraavat tiedot:</p> <pre><code>os.stat_result(\n    st_mode=33261,    # oct(33261) == 0o100755 eli 755 eli rwxr-xr-x\n    st_uid=0,         # user id\n    st_gid=0,         # group id\n    st_size=1346480,  # size in bytes\n    ...\n)\n</code></pre> <p>Huomaa, ett\u00e4 arvot <code>st_uid</code> ja <code>st_gid</code> tulee muuttaa k\u00e4ytt\u00e4j\u00e4nimeksi ja ryhm\u00e4nimeksi. T\u00e4m\u00e4 onnistuu helposti pwd ja grp-moduuleilla. Ent\u00e4 kuinka muuttaisit <code>st_size</code>-arvon ihmisluettavaan muotoon? Kenties StackOverFlow-palvelussa t\u00e4t\u00e4 on pohtinut joku muukin?</p> <p>Lis\u00e4haaste</p> <p>Voit lis\u00e4t\u00e4 teht\u00e4v\u00e4n haastavuutta seuraamalla symbolisia linkkej\u00e4. Jos teet t\u00e4m\u00e4n, tulet saamaan kohtalaisen m\u00e4\u00e4r\u00e4n duplikaatteja. Keksi tapa poistaa duplikaatit listasta.</p> <p>Lis\u00e4haaste 2</p> <p>Lis\u00e4haaste on hy\u00f6dynt\u00e4\u00e4 st_modea. Voit parsia siit\u00e4 muun muassa moden numeroina (esim. <code>755</code>), k\u00e4\u00e4nt\u00e4\u00e4 sen merkkijonoksi (esim. <code>rwxrxrx</code>)</p> <p>Esimerkki k\u00e4yt\u00f6st\u00e4 alla (lis\u00e4haasteet mukana):</p> \ud83d\udda5\ufe0f Bash<pre><code>$ ./runpy.py scripts/largest_binaries.py -n 8 \n/usr/bin/x86_64-linux-gnu-lto-dump-12      30.5 MiB    root:root rwxr-xr-x\n/usr/bin/sq                                 9.6 MiB    root:root rwxr-xr-x\n/usr/bin/python3.11                         6.5 MiB    root:root rwxr-xr-x\n/usr/bin/perl5.36.0                         3.6 MiB    root:root rwxr-xr-x\n/usr/bin/git                                3.5 MiB    root:root rwxr-xr-x\n/usr/bin/x86_64-linux-gnu-ld.gold           3.0 MiB    root:root rwxr-xr-x\n/usr/bin/scalar                             2.1 MiB    root:root rwxr-xr-x\n/usr/bin/git-shell                          2.0 MiB    root:root rwxr-xr-x\n</code></pre> <p>T\u00e4m\u00e4 harjoitus ei juuri saavuta mit\u00e4\u00e4n, mit\u00e4 <code>ls</code>-komento ei tee, mutta se on hyv\u00e4 harjoitus tiedostojen k\u00e4sittelyyn ja tiedostojen metatietojen lukemiseen. Voisit k\u00e4ytt\u00e4\u00e4 n\u00e4it\u00e4 taitoja esimerkiksi tiedostojen analysointiin, j\u00e4rjest\u00e4miseen, tai vaikkapa tiedostojen poistamiseen \u2013 kenties sis\u00e4llytt\u00e4en merkitt\u00e4v\u00e4sti enemm\u00e4n logiikkaa.</p> Teht\u00e4v\u00e4: Duplikaattitiedostojen luominen <p>T\u00e4m\u00e4 teht\u00e4v\u00e4 toimii esiasteena seuraavalle teht\u00e4v\u00e4lle. Luo skripti, joka kirjoittaa tiedostoihin sis\u00e4lt\u00f6\u00e4 siten, ett\u00e4 osa tiedostoista on tarkoituksella toistensa kopioita. Osa tiedostoista tulee sen sijaan olla uniikkeja. Voit k\u00e4ytt\u00e4\u00e4 apuna seuraavanlaista jakoa:</p> add_duplicates.py<pre><code>duplicate_files = [\n    tmpdir / \"foo.txt\",\n    tmpdir / \"foo_copy.txt\",\n    tmpdir / \"nested\" / \"foo_copy_nested.txt\",\n]\n\nunique_files = [\n    tmpdir / \"unicorn_a.txt\",\n    tmpdir / \"nested\" / \"unicorn_b.txt\",\n]\n</code></pre> <p>Lopulta ohjelmaa tulisi voida k\u00e4ytt\u00e4\u00e4 seuraavanlaisesti:</p> \ud83d\udc33 Bash<pre><code>$ python scripts/add_duplicates.py\nTemporary directory created at: /tmp/tmpinhu9_m1\nCreated file: /tmp/tmpinhu9_m1/foo.txt\nCreated file: /tmp/tmpinhu9_m1/foo_copy.txt\nCreated file: /tmp/tmpinhu9_m1/nested/foo_copy_nested.txt\nCreated file: /tmp/tmpinhu9_m1/unicorn_a.txt\nCreated file: /tmp/tmpinhu9_m1/nested/unicorn_b.txt\nNavigate to /tmp/tmpinhu9_m1 to see the files! \ud83d\udc40\n</code></pre> <p>Tip</p> <p>Rautakoodauksen sijasta voit k\u00e4ytt\u00e4\u00e4 <code>tempfile.gettempdir()</code>, jotta sama skripti toimisi eri alustoilla.</p> Teht\u00e4v\u00e4: Duplikaattien tunnistaminen <p>Luo skripti, joka tunnistaa duplikaatit annetussa hakemistossa. Mik\u00e4li <code>-recurse</code> flag on annettu, sen tulisi k\u00e4yd\u00e4 my\u00f6s alihakemistot l\u00e4pi. Duplikaatit tulisi tunnistaa tiedoston MD5-hashin perusteella. Voit k\u00e4ytt\u00e4\u00e4 samoja vaiheita kuin aiemmin PowerShellin kanssa, mutta puuttuvat cmdletit saattavat aiheuttaa p\u00e4\u00e4nvaivaa.</p> <p>P\u00e4\u00e4nvaiva 1: Tulet mahdollisesti huomaamaan, ett\u00e4 Group-Object ja Where-Object Count -komentojen puute tekee teht\u00e4v\u00e4st\u00e4 hieman vaikeamman Pythonissa kuin PowerShelliss\u00e4, jossa olet toteuttanut vastaavan operaation aiemmin. Datan k\u00e4sittelyyn tarkoitetut kirjastot, kuten Pandas, tarjoavat n\u00e4it\u00e4 ominaisuuksia, mutta se lis\u00e4isi meid\u00e4n skriptille ylim\u00e4\u00e4r\u00e4isi\u00e4 riippuvuuksia. Ratkaise t\u00e4m\u00e4 ongelma Pythonin sis\u00e4\u00e4nrakennetuilla kirjastoilla. Kenties <code>collections.defaultdict</code> tai <code>collections.Counter</code> voisi olla hy\u00f6dyllinen?</p> <p>P\u00e4\u00e4nvaiva 2: Sinun saattaa tulla ik\u00e4v\u00e4 my\u00f6s Get-FileHash -cmdletia, joka laskee tiedoston hashin. Pythonissa voit k\u00e4ytt\u00e4\u00e4 <code>hashlib</code>-moduulia. Voit chunkata tiedoston ja laskea hashin osissa, kuten StackOverFlow:n postauksissa neuvotaan, jotta suurten tiedostojen k\u00e4sittely onnistuu. Vaihtoehtona on k\u00e4ytt\u00e4\u00e4 valmisratkaisua: <code>hashlib.file_digest(f, algorithm)</code>. Kyseinen funktio on Python 3.11:ss\u00e4 lis\u00e4tty.</p> <p>Alla n\u00e4kyy esimerkkitoteutuksen k\u00e4ytt\u00f6:</p> \ud83d\udc33 Bash<pre><code>$ python scripts/find_duplicates.py /tmp/tmpinhu9_m1/\n\ud83d\udea8 WARNING: Duplicate files found:\n\nFull path                      MD5 checksum\n---------------------------------------------------------------\n/tmp/tmpinhu9_m1/foo.txt       746308829575e17c3331bbcb00c0898b\n/tmp/tmpinhu9_m1/foo_copy.txt  746308829575e17c3331bbcb00c0898b\n\n$ python scripts/find_duplicates.py /tmp/tmpinhu9_m1/ --recurse\n\ud83d\udea8 WARNING: Duplicate files found:\n\nFull path                                    MD5 checksum\n-----------------------------------------------------------------------------\n/tmp/tmpinhu9_m1/foo.txt                     746308829575e17c3331bbcb00c0898b\n/tmp/tmpinhu9_m1/foo_copy.txt                746308829575e17c3331bbcb00c0898b\n/tmp/tmpinhu9_m1/nested/foo_copy_nested.txt  746308829575e17c3331bbcb00c0898b\n</code></pre> Teht\u00e4v\u00e4: Tulosta PATH-muuttujan hakemistot <p>Skriptiohjelmoinnin t\u00e4rke\u00e4 osa on ymp\u00e4rist\u00f6muuttujien k\u00e4sittely. Yksi t\u00e4rkeimmist\u00e4 ymp\u00e4rist\u00f6muuttujista on <code>PATH</code>, joka sis\u00e4lt\u00e4\u00e4 hakemistot, joista k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4 etsii suoritettavia tiedostoja. Toteuta skripti, joka tulostaa <code>PATH</code>-muuttujan hakemistot riveitt\u00e4in. Voit k\u00e4ytt\u00e4\u00e4 <code>os.environ[\"PATH\"]</code>-muuttujaa, joka palauttaa <code>PATH</code>-muuttujan arvon.</p> <p>T\u00e4m\u00e4 on Curium-osion helppo loppukevennys! Tulosteen tulisi n\u00e4ytt\u00e4\u00e4 jotakuinkin t\u00e4lt\u00e4:</p> \ud83d\udc33 Bash<pre><code>python scripts/print_env.py \n/usr/local/bin\n/usr/local/sbin\n/usr/local/bin\n/usr/sbin\n/usr/bin\n/sbin\n/bin\n</code></pre>"},{"location":"python/99_einsteinium/","title":"\ud83d\udc68\u200d\ud83d\udd2c Einsteinium","text":""},{"location":"python/99_einsteinium/#tarpit","title":"T\u00e4rpit","text":""},{"location":"python/99_einsteinium/#subprocess","title":"Subprocess","text":"<p>Pythonin <code>subprocess</code>-kirjasto mahdollistaa muiden ohjelmien k\u00e4ynnist\u00e4misen ja niiden tulosteen lukemisen. T\u00e4m\u00e4 on hy\u00f6dyllist\u00e4, kun halutaan esimerkiksi testata ohjelmia automaattisesti tai k\u00e4ytt\u00e4\u00e4 ohjelmia osana skripti\u00e4. Yksinkertaisissa skripteiss\u00e4 kannattaa hy\u00f6dynt\u00e4\u00e4 ihan oikeaa shelli\u00e4, kuten Bash tai PowerShell. Jos komennon suorittaminen on osa suurempaa kokonaisuutta, tai komennon tuloste vaatii monimutkaista jatkok\u00e4sittely\u00e4, Python ja <code>subprocess</code> voivat olla oikeutettu valinta.</p> subprocess_demo.py<pre><code>import subprocess\n\nresult = subprocess.run(\n    [\"cat\", \"/root/kissa.txt\"],\n    text=True,\n    capture_output=True\n)\n\nprint(f\"STDOUT:\")\nprint(result.stdout)\nprint(f\"STDERR:\")\nprint(result.stderr)\n</code></pre> <p>Yll\u00e4 oleva toteutus tarkoittaa, ett\u00e4 n\u00e4m\u00e4 kaksi komentoa tekev\u00e4t k\u00e4yt\u00e4nn\u00f6ss\u00e4 saman asian:</p> \ud83d\udc33 Bash<pre><code>$ echo /root/kissa.txt\n...\n\n$ python /scripts/subprocess_demo.py\n...\n</code></pre> Skriptin tuloste <p>Alla tuloste siten, ett\u00e4 kissa.txt ei ole olemassa ja sen j\u00e4lkeen kun se on luotu.</p> \ud83d\udc33 Bash<pre><code>$ python scripts/subprocess_demo.py \nSTDOUT:\n\nSTDERR:\ncat: /root/kissa.txt: No such file or directory\n\n$ echo 'I am Puss in Roots!' &gt; /root/kissa.txt\n$ python scripts/subprocess_demo.py \nSTDOUT:\nI am Puss in Roots!\n\nSTDERR:\n</code></pre>"},{"location":"python/99_einsteinium/#stdin-lukeminen","title":"Stdin lukeminen","text":"<p>Linuxista (ja PowerShellist\u00e4) sinulle pit\u00e4isi olla tuttua, ett\u00e4 voit ohjata tulosteen toisen ohjelman sy\u00f6tteeksi. Edistynyt tapa k\u00e4sitell\u00e4 t\u00e4t\u00e4 on <code>subprocess.Popen</code>-luokka, joka ajaa valitun child ohjelman omassa prosesissa. T\u00e4st\u00e4 saat esimakua Arvaa luku botti -teht\u00e4v\u00e4ss\u00e4. Pysyt\u00e4\u00e4n kuitenkin hetki simppeliss\u00e4 esimerkiss\u00e4, joka auttaa sinua Paste.ee -teht\u00e4v\u00e4ss\u00e4.</p> stdin_demo.py<pre><code>import sys\n\ndef print_whatever_is_given_to_stdin():\n    if sys.stdin.isatty():\n        print(\"No input string given\", file=sys.stderr)\n        sys.exit(1)\n    for line in sys.stdin:\n        print(line, end=\"\")\n\nprint_whatever_is_given_to_stdin()\n</code></pre> <p>Yll\u00e4 esitelty skripti tulostaa kaiken, mit\u00e4 sille sy\u00f6tet\u00e4\u00e4n, paitsi jos sy\u00f6te on TTY eli terminal device. Jos se ei ole tty, niin oletettavasti:</p> <ul> <li>Skripti on osa putkea, jossa se saa sy\u00f6tett\u00e4 toiselta ohjelmalta.<ul> <li>Esim. <code>echo \"Hello\" | python stdin_demo.py</code></li> </ul> </li> <li>Skriptin sy\u00f6te on uudelleenohjattu tiedostosta.<ul> <li>Esim. <code>python stdin_demo.py &lt; /root/kissa.txt</code></li> </ul> </li> </ul> <p>Alla skriptin ajo viel\u00e4 esimerkkin\u00e4 (rivivaihto lis\u00e4tty luettavuuden parantamiseksi):</p> \ud83d\udc33 Bash<pre><code>$ alias thingy='python /app/scripts/stdin_demo.py'\n$ echo \"Hello\" | thingy\nHello\n\n$ echo 'Miau mau mou' &gt;&gt; /root/mirri.txt\n$ echo 'Purr purrrrr' &gt;&gt; /root/mirri.txt\n$ thingy &lt; /root/mirri.txt \nMiau mau mou\nPurr purrrrr\n</code></pre>"},{"location":"python/99_einsteinium/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Paste.ee</p> <p>Teht\u00e4v\u00e4si on luoda skripti, jolla voit siirt\u00e4\u00e4 <code>stdout</code>:n sis\u00e4ll\u00f6n paste.ee-sivustolle. Skriptin tulee siis lukea standardisy\u00f6tett\u00e4 ja l\u00e4hett\u00e4\u00e4 se paste.ee-sivustolle. Skriptin tulee tulostaa URL-osoite, josta skriptin voi k\u00e4yd\u00e4 my\u00f6hemmin poimimassa. T\u00e4m\u00e4 voi olla hy\u00f6dyllist\u00e4, jos olet esimerkiksi asentanut Linuxille jotakin, mik\u00e4 vaati useamman komennon. Kenties voit t\u00e4ll\u00f6in ajaa vaikkapa seuraavan:</p> <pre><code>$ history 50 | python /app/scripts/to_pastee.py\n</code></pre> <p>N\u00e4in Bash-historyn viimeiset 50 rivi\u00e4 singahtaisi Paste.ee-sivustolle, josta voisit poimia ne my\u00f6hemmin dokumentaatiosi dokumentointiin. T\u00e4ss\u00e4 harjoituksessa opit k\u00e4ytt\u00e4m\u00e4\u00e4n sek\u00e4 tokeneita ett\u00e4 POST-pyynt\u00f6\u00e4.</p> <p>Tarvitset teht\u00e4v\u00e4ss\u00e4 seuraavat:</p> <ul> <li>paste.ee-k\u00e4ytt\u00e4j\u00e4tunnuksen</li> <li>paste.ee API-avaimen<ul> <li>Luo applikaatio esimerkiksi nimell\u00e4 <code>skroh</code> ja ilman urlia.</li> <li>Ota avain talteen. Se on pitk\u00e4 merkkijono: <code>aBg************************************S5</code></li> <li>Tallenna se <code>scripts/.secret</code></li> <li>Lis\u00e4\u00e4 kyseinen tiedosto <code>.gitignore</code>-tiedostoon.</li> </ul> </li> <li>pastee.ee API Documentation</li> <li><code>requests</code>-kirjaston</li> </ul> <p>\ud83e\udd77 Yksityisyysvinkki</p> <p>Jos et halua sivuston saavan sinun oikeaa s\u00e4hk\u00f6postiosoitetta, k\u00e4yt\u00e4 jotakin v\u00e4liaikaista s\u00e4hk\u00f6postipalvelua, kuten temp-mail.org tai 10minutemail.com. Jos sivusto hakkeroidaan, oikea s\u00e4hk\u00f6postisi ei ole vaarassa.</p> <p>Alla on opettajan luoma ohjelmarunko, josta voi olla apua. Vaihtoehtoisesti voit hyl\u00e4t\u00e4 sen ja l\u00e4hesty\u00e4 ongelmaa omalla tavallasi.</p> Opettajan vihjekoodi to_pastee.py<pre><code>import sys\nimport requests\nimport argparse\n\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\n\n@dataclass\nclass NewPasteResponse:\n    id: str\n    link: str\n\n\n@dataclass\nclass ParsedArguments:\n    syntax: str\n    dry_run: bool\n\n\ndef read_secret() -&gt; str:\n    secret_file = Path(\"/app/scripts/.secret\")\n    secret = secret_file.read_text().strip()\n    return secret\n\n\ndef get_valid_syntaxes() -&gt; list[str]:\n    # You can get all 170+ from: GET https://api.paste.ee/v1/syntaxes\n    return [\"autodetect\", \"python\", \"powershell\", \"bash\"]\n\n\ndef get_stdin_lines() -&gt; list[str]:\n    return [line.rstrip(\"\\n\") for line in sys.stdin]\n\n\ndef stdin_to_data_header(syntax=\"autodetect\") -&gt; dict:\n    return {\n        \"description\": \"stdin\",\n        \"sections\": [\n            {\n                \"name\": \"stdin\",\n                \"syntax\": syntax,\n                \"contents\": \"\\n\".join(get_stdin_lines()),\n            }\n        ],\n    }\n\n\ndef parse_args() -&gt; ParsedArguments:\n    # IMPLEMENT ME\n    return ParsedArguments(syntax=\"python\", dry_run=True)\n\n\ndef pretty_print_request(prepared_request: requests.PreparedRequest):\n    # IMPLEMENT\n    pass\n\n\ndef post_to_pastee(data: dict, secret: str, dry_run: bool) -&gt; NewPasteResponse | None:\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"X-Auth-Token\": secret,\n    }\n\n    prepared_request = requests.Request(\n        method=\"POST\",\n        url=\"https://api.paste.ee/v1/pastes\",\n        headers=headers,\n        json=data).prepare()\n\n    if dry_run:\n        pretty_print_request(prepared_request)\n        return NewPasteResponse(id=\"DRY-RUN\", link=\"DRY-RUN\")\n\n    session = requests.Session()\n    response = session.send(prepared_request)\n    session.close()\n\n    response_data = response.json()\n    return NewPasteResponse(id=response_data[\"id\"], link=response_data[\"link\"])\n\nif __name__ == \"__main__\":\n    # Get arguments\n    args = parse_args()\n\n    prepared_data = stdin_to_data_header(syntax=args.syntax)\n    secret = read_secret()\n    response = post_to_pastee(prepared_data, secret, args.dry_run)\n\n    print(f\"New paste created: {response.link}\")\n    print(f\"ID: {response.id}\")\n</code></pre> <p>Jos opettajan koodin ajaa dry-run moodissa, tulostuu seuraava:</p> \ud83d\udc33 Bash<pre><code>$ alias pastee='python /app/scripts/to_pastee.py'\n$ pastee --syntax python --dry-run &lt; /app/scripts/hello_turbo.py \nDry run. The following request would be made:\n\n=== URL ===\nhttps://api.paste.ee/v1/pastes\n\n=== Headers ===\n{'Content-Type': 'application/json', 'X-Auth-Token': '********', 'Content-Length': '707'}\n\n=== Body ===\n{\"description\": \"stdin\", \"sections\": [{\"name\": \"stdin\", \"syntax\": \"python\", \"contents\": \"import os\\n\\nimport sys\\n\\n\\n\\n\\n\\ndef print_title_n_val(title: str, value: str):\\n\\n    print(f\\\"{title:&lt;30}: {value}\\\")\\n\\n\\n\\n\\n\\n# Tulostaa absoluuttinen polku ty\\u00f6hakemistoon\\n\\nprint(\\\"========= Turbo Hello World! =========\\\")\\n\\nprint_title_n_val(\\\"Current working dir: \\\", os.getcwd())\\n\\n\\n\\n# Tulostaa absoluuttinen polku skriptin sijaintiin\\n\\nprint_title_n_val(\\\"Skriptin sijainti: \\\", os.path.abspath(__file__))\\n\\n\\n\\n# Tulostaa kaikki lokaatiot, mist\\u00e4 Python etsii moduuleita importtia varten\\n\\nprint(\\\"Python moduulien hakupolut:\\\")\\n\\nfor path in sys.path:\\n\\n    print(\\\"    \\\", path)\\n\"}]}\"\n</code></pre> <p>Ilman dry-run moodia tulostuu sek\u00e4 URL ett\u00e4 ID:</p> \ud83d\udc33 Bash<pre><code>New paste created: https://paste.ee/p/jkHt7Rp5\nID: jkHt7Rp5\"\n</code></pre> <p></p> <p>Kuva 1. Esimerkki paste.ee-sivustolle l\u00e4hetetyst\u00e4 tiedostosta. Tiedosto n\u00e4kyy kaikille, jotka tiet\u00e4v\u00e4t URLin.</p> <p>Note</p> <p>K\u00e4yt\u00e4nn\u00f6ss\u00e4 sinun ei tietenk\u00e4\u00e4n tyypillisesti tarvitse luoda omaa CLI-k\u00e4ytt\u00f6liittym\u00e4\u00e4. Ubuntun <code>/bin/</code>-hakemiston Python-skriptej\u00e4 pl\u00e4r\u00e4tess\u00e4 saatoikin huomata skriptin nimelt\u00e4\u00e4n <code>pastebinit</code>. Kyseinen skripti l\u00e4hett\u00e4\u00e4 datat paste.ubuntu.com/ tai dpaste.com sivustolle. J\u00e4lkimm\u00e4inen on vakio, jos sinulla ei ole tunnuksia lis\u00e4ttyn\u00e4 <code>~/bin/.pastebinit.xml</code>-tiedostoon. Vailla tunnuksia tehdyn postauksen huono puoli on luonnollisesti se, ett\u00e4 et voi my\u00f6hemmin listata omia pasteja tai poistaa niit\u00e4. Se on seuraavat 30 p\u00e4iv\u00e4\u00e4 julkisesti online.</p> <p>Voit kokeilla tunnuksetonta postausta n\u00e4in:</p> <pre><code>$ echo 'I am a happy penguin!' | pastebinit\nhttps://dpaste.com/BKZYVE9GZ\n\n$ man pastebinit\n... lue lis\u00e4\u00e4 ...\n</code></pre> <p>My\u00f6s muita vaihtoehtoja on olemassa, kuten <code>pastee-cli</code>, joka on Go:lla korjoitettu CLI, joka ajaa jotakuinkin saman asian kuin juuri sinun kirjoittamasi koodi.</p> Teht\u00e4v\u00e4: Premiere Markers to YouTube <p>Luo skripti, joka lataa netist\u00e4 tekstitiedoston, joka sis\u00e4lt\u00e4\u00e4 Adobe Premierest\u00e4 exportatut Chapter Markerit ja k\u00e4\u00e4nt\u00e4\u00e4 ne YouTuben Video Chapters-formaattiin. Output-formaatin voi liitt\u00e4\u00e4 YouTube-videon kuvauskentt\u00e4\u00e4n ja videon aikajana katkotaan automaattisesti chapter-markerien kohdalta otsikoiduiksi osioiksi. Lopputuloksen pit\u00e4isi n\u00e4ytt\u00e4\u00e4 t\u00e4lt\u00e4:</p> Haluttu formaatti<pre><code>00:00 Intro\n00:29 Miksi Linux?\n01:06 Mik\u00e4 WSL?\n...\n32:22 Ubuntun tuhoaminen\n...\n01:01:06 Ja lis\u00e4haasteena yli tunnin klipit\n</code></pre> <p>Lis\u00e4haaste</p> <p>Ent\u00e4 jos video on yli tunnin mittainen? Voit lis\u00e4haasteena muotoilla formaatin automaattisesti siten, ett\u00e4 tunnin ylitt\u00e4v\u00e4t osiot saavat formaatin <code>01:00:00</code>.</p> <p>Alkuper\u00e4inen data l\u00f6ytyy gh:sourander/skriptiohjelmointi/exercise-assets/data/premieremarkers.txt. Alla boilerplate-koodi, jolla p\u00e4\u00e4set alkuun. Se lataa kyseisen tiedoston Path-tyypin muuttujaan. Parsi kyseisen muuttujan sis\u00e4lt\u00f6 ja tulosta konsoliin ja/tai kirjoita uuteen tiedostoon.</p> premiere_markers_to_youtube.py<pre><code>import csv\nimport tempfile\nimport requests\nfrom pathlib import Path\n\nURI = \"https://raw.githubusercontent.com/sourander/skriptiohjelmointi/refs/heads/main/exercise-assets/data/premieremarkers.txt\"\n\ndef cache_internet_file(uri: str) -&gt; Path:\n    \"\"\" \n        Katso funktion toteutus aiemman luvun harjoituksesta.\n    \"\"\"\n    print(f\"[INFO] Downloaded data is available at: {temp_file_path}\")\n    return temp_file_path\n\nmarkers_file = cache_internet_file(URI)\n</code></pre> Odotettu bugi! <p>Jos t\u00e4ss\u00e4 vaiheessa ajat tiedoston, niin sinulle pit\u00e4isi olla alla oleva tilanne ongelmineen. Huomaa, ett\u00e4 k\u00e4yt\u00f6ss\u00e4 on <code>python3 runpy.py --image skroh-python:3.12 --bash</code>-komennon alustama kontti, josta l\u00f6ytyy requests-kirjasto.</p> \ud83d\udc33 Bash<pre><code>$ python scripts/premiere_markers_to_youtube.py\n[INFO] Downloaded data is available at: /tmp/premieremarkers.txt\n\n$ cat /tmp/premieremarkers.txt \n\n$ python\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; content = Path(\"/tmp/premieremarkers.txt\").read_text()\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFile \"/usr/local/lib/python3.12/pathlib.py\", line 1028, in read_text\n    return f.read()\n        ^^^^^^^^\nFile \"&lt;frozen codecs&gt;\", line 322, in decode\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte\n</code></pre> <p>UniCodeError ei siis ole opettajan k\u00e4mmi tiedostossa vaan odotettu ongelma, joka aiheutuu Premieren k\u00e4ytt\u00e4m\u00e4st\u00e4 enkoodauksesta. T\u00e4m\u00e4n korjaus on olennainen osa teht\u00e4v\u00e4\u00e4. Skriptej\u00e4 kirjoittaessa tulet kohtaamaan urallasi erilaisia enkoodausongelmia, joten t\u00e4m\u00e4 on aiheellinen harjoitus.</p> Vinkki: Encoding <p>Huomaa, ett\u00e4 Premiere kirjoittaa hyvin ep\u00e4tyyllist\u00e4 enkoodausta. Jos luotat <code>markers_file.open()</code>-funktion. Voit p\u00e4\u00e4tell\u00e4 tiedoston enkoodauksen joko lokaalisti lataamalla tiedoston ja avaamalla sen Visual Studio Codessa tai Pythonin avulla. Alla esimerkki:</p> <pre><code>def get_file_encoding(file_path: Path) -&gt; str:\n    with file_path.open(\"rb\") as file:\n        raw_data = file.read(32)\n    if raw_data.startswith(codecs.BOM_UTF8):\n        return \"utf-8-sig\"\n    if raw_data.startswith(codecs.BOM_UTF16_LE):\n        return \"utf-16\"\n    if raw_data.startswith(codecs.BOM_UTF32_LE):\n        return \"utf-32\"\n    return \"utf-8\"\n\nencoding = get_file_encoding(markers_file)\n</code></pre> <p>Python-ratkaisu voittaa rautakoodauksen siten, ett\u00e4 Premiere saattaa jatkossa vaihtaa tavalliseen UTF-8 enkoodaukseen, jolloin koodi ei en\u00e4\u00e4 toimisi, jos rautakoodaat enkoodauksen. Vaihtoehtoisesti k\u00e4ytt\u00e4j\u00e4 on saattanut avata tekstitiedoston jossakin editorissa, joka teki muutoksen automaattisesti. My\u00f6s t\u00e4m\u00e4 rikkoisi rautakoodatun toteutuksen.</p> Vinkki: Timeformat <p>Alkuper\u00e4isen datan aikamuoto on <code>hh:mm:ss:frames</code>. Voit k\u00e4yt\u00e4nn\u00f6ss\u00e4 unohtaa framet.</p> Teht\u00e4v\u00e4: Arvaa luku botti <p>T\u00e4m\u00e4n teht\u00e4v\u00e4n voi tehd\u00e4 helpotettuna tai haastavana versiona. Helpostetussa versiossa korjaat t\u00e4m\u00e4n alla olevan koodin siten, ett\u00e4 se pelaa <code>arvaaluku.py</code>-pelin l\u00e4pi brute forcena eli sy\u00f6tt\u00e4en kaikki numerot 1:st\u00e4 1000:een, kunnes oikea ratkaisu l\u00f6ytyy. Lis\u00e4ksi sinun tulee kommentoida koodi tai muutoin varmistaa, ett\u00e4 ymm\u00e4rr\u00e4t, mit\u00e4 koodi tekee.</p> <p>Haastavassa versiossa jatkat koodia siten, ett\u00e4 implementoit kesken j\u00e4\u00e4neen <code>binary_search()</code>-funktion loppuun ja lis\u00e4\u00e4t mahdollisuuden vaihtaa ko. solveriin skriptin argumenttien avulla.</p> <p>Huomaa, ett\u00e4 skriptiin on rautakoodattuna oletuksia <code>arvaaluku.py</code>-skriptin toiminnasta. Muokkaa jompaa kumpaa skripti\u00e4, jotta ne toimivat yhteen.</p> <p>Oletus 1</p> <p>On oletus, ett\u00e4 pyynt\u00f6 sis\u00e4lt\u00e4\u00e4 sanan <code>sy\u00f6t\u00e4</code>, ja ett\u00e4 t\u00e4m\u00e4 tulostetaan erikseen ennen <code>input()</code>-funktiota. Muutoin Pipe on huomattavan vaikea saada toimimaan reaktiivisesti kysymysten kanssa.</p> <pre><code>print(\"\\nSy\u00f6t\u00e4 arvaus:\")\nguess = int(input())\n</code></pre> <p>Oletus 2</p> <p>On oletus, ett\u00e4 ohjelman tuloste sis\u00e4lt\u00e4\u00e4 sanan <code>oikein</code> kun arvaus on oikein. T\u00e4m\u00e4 on t\u00e4rke\u00e4\u00e4, jotta solveri voi tiet\u00e4\u00e4, milloin lopettaa arvaaminen.</p> <pre><code>print(f\"\ud83c\udf89 Oikein! ...\")\n</code></pre> <p>Tip</p> <p>Kannattaa my\u00f6s lis\u00e4t\u00e4 koodiin rivi, joka tulostaa oikean vastauksen. T\u00e4m\u00e4 helpottaa testaamista ja sen tulkitsemista, ett\u00e4 l\u00f6yt\u00e4\u00e4k\u00f6 <code>arvaaluku_bot.py</code> oikean vastauksen vai ei.</p> Opettajan vihjekoodi arvaaluku_bot.py<pre><code>import subprocess\nfrom pathlib import Path\n\ndef brute_force(pipe: subprocess.Popen) -&gt; int:\n    guess = 1\n    while guess &lt; 1001:\n\n        output = pipe.stdout.readline().strip()\n        reply = None\n\n        if output.startswith(\"Oikea\"):\n            print(f\"[PRE-GAME] {output}\")\n            continue\n\n        if \"sy\u00f6t\u00e4\" in output.lower():\n            pipe.stdin.write(\"500\\n\")\n            pipe.stdin.flush()\n            reply = pipe.stdout.readline().strip().lower()\n\n        if reply:\n            if \"oikein\" in reply:\n                return guess\n            guess += 1\n\n    return -1 # Not found\n\ndef binary_search(pipe: subprocess.Popen) -&gt; int:\n    pass\n\ndef guess_number(script: Path, solver):\n    process = subprocess.Popen(\n        [ \"python\", script],\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        text=True, \n        encoding=\"utf-8\"\n    )\n\n    # Call the solver function\n    print(f\"[INFO] Solver: {solver.__name__}\")\n    correct = solver(process)\n    process.terminate()\n\n    return correct\n\nif __name__ == \"__main__\":\n\n    SCRIPT = Path(\"./scripts/arvaaluku.py\")\n    assert SCRIPT.exists(), f\"Script not found: {SCRIPT.resolve()}\"\n\n    # Extra challenge: Handle different solvers with argparse\n    # solvers = [brute_force, binary_search]\n    # ...\n    # solver = solvers[args.solver]\n    solver = brute_force\n\n    correct = guess_number(SCRIPT, solver)\n    print(f\"[MAIN] Correct number: {correct}\")\n</code></pre> <p>Alla on esiteltyn\u00e4 lopullinen koodin toimivuus ja k\u00e4ytt\u00f6 <code>brute_force</code>-solverilla. Huomaa, ett\u00e4 tuloste on s\u00e4\u00e4detty siten, ett\u00e4 se tulostaa vain <code>guess == 1</code> tai <code>guess % 50</code> arvaukset, jotta tuloste ei ole liian pitk\u00e4. Siksi vain joka viideskymmenes arvaus tulostetaan.</p> \ud83d\udc33 Bash<pre><code>$ python scripts/arvaaluku_bot.py \n[INFO] Solver: brute_force\n[PRE-GAME] Oikea vastaus: 380\n[BOT] Guessing: 1\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 1.\n[BOT] Guessing: 50\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 50.\n[BOT] Guessing: 100\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 100.\n[BOT] Guessing: 150\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 150.\n[BOT] Guessing: 200\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 200.\n[BOT] Guessing: 250\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 250.\n[BOT] Guessing: 300\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 300.\n[BOT] Guessing: 350\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 350.\n\n=== Found ===\n[&gt;&gt;&gt;] \ud83c\udf89 oikein! arvasit luvun 380. (peliaika: 0h 0m 0s)\n[MAIN] Correct number: 380\n</code></pre> <p>Alta voit klikata auki binary search -tulosteesta esimerkin:</p> Binary Search tuloste <pre><code>python scripts/arvaaluku_bot.py 1\n[INFO] Solver: binary_search\n[PRE-GAME] Arvaa luku v\u00e4lilt\u00e4 1-1000.\n[PRE-GAME] Muu sy\u00f6te kuin positiviinen kokoluku poistuu ohjelmasta.\n[PRE-GAME] Oikea vastaus: 622\n[PRE-GAME] \n[PRE-GAME] Sy\u00f6t\u00e4 arvaus:\n[BOT] Guessing: 500 (1\u2e3a1000)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 500.\n[BOT] Guessing: 750 (501\u2e3a1000)\n[&gt;&gt;&gt;] \ud83d\udcc9 luku on pienempi kuin 750.\n[BOT] Guessing: 625 (501\u2e3a749)\n[&gt;&gt;&gt;] \ud83d\udcc9 luku on pienempi kuin 625.\n[BOT] Guessing: 562 (501\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 562.\n[BOT] Guessing: 593 (563\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 593.\n[BOT] Guessing: 609 (594\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 609.\n[BOT] Guessing: 617 (610\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 617.\n[BOT] Guessing: 621 (618\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc8 luku on suurempi kuin 621.\n[BOT] Guessing: 623 (622\u2e3a624)\n[&gt;&gt;&gt;] \ud83d\udcc9 luku on pienempi kuin 623.\n[BOT] Guessing: 622 (622\u2e3a622)\n[&gt;&gt;&gt;] \ud83c\udf89 oikein! arvasit luvun 622. (peliaika: 0h 0m 0s)\n[MAIN] Correct number: 622\n</code></pre> <p>Huomaa, ett\u00e4 vastaus l\u00f6ytyy huonoimmassa tapauksessa <code>log2(1000)</code> eli kymmenell\u00e4 arvauksella, mik\u00e4 on huomattavasti nopeampaa kuin brute force -ratkaisu, joka vaatii huonoimmassa tapauksessa 1000 arvausta.</p>"},{"location":"python/aloita/","title":"Python 101","text":""},{"location":"python/aloita/#perusteet","title":"Perusteet","text":""},{"location":"python/aloita/#missa-ajetaan","title":"Miss\u00e4 ajetaan?","text":""},{"location":"python/aloita/#docker","title":"Docker","text":"<p>Aivan kuten aiemmissa osioissa k\u00e4sitellyt kielet, my\u00f6s Python-kieliset skriptit voidaan ajaa Docker-kontissa. T\u00e4m\u00e4 on, aivan kuten ennenkin, kannattavaa jos teet jotakin riskialtista, kuten tuhoat tiedostoja. Kontti mahdollistaa ns. \"clean slate\" -ymp\u00e4rist\u00f6n, jossa ei ole mit\u00e4\u00e4n ylim\u00e4\u00e4r\u00e4ist\u00e4.</p>"},{"location":"python/aloita/#lokaalisti","title":"Lokaalisti","text":"<p>Python on valmiiksi asennettuna Ubuntussa ja monissa muissa Linux-jakeluissa. Windowsissa Pythonia ei ole valmiiksi asennettuna, mutta sen voi ladata ja asentaa Pythonin kotisivuilta. Asennuksen j\u00e4lkeen Python on k\u00e4ytett\u00e4viss\u00e4 komentorivilt\u00e4, kunhan muistat aktivoida Add Python to PATH -valinnan asennuksen aikana.</p> <p>Paketinhallinta... not today</p> <p> Kun luot Python-ohjelmaa tai -kirjastoa, k\u00e4yt\u00e4t todenn\u00e4k\u00f6isesti virtuaaliymp\u00e4rist\u00f6j\u00e4 tai jopa paketinhallintaaohjelmia, kuten Python Poetry tai uv.</p> <p> Kun kirjoitat skripti\u00e4, on jossain m\u00e4\u00e4rin oletettavaa, ett\u00e4 k\u00e4yt\u00e4t sit\u00e4 Python-versiota, mik\u00e4 sattuu olemaan asennettuna bin\u00e4\u00e4riss\u00e4 <code>/usr/bin/python3</code>.</p> <p>T\u00e4ss\u00e4 luvussa emme luo ohjelmia vaan irrallisia skriptej\u00e4. Pyrimme pit\u00e4m\u00e4\u00e4n asiat mahdollisimman yksinkertaisina, joten emme k\u00e4yt\u00e4 kohdekoneessa virtuaaliymp\u00e4rist\u00f6j\u00e4, paketinhallintaa, emmek\u00e4 edes asenna <code>pip</code>-paketteja. K\u00e4yt\u00e4mme sit\u00e4 Python-versiota, mik\u00e4 sattuu olemaan asennettuna. Lokaalissa koneessa saatamme asentaa paketteja, jotta meid\u00e4n ymp\u00e4rist\u00f6mme vastaa sit\u00e4, mik\u00e4 Debianissa on vakiona.</p> <p>Python on monilta osin cross-platform, joten skriptit toimivat samalla tavalla riippumatta siit\u00e4, ajatko niit\u00e4 Windowsissa, Linuxissa vai macOS:ss\u00e4. Esimerkiksi hakemistopolut k\u00e4ytt\u00e4ytyv\u00e4t <code>pathlib</code>-kirjaston avulla samalla tavalla riippumatta k\u00e4ytt\u00f6j\u00e4rjestelm\u00e4st\u00e4: <code>Path</code> on alustasta riippuen joko <code>WindowsPath</code> tai <code>PosixPath</code>.</p> <p>Warning</p> <p>Eroja tosin silti l\u00f6ytyy! Esimerkiksi tiedostoja kirjoittaessa kannattaa olla skarppina, ett\u00e4 m\u00e4\u00e4rit\u00e4t eksplitiittisesti tiedoston enkoodauksen, sill\u00e4 Windowsissa oletusenkoodaus on <code>win-1252</code>, kun taas Linuxissa ja macOS:ss\u00e4 se on <code>utf-8</code>.</p> <p>My\u00f6s Linux-jakelut voivat yll\u00e4tt\u00e4\u00e4 muutoksillaan. Debianissa (ja my\u00f6s Ubuntussa) on k\u00e4yt\u00f6ss\u00e4 <code>dist-packages</code>-hakemisto, joka ei ole standardi Pythonin osalta. T\u00e4m\u00e4 voi aiheuttaa esimerkiksi sen, ett\u00e4 Ubuntu-k\u00e4ytt\u00e4j\u00e4t luulevat <code>requests</code>-kirjaston olevan osa Pythonin Standard Library\u00e4.</p>"},{"location":"python/aloita/#mika-python-on","title":"Mik\u00e4 Python on?","text":"<p>Vapaasti suomennettu What is Python? Executive Summary on seuraava: </p> <p>Quote</p> <p>Python on tulkattava, olio-ohjelmointiin perustuva korkean tason ohjelmointikieli. Sen monipuoliset tietorakenteet, dynaaminen tyypitys ja sidonta tekev\u00e4t siit\u00e4 erinomaisen nopeaan sovelluskehitykseen sek\u00e4 skriptauskieleksi eri komponenttien yhdist\u00e4miseen. Selke\u00e4 ja helposti opittava syntaksi parantaa luettavuutta ja v\u00e4hent\u00e4\u00e4 yll\u00e4pitokustannuksia. Python tukee moduuleja ja paketteja, mik\u00e4 edist\u00e4\u00e4 koodin uudelleenk\u00e4ytt\u00f6\u00e4. Tulkki ja laaja vakiokirjasto ovat ilmaiseksi saatavilla kaikille merkitt\u00e4ville alustoille. <sup>2</sup></p> <p>Pythonin sijasta voisimme yht\u00e4 hyvin opiskella Perli\u00e4. Kumpikin kieli ponnistaa samankaltaisesta historiasta eli Unix-skriptauksesta. Aivan kuten <code>python3</code>, my\u00f6s <code>perl</code> on mit\u00e4 todenn\u00e4k\u00f6isimmin valmiiksi asennettuna jakelussasi. Perl on kenties kotikent\u00e4ll\u00e4 skriptauksessaan vahvemmassa asemassa. Pythonin oma dokumentaatio tiivist\u00e4\u00e4 sen n\u00e4in: \"As a consequence, Python comes close to Perl but rarely beats it in its original application domain; however Python has an applicability well beyond Perl's niche <sup>1</sup>\" Me k\u00e4yt\u00e4mme Pythonia monista syist\u00e4, joita yksi on se, ett\u00e4 kurssilla k\u00e4sitelty Ansible on kirjoitettu Pythonilla. Toinen on se, ett\u00e4 opiskelijat ovat usein jo k\u00e4ytt\u00e4neet Pythonia jossain muussa yhteydess\u00e4. Jos halut lukea Pythonin oman n\u00e4kemyksen kielen vahvuuksista, lue esimerkiksi Python Docs: Whetting Your Appetite</p> <p>Alla on piirakkakuvaajaan laskettuna Python, Perl ja Shell-skriptien sek\u00e4 Linux-bin\u00e4\u00e4rien m\u00e4\u00e4r\u00e4 <code>/usr/bin</code>-hakemistossa.</p> <pre><code>pie showData\n    title File types in bin\n    \"Python\" : 46\n    \"Perl\" : 50\n    \"Shell\" : 132\n    \"Binaries\" : 631</code></pre> Kuinka tiedostot laskettiin? <p>Komento on ajettu Multipassilla luodussa virtuaalikoneessa, jossa on arm64 Ubuntu 24.04. Komennon <code>find</code> syntaksi on hieman vaikea tulkita, mutta se suorittaa komennon <code>file &lt;file_1&gt; &lt;file_2&gt; &lt;file_...&gt;</code>. Kyseinen komento tulostaa rivin per tiedosto, joka sis\u00e4lt\u00e4\u00e4 p\u00e4\u00e4tellyt tiedostotyypin. N\u00e4m\u00e4 rivit putkitetaan grep-komennon filtter\u00f6it\u00e4v\u00e4ksi, ja lopulta lasketaan filtterin l\u00e4p\u00e4isseet rivit.</p> \u2623\ufe0f Bash<pre><code>$ # Count Python scripts in /bin\n$ find /usr/bin -type f -exec file {} \\+ | cut -d: -f2 | grep -i \"python\" | wc -l\n46\n$ # Count Perl\n$ find /usr/bin -type f -exec file {} \\+ | cut -d: -f2 | grep -i \"perl\" | wc -l\n50\n$ # Count Shell scripts\n$ find /usr/bin -type f -exec file {} \\+ | cut -d: -f2 | grep -i \"shell\" | wc -l\n132\n$ # Count binaries\n$ find /usr/bin -type f -exec file {} \\+ | grep \"ELF\" | wc -l\n631\n</code></pre>"},{"location":"python/aloita/#erot-shelleihin","title":"Erot shelleihin","text":"<p>Huomaa, ett\u00e4 Python ei k\u00e4ytt\u00e4ydy shellin\u00e4 samalla tavalla kuin Bash tai PowerShell. Pythonissa toki on olemassa niin sanottu Python Shell, mutta se ei ole shell sanan samassa merkityksess\u00e4. Pythonin Shell on \"REPL\" (Read-Eval-Print Loop), joka on interaktiivinen ohjelmointiymp\u00e4rist\u00f6. T\u00e4m\u00e4 tarkoittaa, ett\u00e4 voit kirjoittaa Python-koodia ja n\u00e4hd\u00e4 tuloksen v\u00e4litt\u00f6m\u00e4sti. Mik\u00e4 sen sitten erottaa Bashista tai PowerShellista? Et voi suorittaa j\u00e4rjestelm\u00e4komentoja suoraan Python Shelliss\u00e4. Eli siis <code>ls</code> ei tulosta hakemiston sis\u00e4lt\u00f6\u00e4, <code>cd</code> ei navigoi hakemistossa, <code>docker</code> ei kutsu Docker CLI:t\u00e4 ja niin edelleen.</p> <p>Selvyyden vuoksi t\u00e4ytyy painottaa, ett\u00e4 vaikka emme voi kutsua PATH:ssa olevia bin\u00e4\u00e4rej\u00e4 suoraan Python Shellist\u00e4, voimme kutsua niit\u00e4 <code>subprocess</code>-moduulin avulla. N\u00e4in my\u00f6s tulemme kurssin aikana tekem\u00e4\u00e4n.</p> <p></p> <p>Kuva 1: Python Shell on interaktiivinen ohjelmointiymp\u00e4rist\u00f6, jossa voit kirjoittaa Python-koodia ja n\u00e4hd\u00e4 tuloksen v\u00e4litt\u00f6m\u00e4sti. Huomaa, ett\u00e4 se k\u00e4ynnistet\u00e4\u00e4n tyypillisesti jonkin shellin child-prosessina: kuvan tapauksessa Bashin. Interaktiivista shelli\u00e4 voi k\u00e4ytt\u00e4\u00e4 leikkikentt\u00e4n\u00e4, mutta tyypillisesti Python ajetaan skriptin\u00e4.</p>"},{"location":"python/aloita/#ensimmainen-kontti","title":"Ensimm\u00e4inen kontti","text":"<p>Aivan kuten edellisiss\u00e4 osioissa, my\u00f6s Python-skriptit voidaan ajaa Docker-kontissa, mutta image pit\u00e4\u00e4 valita siten, ett\u00e4 Python 3 on asennettuna.</p> \ud83d\udda5\ufe0f Bash|Git Bash|PowerShell|CMD<pre><code>$ docker run -it --rm python:3.12\n</code></pre> <p>Komento suorittaa imagen default <code>Cmd</code>:n, joka on <code>python3</code>. Toisin sanoen k\u00e4ynnist\u00e4t Python Shellin. Vaihtoehtoisesti voit antaa sille parametriksi polun skriptiin. T\u00e4h\u00e4n tutustumme kurssin aikana.</p>"},{"location":"python/aloita/#skripti","title":"Skripti","text":""},{"location":"python/aloita/#sisalto","title":"Sis\u00e4lt\u00f6","text":"<p>Huomaa, ett\u00e4 shebang ei ole sin\u00e4ns\u00e4 osa Pythonia, eik\u00e4 tyypillinen Python-ohjelma sis\u00e4ll\u00e4 shebangi\u00e4. Alustamme on Unix-like, ja teemme skriptiohjelmointia, joten voimme kuitenkin hy\u00f6dynt\u00e4\u00e4 sit\u00e4 - ja n\u00e4in tekev\u00e4t <code>/usr/bin</code>-hakemiston Python-skriptitkin.</p> hello.py<pre><code>#!/usr/bin/env python3\n\nprint(\"Hello, world!\")\n</code></pre>"},{"location":"python/aloita/#inline-script-metadata","title":"\ud83c\udd95 Inline Script Metadata","text":"<p>Tulevaisuus</p> <p>T\u00e4m\u00e4 on tuore feature ja siksi otsikossa on \ud83c\udd95-emoji. Emme k\u00e4yt\u00e4 ominaisuutta kurssilla, mutta koska se liittyy vahvasti skriptaukseen ja lienee tulevaisuudessa yleinen k\u00e4yt\u00e4nt\u00f6, on hyv\u00e4 olla tietoinen siit\u00e4.</p> <p>PEP 723 (Python Enhancement Proposal) toi mukanaan Pythoniin uudistuksen Inline Script Metadata. Kuinka t\u00e4t\u00e4 sitten hy\u00f6dynnet\u00e4\u00e4n? Alla on esimerkki metadatan muotoilusta skriptin alkuun. Skripti\u00e4 ei voi ajaa suoraan Python 3.12:lla, vaan avuksi tarvitsee muita ty\u00f6kaluja, kuten <code>uv</code> tai <code>hatch</code>.</p> inline_metadata_example.py<pre><code># /// script\n# requires-python = \"&gt;=3.12\"\n# dependencies = [\n#   \"requests\",\n#   \"pydantic\",\n# ]\n# ///\n\nimport requests\nfrom pydantic import BaseModel\n\nclass Post(BaseModel):\n    userId: int\n    id: int\n    title: str\n    body: str\n\n# Fetch a dummy Post from REST API using Requests\nresponse = requests.get(\"https://jsonplaceholder.typicode.com/posts/1\")\npost = Post.model_validate_json(response.content)\nprint(post.title)\n</code></pre> <p>Jos <code>uv</code> on asennettuna, voit ajaa skriptin seuraavasti:</p> <pre><code>$ uv run inline_metadata_example.py\nInstalled 9 packages in 21ms\n[INFO] The title:  sunt aut facere repellat provident occaecati excepturi optio reprehenderit\n</code></pre> <p>Huomaa, ett\u00e4 inline-metadatassa listatut riippuvuudet (ja niiden riippuvuudet) asennettiin automaattisesti v\u00e4liaikaiseen ymp\u00e4rist\u00f6\u00f6n.</p> Ent\u00e4 kontissa? <p>Voit toki kokeilla samaa ominaisuutta my\u00f6s kontissa. Esimerkiksi n\u00e4in:</p> <pre><code>docker run --rm -v \"$(pwd)/scripts:/workspace\" ghcr.io/astral-sh/uv:debian uv run /workspace/inline_metadata_example.py\n</code></pre>"},{"location":"python/aloita/#ajaminen","title":"Ajaminen","text":"<p>Python skriptin voi ajaa joko argumenttina <code>python3</code>-ohjelmalle tai suoraan skriptin\u00e4, jos shebang on m\u00e4\u00e4ritelty, ja tiedosto on ajettava (executable, <code>x</code> file mode).</p> \ud83d\udda5\ufe0f Bash|Git Bash|PowerShell|CMD<pre><code>$ python3 hello.py\nHello, world!\n$ ./hello.py\nHello, world!\n</code></pre>"},{"location":"python/aloita/#bash-python-ajurina","title":"Bash Python-ajurina","text":"<p>On mahdollista hy\u00f6dynt\u00e4\u00e4 Python-kielt\u00e4 Bash-skriptiss\u00e4. T\u00e4m\u00e4 on hy\u00f6dyllist\u00e4, kun haluat suorittaa jonkin operaation, mik\u00e4 on merkitt\u00e4v\u00e4n vaikea toteuttaa Bashilla. Jopa kohtalaisen yksinkertaisissa tapauksissa Python voi edist\u00e4\u00e4 syntaksin selkeytt\u00e4 ja ymm\u00e4rrett\u00e4vyytt\u00e4 - ja t\u00e4m\u00e4 on t\u00e4rke\u00e4\u00e4, jos skripti\u00e4si joku muu joutuu lukemaan.</p> <p>Kuvitellaan esimerkki, ett\u00e4 sinun tulee selvitt\u00e4\u00e4, kuinka monta p\u00e4iv\u00e4\u00e4 on tietyss\u00e4 kuukaudessa. Mieti hetki, kuinka t\u00e4m\u00e4 voisi onnistua Bashiss\u00e4. T\u00e4m\u00e4n j\u00e4lkeen avaa alta vihjelaatikko, jossa on ainakin yksi ratkaisu t\u00e4h\u00e4n.</p> Vihje: Kuukauden p\u00e4iv\u00e4t Bashill\u00e4 <p>Voit toteuttaa t\u00e4m\u00e4n Bashilla k\u00e4ytt\u00e4m\u00e4ll\u00e4 case-lauseketta. Helmikuu vaatisi kuitenkin karkausvuosien osalta poikkeuksen. T\u00e4m\u00e4 ei ole maailman vaikein ohjelma, ja olet kenties jo aiemmassa harjoituksessa toteuttanut <code>is_leap_year</code> -funktion, jota voisi hy\u00f6dynt\u00e4\u00e4 t\u00e4ss\u00e4.</p> example_days_in_month.sh<pre><code>#!/bin/bash\n# Usage: days_in_month.sh [month] [year]\n\n# Source imaginery is_leap_year function\n. is_leap_year.sh\n\nmonth=$1\nyear=${1:-$(date +%Y)}\n\ncase $month in\n1|3|5|7|8|10|12) days=31 ;;\n4|6|9|11) days=30 ;;\n2) \n    if is_leap_year $year; then\n        days=29\n    else\n        days=28\n    fi\n    ;;\nesac\n</code></pre> <p>Saman voisi toteuttaa Pythonissa rautakoodattuna n\u00e4in:</p> days_in_month.py<pre><code>import calendar\nprint(calendar.monthrange(2025, 2)[1])\n</code></pre> <p>Voimme upottaa seuraavan Python-rimpsun Bashiin n\u00e4in:</p> days_in_month_python.sh<pre><code>#!/bin/bash -eu\n# Usage: days_in_month.sh [month] [year]\n\nmonth=$1\nyear=${2:-$(date +%Y)}\n\nn_days=$(python3 -c \"\nimport calendar\nprint(calendar.monthrange($year, $month)[1])\n\"\n)\n\necho \"Number of days in $month/$year: $n_days\"\n</code></pre> <p>Warning</p> <p>Miksi joku siis suosisi natiivia Bash-toteutusta? Yksi syy on, ett\u00e4 Linuxissa on aina jokin POSIX-yhteensopiva shell saatavilla, toisin kuin Python. Tyypillisist\u00e4 jakeluista <code>python3</code> l\u00f6ytyy, mutta konteissa ajetaan usein kovin karsittua imagea. Jos k\u00e4yt\u00e4t Pythonia skripteiss\u00e4, sinun pit\u00e4\u00e4 valita oikea image. Lis\u00e4ksi vuosikymmeni\u00e4 vanha POSIX-yhteensopivuus on melko vakaa verrattuna Pythonin versioyhteensopivuuteen.</p> <p>K\u00e4yt\u00e4nn\u00f6ss\u00e4 t\u00e4ss\u00e4 taistelevat siis <code>portability + stability</code> vs. <code>readability + maintainability</code>.</p> <p>T\u00e4h\u00e4n ei ole absoluuttisesti oikeaa ja v\u00e4\u00e4r\u00e4\u00e4 vastausta.</p>"},{"location":"python/aloita/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"<p>Teht\u00e4v\u00e4: Python informaatiohaku</p> <p>Muodosta itsellesi katalogi tarpeellisista l\u00e4hteist\u00e4. Python kehittyy aktiivisesti, joten suosi uusia l\u00e4hteit\u00e4. Alla pari suositusta, mist\u00e4 aloittaa etsint\u00e4:</p> <ol> <li>The Python Standard Library. Pythonin oman dokumentaation Standard Library -osio on korvaamattoman hyv\u00e4. Pythonin mukana tulevien moduulien dokumentaatio on t\u00e4\u00e4ll\u00e4. Kurssilla k\u00e4ytet\u00e4\u00e4n skriptaukseen liittyvi\u00e4 moduuleja, joista t\u00e4rkeimpin\u00e4 <code>os</code>, <code>sys</code>, <code>subprocess</code>, <code>argparse</code> ja <code>logging</code>. Mit\u00e4 mahtaa tehd\u00e4 esim. <code>calendar</code>? Ent\u00e4 <code>getpass</code>?</li> <li>DevHints.io: Python. Cheat sheet, joka sis\u00e4lt\u00e4\u00e4 kielen perusasiat yhdess\u00e4 paketissa. T\u00e4m\u00e4n ja ylemm\u00e4n l\u00e4hteet avulla saat jo yll\u00e4tt\u00e4v\u00e4n paljon aikaiseksi.</li> <li>Python strftime cheatsheet. Jos/kun p\u00e4\u00e4dyt pelaamaan p\u00e4iv\u00e4m\u00e4\u00e4rien formatoinnin kanssa, t\u00e4m\u00e4 cheat sheet on nopea apu.</li> <li>Python for DevOps: Learn Ruthlessly Effective Automation. Kirja l\u00f6ytyy korkeakoulun Finna-kirjastosta digitaalisena kopiona. Voit lukea sit\u00e4 selaimessa.</li> </ol> <p>Skriptaus on niin laaja k\u00e4site, ett\u00e4 hakusanoilla \"python scripting\" ei yleens\u00e4 l\u00f6yd\u00e4 mit\u00e4\u00e4n hy\u00f6dyllist\u00e4. Tee siis ensin tarkempi suunnitelma siit\u00e4, mit\u00e4 aiot tehd\u00e4, ja muodosta t\u00e4m\u00e4n avulla hakusanasi. Kielimallit voivat auttaa hahmottamaan, mill\u00e4 kirjastoilla haluamasi ratkaisu hoituu.</p> <p>Jos olet valmis sijoittamaan opiskeluusi rahaa, my\u00f6s seuraavat l\u00e4hteet voivat olla varteenotettavia:</p> <ul> <li>\ud83d\udcb0 Humble Bundle. Sivustolla on ajoittain tarjolla kirjoja, jotka k\u00e4sittelev\u00e4t Bash-skriptauksen perusteita. Tarjonta vaihtelee jatkuvasti, joten on tuurista kiinni, l\u00f6ytyyk\u00f6 sielt\u00e4 nyt mit\u00e4\u00e4n hy\u00f6dyllist\u00e4. Kirjapaketit maksavat yleens\u00e4 halvimmillaan noin 1-20 euroa.</li> <li>\ud83d\udcb0 O'Reilly. Kirjastoon kuuluu useiden eri julkaisijoiden kirjoja: O'Reilly, No Starch Press, Manning Publications, Packt, Apress ja monet muut. Luettavissa kuukausimaksulla.</li> <li>\ud83d\udcb0 Real Python: Subprocess. Real Python on maksullinen sivu, mutta maltillisen m\u00e4\u00e4r\u00e4n artikkeleita saa lukea ilmaiseksi. Kun tied\u00e4t, mit\u00e4 haluat, voit etsi\u00e4 tietoa tarkemmin t\u00e4\u00e4lt\u00e4. T\u00e4ss\u00e4 linkitetty artikkeli k\u00e4sittelee <code>subprocess</code>-moduulia, joka on t\u00e4rke\u00e4 osa Python-skriptauksen ty\u00f6kalupakkia.</li> </ul>"},{"location":"python/aloita/#lahteet","title":"L\u00e4hteet","text":"<ol> <li> <p>Python.org. Comparing Python to Other Languages. https://www.python.org/doc/essays/comparisons/\u00a0\u21a9</p> </li> <li> <p>Python.org. What is Python? Executive Summary. https://www.python.org/doc/essays/blurb/\u00a0\u21a9</p> </li> </ol>"},{"location":"python/lukeminen/","title":"Lukeminen","text":""},{"location":"python/lukeminen/#mista-on-kyse","title":"Mist\u00e4 on kyse?","text":"<p>Aloitetaan jo olemassa olevien skriptien lukemisesta. Aiemmissa luvuissa tutustuimme Bash ja PowerShell asennusskripteihin. Python ei ole Shell, joten on hieman harvinaisempaa, ett\u00e4 asennusskripti on kirjoitettu Pythonilla. Sen sijaan me pengomme <code>/usr/bin</code>-hakemistossa sijaitsevia Python-skriptej\u00e4.</p>"},{"location":"python/lukeminen/#skriptien-louhiminen","title":"Skriptien louhiminen","text":""},{"location":"python/lukeminen/#louhinta","title":"Louhinta","text":"<p>Alla on skripti, jolla voit kopioida kaikki Python-skriptit virtuaalikoneesta. Skripti noutaa kaikki virtuaalikoneen skriptit ja kopioi ne hakemistoon <code>$REPO/python/ubuntu_python/</code>. T\u00e4m\u00e4n sin\u00e4 toki jo tied\u00e4t, koska osaat tulkita aiempien lukujen oppien avulla skriptin sis\u00e4ll\u00f6n. T\u00e4m\u00e4n luvun ensimm\u00e4inen teht\u00e4v\u00e4 on luoda ja ajaa t\u00e4m\u00e4 skripti. Tarkempi teht\u00e4v\u00e4nanto on alempana otsikon Teht\u00e4v\u00e4t alla.</p> getscripts.sh<pre><code>#!/bin/bash\n# Usage: getscripts.sh [language]\n\nlanguage=${1:-python}\ndirname=\"ubuntu_$language\" \nvm_name=\"copycat\"\n\n# Create new virtual machine using multipass\nmultipass launch --name $vm_name lts\n\n# List all scripts in the system\ndeclare -a scripts\nIFS=$'\\n' read -d '' -r -a scripts &lt; &lt;(\n    multipass exec \"$vm_name\" -- find /usr/bin -type f -exec file {} \\+ | awk -F: -v lang=\"${language}\" 'tolower($2) ~ lang {print $1}'\n)\n\n# Copy all files\nfor script in \"${scripts[@]}\"; do\n  multipass transfer --parents ${vm_name}:$script ./$dirname/\n  echo \"Copied $script\"\ndone\n\n# Kill the virtual machine\nmultipass delete $vm_name\nmultipass purge\n</code></pre> <p>Tip</p> <p>Jos haluat hakea Perl-skriptit, aja sama komento argumentilla <code>perl</code>. Ne kopioidaan hakemistoon <code>$REPO/perl/ubuntu_perl/</code>. Et tarvitse Perl-skriptej\u00e4 t\u00e4ll\u00e4 kurssilla, mutta voit tutustua niihin ihan yleisen mielenkiinnon ja sivistyksen vuoksi.</p>"},{"location":"python/lukeminen/#katsaus","title":"Katsaus","text":"<p>Kun olet ajanut skriptin, sinulla on hakemisto, jossa on kaikki Python-skriptit. Seuraavaksi valitset kolme skripti\u00e4, joita tulet lukemaan. Valitse skriptit, jotka ovat tarpeeksi pitki\u00e4 ja monimutkaisia, jotta niiden lukeminen on mielek\u00e4st\u00e4. Alla on listaus helmikuussa 2025 Ubuntu 24.04:st\u00e4 l\u00f6ytyneist\u00e4 skripteist\u00e4 lyhyine kuvauksineen ja pituuksineen.</p> <p>Alla taulukossa vain ne, joiden pituus on yli 100. Loput l\u00f6ytyv\u00e4t admonitionin alta.</p> Name Lines Purpose unattended-upgrade 2522 Automates system package upgrades for security and stability. pygettext3.12 681 Extracts translatable strings from Python source files. ubuntu-security-status 579 Reports security status of installed Ubuntu packages. networkd-dispatcher 547 Dispatches network status changes to scripts. pastebinit 474 Uploads text to pastebin services from the command line. add-apt-repository 452 Manages PPAs and other APT repositories. apport-cli 419 Command-line interface for Ubuntu's crash reporting tool. rrsync 379 Restricted wrapper for rsync. hwe-support-status 369 Checks Ubuntu Hardware Enablement (HWE) support status. py3compile 323 Compiles Python 3 files to bytecode. oem-getlogs 307 Collects system logs for OEM support. ec2metadata 283 Retrieves instance metadata on AWS EC2. do-release-upgrade 260 Upgrades Ubuntu to a newer release. py3clean 210 Removes Python 3 bytecode files. apport-unpack 111 Extracts crash reports for debugging. jsonpatch 107 Applies JSON patches to JSON documents. &lt; 100 pitk\u00e4t Name Lines Purpose jsonpointer 69 Resolves JSON Pointer references. routel 62 Displays routing table information. json-patch-jsondiff 39 Generates and applies JSON patches. sosreport 35 Collects system diagnostic information. sos-collector 35 Collects sosreports from multiple systems. ubuntu-advantage 33 Manages Ubuntu Advantage cloud services. ssh-import-id 33 Imports SSH public keys from Launchpad/GitHub. pyserial-ports 33 Lists available serial ports. pyserial-miniterm 33 Simple terminal for serial communication. pybabel-python3 33 Manages translations in Python projects. netaddr 33 Provides network address manipulation utilities. cloud-init 33 Initializes cloud instances at boot. cloud-id 33 Identifies cloud instance metadata. automat-visualize3 33 Visualizes state machines from Automat library. landscape-sysinfo 26 Displays system information summary. sos 25 Command-line tool for gathering system information. twistd3 8 Runs Twisted-based applications as daemons. twist3 8 Twisted framework helper script. trial3 8 Runs unit tests for Twisted applications. tkconch3 8 SSH client using Twisted Conch. pyhtmlizer3 8 Converts Python source code to HTML. pygmentize 8 Highlights syntax of source code. markdown-it 8 Processes Markdown with markdown-it library. mailmail3 8 Sends email using the mailmail utility. jsonschema 8 Validates JSON data against schemas. conch3 8 Twisted Conch SSH framework utility. ckeygen3 8 Generates SSH keys using Twisted Conch. chardetect 8 Detects character encoding of text files. cftp3 8 FTP client using Twisted Conch. pydoc3.12 5 Displays Python documentation in a pager or web browser. <p>Kuinka lista tehtiin?</p> <p>Lista on alustettu komennolla:</p> <pre><code>cd ubuntu_python\nfind . -type f -exec wc -l {} \\; | sort -k1 -r\n</code></pre> <p>Kokeile ihmeess\u00e4 komentoa omassa hakemistossasi! Komennon tuloste on sy\u00f6tetty ChatGPT 4o -mallille, jota on pyydetty t\u00e4ydent\u00e4m\u00e4\u00e4n kunkin skriptin purpose. Huomaa, ett\u00e4 ChatGPT voi olla v\u00e4\u00e4r\u00e4ss\u00e4! Kun valitset omat kolme skripti\u00e4si, tarkista niiden osalta, ettei ChatGPT ole antanut virheellist\u00e4 tietoa.</p>"},{"location":"python/lukeminen/#tarpit","title":"T\u00e4rpit","text":"<p>T\u00e4m\u00e4n luvun toinen teht\u00e4v\u00e4 on tutustua Python-skripteihin, jotka kopioit virtuaalikoneesta host-koneellesi. Osa skripteist\u00e4 voi olla hieman vaikea l\u00e4hesty\u00e4, jos et ole Pythonin kanssa ennen ty\u00f6skennellyt. T\u00e4m\u00e4n otsikon alaotsikoissa k\u00e4sitell\u00e4\u00e4n muutamat vinkit, joiden avulla voit paremmin ymm\u00e4rt\u00e4\u00e4 skriptien toimintaa.</p>"},{"location":"python/lukeminen/#sisennys","title":"Sisennys","text":"<p>Toisin kuin Bash ja PowerShell, Python k\u00e4ytt\u00e4\u00e4 sisennyst\u00e4 (engl. indentation) koodin rakenteen m\u00e4\u00e4ritt\u00e4miseen. Aiempien kielten skripteiss\u00e4 olet n\u00e4hnyt sisennyst\u00e4 k\u00e4ytett\u00e4v\u00e4n, mutta syyn\u00e4 on pelkk\u00e4 luettavuuden parantaminen. Pythonissa sisennys vaikuttaa toiminnallisuuteen. Sivuoireena Pythonissa koodiblokin ymp\u00e4rille ei tarvitse laittaa sulkeita esimerkiksi if-lausekkeissa.</p> <p>Esimerkiksi:</p> <pre><code>if True:\n    print(\"&lt;= Huomaa sisennys. T\u00e4m\u00e4 toimii!\")\n\nif True:\nprint(\"&lt;= Huomaa puuttuva sisennys. T\u00e4m\u00e4 nostaa IndentationError-virheen!\")\n</code></pre> <p>Vertaa t\u00e4t\u00e4 PowerShellin syntaksin kanssa:</p> <pre><code>if ($true) {\nWrite-Host \"T\u00e4m\u00e4 toimii!\"; Write-Host \"T\u00e4m\u00e4kin toimii!\";\n    Write-Host \"Ja t\u00e4m\u00e4!\"\n}\n</code></pre> <p>Tip</p> <p>Sisennys voi olla esimerkiksi 2 v\u00e4lily\u00f6nti\u00e4, 4 v\u00e4lily\u00f6nti\u00e4 tai tabulaattori. Pythonin PEP 8 -ohjeistus suosittelee 4 v\u00e4lily\u00f6nnin k\u00e4ytt\u00f6\u00e4. Mink\u00e4 ikin\u00e4 valitsetkin, pid\u00e4 se koko skriptin (tai projektin) ajan samana.</p> <p>Puolipistett\u00e4 voi k\u00e4ytt\u00e4\u00e4 Pythonissa erottamaan monta komentoa toisistaan, mutta se ei ole konvention mukaista.</p>"},{"location":"python/lukeminen/#toimimattomat-importit","title":"Toimimattomat importit","text":"<p>Jos parsit Python-skripti\u00e4 lokaalilla koneella, joka ei ole Ubuntu, huomannet, ett\u00e4 VS Code varoittaa joidenkin importtien olevan toimimattomia.</p> <p></p> <p>Kuva 1: VS Code:n Pylance varoittaa keltaisella alleviivauksella, ett\u00e4 <code>jsonpatch</code>-moduuli on toimimaton. Kuvakaappaus on otettu macOS-koneelta, jossa ei ole kyseist\u00e4 moduulia. Parsittava tiedosto on <code>jsonpatch</code>.</p> <p>N\u00e4m\u00e4 toimimattomat importit liittyv\u00e4t Debian-pohjaisen Ubuntun tapaan k\u00e4ytt\u00e4\u00e4 suurta m\u00e4\u00e4r\u00e4\u00e4 esiasennettuja moduuleita. Moduulit l\u00f6ytyv\u00e4t hakekistosta: <code>/usr/lib/python3/dist-packages/</code>. Yll\u00e4 olevan esimerkin (ks. Kuva 1) ep\u00e4toimiva import <code>jsonpatch</code> ei suinkaan ole kyseinen tiedosto itse, vaikka kyseinen tiedosto sattuu olemaan nimelt\u00e4\u00e4n sama. Kyseess\u00e4 on <code>jsonpatch</code>-niminen kirjasto. Useimmat kirjastot l\u00f6ytyv\u00e4t PyPi:st\u00e4 eli Python Package Indexist\u00e4. N\u00e4inp\u00e4 esimerkiksi <code>jsonpatch</code>:n dokumentaatio l\u00f6ytyy osoitteesta: https://pypi.org/project/jsonpatch/.</p>"},{"location":"python/lukeminen/#multipass","title":"Multipass","text":"<p>Yll\u00e4 esitelty skripti luo virtuaalikoneen nimelt\u00e4\u00e4n <code>copycat</code>. Voit hy\u00f6dynt\u00e4\u00e4 vastaavia komentoja luomaan sinulle oman koneen, jonka sis\u00e4ll\u00e4 voit harjoitella interaktiivisia komentoja. Esimerkiksi:</p> <pre><code># Luo kone SKR(ipti)OH(jelmointi)\nmultipass launch --name skroh lts\n\n# N\u00e4et koneen tiedot n\u00e4in (esim. ip-osoite)\nmultipass info skroh\n\n# Avaa koneen terminaali\nmultipass shell skroh\n\n# Poista kone\nmultipass delete skroh\n\n# Poista j\u00e4\u00e4nteet\nmultipass purge\n</code></pre>"},{"location":"python/lukeminen/#skriptin-koeajo","title":"Skriptin koeajo","text":"<p>Skriptin ajaminen voi hyvin antaa konkretiaa siihen, mit\u00e4 skripti oikeastaan tekee. Olettaen ett\u00e4 olet Multipassilla luodun virtuaalikoneen sis\u00e4ll\u00e4, skriptien ajaminen on turvallista. Siisp\u00e4 kannattaa kokeilla, saatko esimerkiksi ChatGTP:n ja dokumentaation avulla skriptin tavalla tai toisella k\u00e4ytt\u00f6\u00f6n!</p> <p>Esimerkiksi skripti <code>/usr/bin/twist3</code> muuttuu paljon konkreettisemmaksi, kun kokeilet ajaa sit\u00e4. Alla on komennot, joilla Twisted-webbiserveri k\u00e4ynnistet\u00e4\u00e4n. Web-palvelimen lis\u00e4ksi Twisted osaa my\u00f6s DNS, FPT ja muita protokollia. Web-serveri on kuitenkin nopea testata, koska tarvitsemme vain <code>index.html</code>-tiedoston johonkin hakemistoon. Luodaan se <code>~/www</code>.</p> <pre><code>$ cd\n$ mkdir www\n$ echo 'Hello, world!' &gt; www/index.html\n$ /usr/bin/twist3 web --path=www\n2025-02-24T10:16:43+0200 [-] Site starting on 8080\n2025-02-24T10:16:43+0200 [twisted.web.server.Site#info] Starting factory &lt;twisted.web.server.Site object at 0xea8a0140fad0&gt;\n2025-02-24T10:16:43+0200 [twisted.application.runner._runner.Runner#info] Starting reactor...\n</code></pre> <p>Tip</p> <p>Tyypillinen kielimalli osaisi tarjota sinulle n\u00e4m\u00e4 komennot, jos min\u00e4 en niit\u00e4 tarjoaisi. K\u00e4yt\u00e4 teko\u00e4ly\u00e4 apuopettajanasi!  \ud83e\udd16</p> <p>Nyt voit avata selaimen ja menn\u00e4 osoitteeseen <code>http://&lt;multipass-vm-ip&gt;:8080</code>. Saat ip-osoitteen selville yll\u00e4 esitellyll\u00e4 <code>multipass info</code>-komennolla.</p> <p></p> <p>Kuva 2: Twisted www-palvelimen tarjoilema <code>index.html</code>-tiedosto n\u00e4kyy host-koneen selaimessa.</p> <p>Note</p> <p>Huomaa, ett\u00e4 <code>twist3</code> ja <code>twistd3</code> ovat eri skriptit. J\u00e4lkimm\u00e4isen <code>d</code> tulee sanasta daemon, joka tarkoittaa taustaprosessia. Jos ajat saman komennon sit\u00e4 vasten, syntynyt prosessi ei j\u00e4\u00e4 shelliin. L\u00f6yd\u00e4t sen prosessilistalta komennolla <code>ps aux | grep twist</code> ja voit tappaa sen komennolla <code>kill &lt;pid&gt;</code>.</p>"},{"location":"python/lukeminen/#tehtavat","title":"Teht\u00e4v\u00e4t","text":"Teht\u00e4v\u00e4: Python Devausymp\u00e4rist\u00f6 <p>Ensimm\u00e4isen\u00e4 teht\u00e4v\u00e4n\u00e4 luot itsellesi devausymp\u00e4rist\u00f6n. K\u00e4yt\u00e4nn\u00f6ss\u00e4 luot:</p> <ul> <li>Hakemistorakenteen teht\u00e4vien vastauksia varten</li> <li>Skriptin <code>getscripts.sh</code>, joka:<ul> <li>Sis\u00e4lt\u00e4\u00e4 yll\u00e4 esitellyn koodin, ja t\u00e4ten...</li> <li>K\u00e4ynnist\u00e4\u00e4 multipass-virtuaalikoneen nimelt\u00e4\u00e4n <code>copycat</code> \ud83d\udc31</li> <li>Kopioi skriptit sinun lokaalille koneelle <code>ubuntu_python/</code>-hakemistoon</li> <li>Tuhoaa virtuaalikoneen</li> </ul> </li> <li>Valitset ja s\u00e4ilyt\u00e4t n kappaletta Python-skriptej\u00e4, joita tulet lukemaan</li> <li>Saat tuhota loput skriptit</li> <li>Varmistat, ett\u00e4 kaikki tarpeellinen on versionhallinnassa</li> </ul> <p>On oletus, ett\u00e4 ty\u00f6skentelet yh\u00e4 samassa hakemistossa ja repositoriossa, miss\u00e4 Bash ja PowerShell-osiotkin on tehty. Esimerkiksi:</p> <p>\ud83d\udc27 linux: <code>/home/uname/Code/skriptiohjelmointi-2054/johnanderton</code></p> <p>Luo repositorion sis\u00e4lle uusi <code>python/</code>-hakemisto ja sen sis\u00e4lle sek\u00e4 yll\u00e4 mainittu skripti ett\u00e4 hakemisto skriptej\u00e4 varten. Repositoriosi rakenteen tulisi olla seuraavaa my\u00f6t\u00e4ilev\u00e4:</p> <pre><code>johnanderton\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 bash\n\u2502   \u2514\u2500\u2500 .gitkeep \n\u251c\u2500\u2500 pwsh\n\u2502   \u2514\u2500\u2500 .gitkeep \n\u2514\u2500\u2500 python\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 getscripts.sh\n    \u2514\u2500\u2500 scripts\n        \u251c\u2500\u2500 kaikki.py\n        \u251c\u2500\u2500 skriptit.py\n        \u2514\u2500\u2500 tanne.py\n</code></pre> <p>Tiedosto <code>getscripts.sh</code>:n sis\u00e4lt\u00f6 on esitelty yll\u00e4. Luo ja aja se.</p> Teht\u00e4v\u00e4: Parsi Python-skriptit <p>Tee sama kuin teit Bashin ja PowerShellin vastaavassa teht\u00e4v\u00e4ss\u00e4. Erona on se, ett\u00e4 skriptit eiv\u00e4t ole t\u00e4ll\u00e4 kertaa netist\u00e4 l\u00f6ytyvi\u00e4 (tai l\u00f6ytyisi ne sielt\u00e4kin), vaan skriptit on louhittu virtuaalikoneen sis\u00e4lt\u00e4. Muista, ett\u00e4 sinun ei tarvitse ymm\u00e4rt\u00e4\u00e4 syv\u00e4llisesti aivan jokaisen rivin toimintaa. Tutustu skriptiin ja sen syntaksiin pinnallisesti. Tutki, kuinka skripti on rakennettu ja mit\u00e4 se tekee yleisell\u00e4 tasolla, ja mist\u00e4 konkreettisista palasista (esim. <code>if</code>) se koostuu.</p> <p>Vaiheet:</p> <ol> <li>Tee yll\u00e4 oleva teht\u00e4v\u00e4, jotta <code>ubuntu_python/</code>-hakemistossa on skriptit</li> <li>Valitse kolme skripti\u00e4. <ul> <li>\u00c4l\u00e4 valitse liian lyhyit\u00e4.</li> <li>Voit tuhota loput skriptit.</li> </ul> </li> <li>Aloita tiedoston ylh\u00e4\u00e4lt\u00e4 ja prosessoi se rivi rivilt\u00e4.</li> </ol> <p>Tee seuraavat toimenpiteet jokaiselle skriptille:</p> <ul> <li>\u2705 Jos koodirivi sis\u00e4lt\u00e4\u00e4 entuudestaan vierasta syntaksia: dokumentoi se. \ud83d\udcc4</li> <li>\ud83d\udd01 Jos koodirivin syntaksi on jo esiintynyt aiemmin scriptiss\u00e4: unohda rivi. \ud83e\udef3</li> <li>(Optional: T\u00e4m\u00e4n j\u00e4lkeen poista kyseinen koodirivi tiedostosta.)</li> </ul> <p>T\u00e4m\u00e4n pit\u00e4isi olla sinulle jo entuudestaan tuttua.</p> <p>Ajans\u00e4\u00e4t\u00f6\u00e4 teko\u00e4lyll\u00e4! \ud83e\udd16</p> <p>T\u00e4m\u00e4n pit\u00e4isi olla sinulle aiemmista luvuista tuttu ohje! On suorastaan suositeltua k\u00e4ytt\u00e4\u00e4 teko\u00e4ly\u00e4 apuna selitt\u00e4m\u00e4\u00e4n, mit\u00e4 kyseiset Powershell-kielen entuudestaan tuntemattomat koodirimpsut tekev\u00e4t. \u00c4l\u00e4 ulkoista omia aivojasi, vaan k\u00e4yt\u00e4 teko\u00e4ly\u00e4 apuna!</p>"}]}